{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useChatApi.js\nimport { useState, useCallback } from 'react';\nimport { getApiUrl } from '../utils/apiConfig';\nimport { GREETING_CACHE } from '../utils/greetingCache';\n\n// 轮询间隔和最大尝试次数\nconst POLL_INTERVAL = 5000;\nconst MAX_POLL_ATTEMPTS = 60;\nconst API_URL = getApiUrl();\n\n// 简单的哈希函数，用于识别重复问题\nfunction hashString(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash = (hash << 5) - hash + str.charCodeAt(i);\n    hash |= 0; // 转换为32位整数\n  }\n  return hash;\n}\nfunction useChatApi(sessionId, setSessionId) {\n  _s();\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [pendingRequests] = useState(new Map());\n  const [streamFailureCount, setStreamFailureCount] = useState(0);\n\n  // 发起初始请求，获取requestId或直接获取答案\n  const initiateRequest = useCallback(async (question, useStream = false) => {\n    try {\n      // 创建问题的哈希值以识别重复请求\n      const questionHash = hashString(question);\n\n      // 检查是否已经在处理这个问题\n      if (pendingRequests.has(questionHash)) {\n        console.log(\"这个问题的请求已在进行中\");\n        return {\n          inProgress: true\n        };\n      }\n\n      // 添加到待处理请求\n      pendingRequests.set(questionHash, true);\n      try {\n        // 判断是否是简单问题\n        const isSimpleQuestion = question.length < 50 && !question.includes(\"如何\") && !question.includes(\"为什么\") && !question.includes(\"比较\");\n        const normalizedQuestion = question.toLowerCase().trim();\n\n        // 检查是否是简单问候语\n        if (GREETING_CACHE[normalizedQuestion] && !useStream) {\n          return {\n            directAnswer: true,\n            answer: GREETING_CACHE[normalizedQuestion]\n          };\n        }\n        let retries = 0;\n        const maxRetries = 3;\n        let lastError = null;\n        while (retries < maxRetries) {\n          try {\n            const response = await fetch(`${API_URL}/rag`, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                'Cache-Control': 'no-cache'\n              },\n              body: JSON.stringify({\n                question,\n                sessionId: sessionId,\n                preferFastResponse: isSimpleQuestion && !useStream,\n                stream: useStream\n              })\n            });\n            if (!response.ok) {\n              const errorText = await response.text();\n              throw new Error(`服务器错误 (${response.status}): ${errorText}`);\n            }\n            const data = await response.json();\n            console.log(\"API响应收到:\", Object.keys(data));\n            if (data.sessionId) {\n              setSessionId(data.sessionId);\n            }\n            if (data.answer) {\n              console.log(\"收到后端直接回答\");\n              return {\n                directAnswer: true,\n                answer: data.answer\n              };\n            }\n            if (data.streamConfig) {\n              console.log(\"收到流式配置\");\n              return {\n                directAnswer: false,\n                streamConfig: data.streamConfig,\n                requestId: data.requestId\n              };\n            }\n            if (data.quickResponse) {\n              console.log(\"收到快速响应\");\n              return {\n                directAnswer: false,\n                quickResponse: data.quickResponse,\n                requestId: data.requestId\n              };\n            }\n            if (data.fallbackToStandard) {\n              console.log(\"不支持流式响应，回退到标准处理\");\n              return initiateRequest(question, false);\n            }\n            return {\n              directAnswer: false,\n              requestId: data.requestId\n            };\n          } catch (error) {\n            lastError = error;\n            retries++;\n            console.warn(`请求尝试${retries}失败: ${error.message}`);\n            if (retries < maxRetries) {\n              const delay = Math.pow(2, retries) * 1000;\n              console.log(`${delay}ms后重试...`);\n              await new Promise(resolve => setTimeout(resolve, delay));\n            }\n          }\n        }\n        throw lastError || new Error('所有请求尝试均失败');\n      } finally {\n        // 处理完毕后从待处理请求中移除\n        pendingRequests.delete(questionHash);\n      }\n    } catch (error) {\n      console.error('初始化请求失败:', error);\n      throw error;\n    }\n  }, [pendingRequests, sessionId, setSessionId]);\n\n  // 处理流式响应\n  const handleStreamingResponse = useCallback(async (streamConfig, onMessageUpdate) => {\n    try {\n      var _streamConfig$message, _streamConfig$message2;\n      console.log(\"设置流式连接...\");\n\n      // 验证流式配置\n      if (!streamConfig || !streamConfig.apiEndpoint || !streamConfig.model || !streamConfig.apiKey) {\n        console.error(\"无效的流式配置:\", JSON.stringify({\n          ...streamConfig,\n          apiKey: streamConfig && streamConfig.apiKey ? \"[REDACTED]\" : undefined\n        }, null, 2));\n        throw new Error(\"流式配置无效，无法建立连接\");\n      }\n\n      // 调试信息\n      console.log(\"流式配置详情:\", {\n        endpoint: streamConfig.apiEndpoint,\n        model: streamConfig.model,\n        messageCount: ((_streamConfig$message = streamConfig.messages) === null || _streamConfig$message === void 0 ? void 0 : _streamConfig$message.length) || 0\n      });\n\n      // 创建请求体\n      const requestBody = {\n        model: streamConfig.model,\n        messages: streamConfig.messages || [{\n          role: \"user\",\n          content: \"请提供回答\"\n        }],\n        stream: true,\n        temperature: 0.7,\n        max_tokens: 1024\n      };\n\n      // 创建fetch选项\n      const options = {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${streamConfig.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      };\n\n      // 发送请求\n      console.log(\"发送流式请求到:\", streamConfig.apiEndpoint);\n      const response = await fetch(streamConfig.apiEndpoint, options);\n\n      // 检查响应状态\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(\"流式API错误响应:\", errorText);\n        throw new Error(`API返回错误状态: ${response.status}`);\n      }\n      console.log(\"流式连接已建立，开始读取...\");\n\n      // 设置流式读取器\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder(\"utf-8\");\n      let fullResponse = '';\n\n      // 处理流式数据\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          console.log(\"流式传输完成\");\n          break;\n        }\n\n        // 解码数据块\n        const chunk = decoder.decode(value);\n        console.log(\"接收到数据块，大小:\", chunk.length);\n        const lines = chunk.split('\\n');\n        for (const line of lines) {\n          if (line.startsWith('data:')) {\n            const data = line.slice(5).trim();\n            if (data === '[DONE]') {\n              continue;\n            }\n            try {\n              const parsed = JSON.parse(data);\n              if (parsed.choices && parsed.choices[0].delta && parsed.choices[0].delta.content) {\n                const content = parsed.choices[0].delta.content;\n                fullResponse += content;\n\n                // 更新UI\n                onMessageUpdate(fullResponse);\n              }\n            } catch (parseError) {\n              console.warn(\"无法解析流式数据块:\", parseError.message);\n            }\n          }\n        }\n      }\n      console.log(\"流式处理成功完成\");\n\n      // 更新会话历史\n      const userQuestion = ((_streamConfig$message2 = streamConfig.messages.find(m => m.role === 'user')) === null || _streamConfig$message2 === void 0 ? void 0 : _streamConfig$message2.content) || '';\n      await updateSessionAfterStreaming(sessionId, userQuestion, fullResponse);\n\n      // 成功时重置失败计数\n      setStreamFailureCount(0);\n      return fullResponse;\n    } catch (error) {\n      console.error(\"流式处理错误:\", error);\n\n      // 增加失败计数\n      setStreamFailureCount(prev => prev + 1);\n\n      // 返回false表示失败，触发回退处理\n      return false;\n    }\n  }, [sessionId]);\n\n  // 更新流式处理后的会话\n  const updateSessionAfterStreaming = useCallback(async (sessionId, question, answer) => {\n    try {\n      console.log(\"更新流式处理后的会话:\", sessionId);\n      const response = await fetch(`${API_URL}/status`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          updateSession: true,\n          sessionId: sessionId,\n          question: question,\n          answer: answer\n        })\n      });\n      const data = await response.json();\n      console.log(\"会话更新响应:\", data);\n      console.log(\"流式处理后会话已更新\");\n      return true;\n    } catch (error) {\n      console.error(\"更新流式处理后会话失败:\", error);\n      return false;\n    }\n  }, []);\n\n  // 轮询结果\n  const pollForResult = useCallback(async (requestId, attempts = 0) => {\n    try {\n      // 超出最大尝试次数时停止\n      if (attempts >= MAX_POLL_ATTEMPTS) {\n        console.log(`达到最大轮询次数${MAX_POLL_ATTEMPTS}`);\n        return {\n          status: \"timeout\",\n          requestId: requestId,\n          message: \"处理时间较长，请稍后检查结果。\"\n        };\n      }\n      console.log(`正在轮询请求ID: ${requestId}, 会话ID: ${sessionId}, 尝试次数: ${attempts + 1}`);\n      let response;\n      try {\n        // 使用POST请求进行轮询\n        response = await fetch(`${API_URL}/status`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-cache'\n          },\n          body: JSON.stringify({\n            requestId: requestId,\n            sessionId: sessionId\n          })\n        });\n        console.log(`轮询响应状态码: ${response.status}`);\n      } catch (fetchError) {\n        console.error(`轮询请求失败: ${fetchError.message}`);\n\n        // 如果POST失败，尝试使用GET作为备选方案\n        console.log(\"尝试使用GET请求作为备选方案...\");\n        response = await fetch(`${API_URL}/status?requestId=${encodeURIComponent(requestId)}&sessionId=${encodeURIComponent(sessionId)}`, {\n          method: 'GET',\n          headers: {\n            'Accept': 'application/json',\n            'Cache-Control': 'no-cache'\n          }\n        });\n        console.log(`备选GET请求响应状态码: ${response.status}`);\n      }\n      if (!response.ok) {\n        throw new Error(`服务器返回错误: ${response.status}`);\n      }\n      const result = await response.json();\n      console.log(\"轮询结果:\", result);\n\n      // 检查状态并处理\n      if (result.status === 'completed' && result.answer) {\n        console.log(\"收到回答:\", result.answer.substring(0, 50) + \"...\");\n        return result;\n      } else if (result.status === 'failed') {\n        console.error(\"请求失败:\", result.error);\n        return {\n          status: \"error\",\n          error: result.error || \"处理请求时出错\"\n        };\n      } else {\n        // 继续轮询\n        console.log(`状态: ${result.status}，等待${POLL_INTERVAL}ms后重试`);\n        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));\n        return pollForResult(requestId, attempts + 1);\n      }\n    } catch (error) {\n      console.error(\"轮询错误:\", error);\n\n      // 轮询出错后短暂等待然后重试\n      if (attempts < MAX_POLL_ATTEMPTS - 1) {\n        console.log(`轮询出错，${POLL_INTERVAL}ms后重试...`);\n        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));\n        return pollForResult(requestId, attempts + 1);\n      }\n      return {\n        status: \"error\",\n        error: error.message || \"轮询过程中遇到错误\"\n      };\n    }\n  }, [sessionId]);\n\n  // 检查特定请求的答案\n  const checkAnswer = useCallback(async requestId => {\n    if (!requestId) return null;\n    try {\n      const result = await pollForResult(requestId, 0);\n      return result;\n    } catch (error) {\n      console.error(\"检查答案失败:\", error);\n      return {\n        status: \"error\",\n        error: `检查失败: ${error.message}`\n      };\n    }\n  }, [pollForResult]);\n  return {\n    initiateRequest,\n    handleStreamingResponse,\n    pollForResult,\n    checkAnswer,\n    isProcessing,\n    setIsProcessing,\n    streamFailureCount\n  };\n}\n_s(useChatApi, \"ezoCRqqMI4YgaV/bhFnjNOdR83I=\");\nexport default useChatApi;","map":{"version":3,"names":["useState","useCallback","getApiUrl","GREETING_CACHE","POLL_INTERVAL","MAX_POLL_ATTEMPTS","API_URL","hashString","str","hash","i","length","charCodeAt","useChatApi","sessionId","setSessionId","_s","isProcessing","setIsProcessing","pendingRequests","Map","streamFailureCount","setStreamFailureCount","initiateRequest","question","useStream","questionHash","has","console","log","inProgress","set","isSimpleQuestion","includes","normalizedQuestion","toLowerCase","trim","directAnswer","answer","retries","maxRetries","lastError","response","fetch","method","headers","body","JSON","stringify","preferFastResponse","stream","ok","errorText","text","Error","status","data","json","Object","keys","streamConfig","requestId","quickResponse","fallbackToStandard","error","warn","message","delay","Math","pow","Promise","resolve","setTimeout","delete","handleStreamingResponse","onMessageUpdate","_streamConfig$message","_streamConfig$message2","apiEndpoint","model","apiKey","undefined","endpoint","messageCount","messages","requestBody","role","content","temperature","max_tokens","options","reader","getReader","decoder","TextDecoder","fullResponse","done","value","read","chunk","decode","lines","split","line","startsWith","slice","parsed","parse","choices","delta","parseError","userQuestion","find","m","updateSessionAfterStreaming","prev","updateSession","pollForResult","attempts","fetchError","encodeURIComponent","result","substring","checkAnswer"],"sources":["/Users/depblu/Documents/GitHub/JasonDepblu.github.io/src/hooks/useChatApi.js"],"sourcesContent":["// src/hooks/useChatApi.js\nimport { useState, useCallback } from 'react';\nimport { getApiUrl } from '../utils/apiConfig';\nimport { GREETING_CACHE } from '../utils/greetingCache';\n\n// 轮询间隔和最大尝试次数\nconst POLL_INTERVAL = 5000;\nconst MAX_POLL_ATTEMPTS = 60;\n\nconst API_URL = getApiUrl();\n\n// 简单的哈希函数，用于识别重复问题\nfunction hashString(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) - hash) + str.charCodeAt(i);\n    hash |= 0; // 转换为32位整数\n  }\n  return hash;\n}\n\nfunction useChatApi(sessionId, setSessionId) {\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [pendingRequests] = useState(new Map());\n  const [streamFailureCount, setStreamFailureCount] = useState(0);\n\n  // 发起初始请求，获取requestId或直接获取答案\n  const initiateRequest = useCallback(async (question, useStream = false) => {\n    try {\n      // 创建问题的哈希值以识别重复请求\n      const questionHash = hashString(question);\n\n      // 检查是否已经在处理这个问题\n      if (pendingRequests.has(questionHash)) {\n        console.log(\"这个问题的请求已在进行中\");\n        return { inProgress: true };\n      }\n\n      // 添加到待处理请求\n      pendingRequests.set(questionHash, true);\n\n      try {\n        // 判断是否是简单问题\n        const isSimpleQuestion = question.length < 50 &&\n                                !question.includes(\"如何\") &&\n                                !question.includes(\"为什么\") &&\n                                !question.includes(\"比较\");\n\n        const normalizedQuestion = question.toLowerCase().trim();\n\n        // 检查是否是简单问候语\n        if (GREETING_CACHE[normalizedQuestion] && !useStream) {\n          return {\n            directAnswer: true,\n            answer: GREETING_CACHE[normalizedQuestion]\n          };\n        }\n\n        let retries = 0;\n        const maxRetries = 3;\n        let lastError = null;\n\n        while (retries < maxRetries) {\n          try {\n            const response = await fetch(`${API_URL}/rag`, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                'Cache-Control': 'no-cache'\n              },\n              body: JSON.stringify({\n                question,\n                sessionId: sessionId,\n                preferFastResponse: isSimpleQuestion && !useStream,\n                stream: useStream\n              })\n            });\n\n            if (!response.ok) {\n              const errorText = await response.text();\n              throw new Error(`服务器错误 (${response.status}): ${errorText}`);\n            }\n\n            const data = await response.json();\n            console.log(\"API响应收到:\", Object.keys(data));\n\n            if (data.sessionId) {\n              setSessionId(data.sessionId);\n            }\n\n            if (data.answer) {\n              console.log(\"收到后端直接回答\");\n              return {\n                directAnswer: true,\n                answer: data.answer\n              };\n            }\n\n            if (data.streamConfig) {\n              console.log(\"收到流式配置\");\n              return {\n                directAnswer: false,\n                streamConfig: data.streamConfig,\n                requestId: data.requestId\n              };\n            }\n\n            if (data.quickResponse) {\n              console.log(\"收到快速响应\");\n              return {\n                directAnswer: false,\n                quickResponse: data.quickResponse,\n                requestId: data.requestId\n              };\n            }\n\n            if (data.fallbackToStandard) {\n              console.log(\"不支持流式响应，回退到标准处理\");\n              return initiateRequest(question, false);\n            }\n\n            return {\n              directAnswer: false,\n              requestId: data.requestId\n            };\n          } catch (error) {\n            lastError = error;\n            retries++;\n            console.warn(`请求尝试${retries}失败: ${error.message}`);\n\n            if (retries < maxRetries) {\n              const delay = Math.pow(2, retries) * 1000;\n              console.log(`${delay}ms后重试...`);\n              await new Promise(resolve => setTimeout(resolve, delay));\n            }\n          }\n        }\n\n        throw lastError || new Error('所有请求尝试均失败');\n      } finally {\n        // 处理完毕后从待处理请求中移除\n        pendingRequests.delete(questionHash);\n      }\n    } catch (error) {\n      console.error('初始化请求失败:', error);\n      throw error;\n    }\n  }, [pendingRequests, sessionId, setSessionId]);\n\n  // 处理流式响应\n  const handleStreamingResponse = useCallback(async (streamConfig, onMessageUpdate) => {\n    try {\n      console.log(\"设置流式连接...\");\n\n      // 验证流式配置\n      if (!streamConfig || !streamConfig.apiEndpoint || !streamConfig.model || !streamConfig.apiKey) {\n        console.error(\"无效的流式配置:\", JSON.stringify({\n          ...streamConfig,\n          apiKey: streamConfig && streamConfig.apiKey ? \"[REDACTED]\" : undefined\n        }, null, 2));\n        throw new Error(\"流式配置无效，无法建立连接\");\n      }\n\n      // 调试信息\n      console.log(\"流式配置详情:\", {\n        endpoint: streamConfig.apiEndpoint,\n        model: streamConfig.model,\n        messageCount: streamConfig.messages?.length || 0\n      });\n\n      // 创建请求体\n      const requestBody = {\n        model: streamConfig.model,\n        messages: streamConfig.messages || [{ role: \"user\", content: \"请提供回答\" }],\n        stream: true,\n        temperature: 0.7,\n        max_tokens: 1024\n      };\n\n      // 创建fetch选项\n      const options = {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${streamConfig.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      };\n\n      // 发送请求\n      console.log(\"发送流式请求到:\", streamConfig.apiEndpoint);\n      const response = await fetch(streamConfig.apiEndpoint, options);\n\n      // 检查响应状态\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(\"流式API错误响应:\", errorText);\n        throw new Error(`API返回错误状态: ${response.status}`);\n      }\n\n      console.log(\"流式连接已建立，开始读取...\");\n\n      // 设置流式读取器\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder(\"utf-8\");\n      let fullResponse = '';\n\n      // 处理流式数据\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          console.log(\"流式传输完成\");\n          break;\n        }\n\n        // 解码数据块\n        const chunk = decoder.decode(value);\n        console.log(\"接收到数据块，大小:\", chunk.length);\n\n        const lines = chunk.split('\\n');\n\n        for (const line of lines) {\n          if (line.startsWith('data:')) {\n            const data = line.slice(5).trim();\n\n            if (data === '[DONE]') {\n              continue;\n            }\n\n            try {\n              const parsed = JSON.parse(data);\n              if (parsed.choices && parsed.choices[0].delta && parsed.choices[0].delta.content) {\n                const content = parsed.choices[0].delta.content;\n                fullResponse += content;\n\n                // 更新UI\n                onMessageUpdate(fullResponse);\n              }\n            } catch (parseError) {\n              console.warn(\"无法解析流式数据块:\", parseError.message);\n            }\n          }\n        }\n      }\n\n      console.log(\"流式处理成功完成\");\n\n      // 更新会话历史\n      const userQuestion = streamConfig.messages.find(m => m.role === 'user')?.content || '';\n      await updateSessionAfterStreaming(sessionId, userQuestion, fullResponse);\n\n      // 成功时重置失败计数\n      setStreamFailureCount(0);\n\n      return fullResponse;\n    } catch (error) {\n      console.error(\"流式处理错误:\", error);\n\n      // 增加失败计数\n      setStreamFailureCount(prev => prev + 1);\n\n      // 返回false表示失败，触发回退处理\n      return false;\n    }\n  }, [sessionId]);\n\n  // 更新流式处理后的会话\n  const updateSessionAfterStreaming = useCallback(async (sessionId, question, answer) => {\n    try {\n      console.log(\"更新流式处理后的会话:\", sessionId);\n\n      const response = await fetch(`${API_URL}/status`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          updateSession: true,\n          sessionId: sessionId,\n          question: question,\n          answer: answer\n        })\n      });\n\n      const data = await response.json();\n      console.log(\"会话更新响应:\", data);\n\n      console.log(\"流式处理后会话已更新\");\n      return true;\n    } catch (error) {\n      console.error(\"更新流式处理后会话失败:\", error);\n      return false;\n    }\n  }, []);\n\n  // 轮询结果\n  const pollForResult = useCallback(async (requestId, attempts = 0) => {\n    try {\n      // 超出最大尝试次数时停止\n      if (attempts >= MAX_POLL_ATTEMPTS) {\n        console.log(`达到最大轮询次数${MAX_POLL_ATTEMPTS}`);\n        return {\n          status: \"timeout\",\n          requestId: requestId,\n          message: \"处理时间较长，请稍后检查结果。\"\n        };\n      }\n\n      console.log(`正在轮询请求ID: ${requestId}, 会话ID: ${sessionId}, 尝试次数: ${attempts + 1}`);\n\n      let response;\n\n      try {\n        // 使用POST请求进行轮询\n        response = await fetch(`${API_URL}/status`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-cache'\n          },\n          body: JSON.stringify({\n            requestId: requestId,\n            sessionId: sessionId\n          })\n        });\n\n        console.log(`轮询响应状态码: ${response.status}`);\n      } catch (fetchError) {\n        console.error(`轮询请求失败: ${fetchError.message}`);\n\n        // 如果POST失败，尝试使用GET作为备选方案\n        console.log(\"尝试使用GET请求作为备选方案...\");\n        response = await fetch(`${API_URL}/status?requestId=${encodeURIComponent(requestId)}&sessionId=${encodeURIComponent(sessionId)}`, {\n          method: 'GET',\n          headers: {\n            'Accept': 'application/json',\n            'Cache-Control': 'no-cache'\n          }\n        });\n\n        console.log(`备选GET请求响应状态码: ${response.status}`);\n      }\n\n      if (!response.ok) {\n        throw new Error(`服务器返回错误: ${response.status}`);\n      }\n\n      const result = await response.json();\n      console.log(\"轮询结果:\", result);\n\n      // 检查状态并处理\n      if (result.status === 'completed' && result.answer) {\n        console.log(\"收到回答:\", result.answer.substring(0, 50) + \"...\");\n        return result;\n      } else if (result.status === 'failed') {\n        console.error(\"请求失败:\", result.error);\n        return {\n          status: \"error\",\n          error: result.error || \"处理请求时出错\"\n        };\n      } else {\n        // 继续轮询\n        console.log(`状态: ${result.status}，等待${POLL_INTERVAL}ms后重试`);\n        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));\n        return pollForResult(requestId, attempts + 1);\n      }\n    } catch (error) {\n      console.error(\"轮询错误:\", error);\n\n      // 轮询出错后短暂等待然后重试\n      if (attempts < MAX_POLL_ATTEMPTS - 1) {\n        console.log(`轮询出错，${POLL_INTERVAL}ms后重试...`);\n        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));\n        return pollForResult(requestId, attempts + 1);\n      }\n\n      return {\n        status: \"error\",\n        error: error.message || \"轮询过程中遇到错误\"\n      };\n    }\n  }, [sessionId]);\n\n  // 检查特定请求的答案\n  const checkAnswer = useCallback(async (requestId) => {\n    if (!requestId) return null;\n\n    try {\n      const result = await pollForResult(requestId, 0);\n      return result;\n    } catch (error) {\n      console.error(\"检查答案失败:\", error);\n      return {\n        status: \"error\",\n        error: `检查失败: ${error.message}`\n      };\n    }\n  }, [pollForResult]);\n\n  return {\n    initiateRequest,\n    handleStreamingResponse,\n    pollForResult,\n    checkAnswer,\n    isProcessing,\n    setIsProcessing,\n    streamFailureCount\n  };\n}\n\nexport default useChatApi;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}