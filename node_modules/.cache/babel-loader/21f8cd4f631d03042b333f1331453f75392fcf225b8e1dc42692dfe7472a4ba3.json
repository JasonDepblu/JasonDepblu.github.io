{"ast":null,"code":"// src/hooks/useChatApi.js\nimport{useState,useCallback,useEffect}from'react';import{getApiUrl}from'../utils/apiConfig';import{GREETING_CACHE}from'../utils/greetingCache';// 轮询间隔和最大尝试次数\nconst POLL_INTERVAL=3000;const MAX_POLL_ATTEMPTS=60;const API_URL=getApiUrl();// 辅助函数：带超时的 fetch\nconst fetchWithTimeout=async function(url,options){let timeoutMs=arguments.length>2&&arguments[2]!==undefined?arguments[2]:30000;const controller=new AbortController();const timeoutId=setTimeout(()=>controller.abort(),timeoutMs);try{const response=await fetch(url,{...options,signal:controller.signal});clearTimeout(timeoutId);return response;}catch(error){clearTimeout(timeoutId);if(error.name==='AbortError'){throw new Error(`请求超时 (${timeoutMs}ms)`);}throw error;}};const fetchWithRetries=async function(url,options){let maxRetries=arguments.length>2&&arguments[2]!==undefined?arguments[2]:3;let lastError;for(let i=0;i<maxRetries;i++){try{return await fetchWithTimeout(url,options);}catch(error){console.error(`请求失败(尝试 ${i+1}/${maxRetries}):`,error);lastError=error;if(i<maxRetries-1){// 指数退避\nconst delay=Math.pow(2,i)*1000;await new Promise(resolve=>setTimeout(resolve,delay));}}}throw lastError;};// 简单的哈希函数，用于识别重复问题\nfunction hashString(str){let hash=0;for(let i=0;i<str.length;i++){hash=(hash<<5)-hash+str.charCodeAt(i);hash|=0;// 转换为32位整数\n}return hash;}function useChatApi(sessionId,setSessionId){const[isProcessing,setIsProcessing]=useState(false);const[pendingRequests]=useState(new Map());const[streamFailureCount,setStreamFailureCount]=useState(0);// 监控流式失败计数并处理\nuseEffect(()=>{// 如果流式传输多次失败，暂时禁用它\nif(streamFailureCount>3){console.log(\"流式传输多次失败，暂时禁用流式模式\");localStorage.setItem(\"disableStreaming\",\"true\");// 5分钟后重置\nsetTimeout(()=>{localStorage.removeItem(\"disableStreaming\");setStreamFailureCount(0);},5*60*1000);}},[streamFailureCount]);// 发起初始请求，获取requestId或直接获取答案\nconst initiateRequest=useCallback(async function(question){let useStream=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;console.log(`发起请求: sessionId=${sessionId}, useStream=${useStream}, 问题长度=${question.length}`);// 检查是否暂时禁用流式传输\nconst shouldDisableStreaming=localStorage.getItem(\"disableStreaming\")===\"true\";if(shouldDisableStreaming&&useStream){console.log(\"由于之前的失败，流式传输已暂时禁用\");useStream=false;}try{// 创建问题的哈希值以识别重复请求\nconst questionHash=hashString(question);// 检查是否已经在处理这个问题\nif(pendingRequests.has(questionHash)){console.log(\"这个问题的请求已在进行中\");return{inProgress:true};}// 添加到待处理请求\npendingRequests.set(questionHash,true);try{// 判断是否是简单问题\nconst isSimpleQuestion=question.length<50&&!question.includes(\"如何\")&&!question.includes(\"为什么\")&&!question.includes(\"比较\");const normalizedQuestion=question.toLowerCase().trim();// 检查是否是简单问候语\nif(GREETING_CACHE[normalizedQuestion]&&!useStream){return{directAnswer:true,answer:GREETING_CACHE[normalizedQuestion]};}let retries=0;const maxRetries=2;let lastError=null;console.log(\"完整 API URL:\",`${API_URL}/rag-background`);while(retries<maxRetries){try{console.log(`尝试请求 ${retries+1}/${maxRetries}...`);const response=await fetchWithTimeout(`${API_URL}/rag-background`,{method:'POST',headers:{'Content-Type':'application/json','Cache-Control':'no-cache'},body:JSON.stringify({question,sessionId:sessionId,preferFastResponse:isSimpleQuestion&&!useStream,stream:useStream})},30000);// 30秒超时\nif(!response.ok){const errorText=await response.text();throw new Error(`服务器错误 (${response.status}): ${errorText}`);}// 针对背景函数的特殊处理\nif(response.status===202){console.log(\"后台函数接受请求，正在异步处理中...\");// 背景函数通常只返回 minimal 信息，比如 requestId\nlet requestId;try{// 尝试解析响应体（部分背景函数可能包含 minimal JSON 信息）\nconst data=await response.json();requestId=data.requestId;}catch(e){// 如果解析失败，则尝试从响应头中获取 requestId\nrequestId=response.headers.get('x-request-id');}return{directAnswer:false,requestId:requestId,sessionId:sessionId};}// 普通的同步函数响应处理\nconst data=await response.json();console.log(\"API响应收到:\",Object.keys(data));if(data.sessionId){console.log(`更新会话ID: ${data.sessionId}`);setSessionId(data.sessionId);}if(data.answer){console.log(\"收到后端直接回答\");return{directAnswer:true,answer:data.answer};}if(data.streamConfig){console.log(\"收到流式配置:\",{hasEndpoint:!!data.streamConfig.apiEndpoint,hasApiKey:!!data.streamConfig.apiKey,model:data.streamConfig.model});return{directAnswer:false,streamConfig:data.streamConfig,requestId:data.requestId};}if(data.quickResponse){console.log(\"收到快速响应\");return{directAnswer:false,quickResponse:data.quickResponse,requestId:data.requestId};}if(data.fallbackToStandard){console.log(\"不支持流式响应，回退到标准处理\");return initiateRequest(question,false);}console.log(`收到请求ID: ${data.requestId}`);return{directAnswer:false,requestId:data.requestId,sessionId:data.sessionId||sessionId};}catch(error){lastError=error;retries++;console.warn(`请求尝试${retries}失败: ${error.message}`);if(retries<maxRetries){const delay=Math.pow(2,retries)*1000;console.log(`${delay}ms后重试...`);await new Promise(resolve=>setTimeout(resolve,delay));}}}// while (retries < maxRetries) {\n//   try {\n//\n//       console.log(`尝试请求 ${retries + 1}/${maxRetries}...`);\n//       const response = await fetchWithTimeout(`${API_URL}/rag-background`, {\n//         method: 'POST',\n//         headers: {\n//           'Content-Type': 'application/json',\n//           'Cache-Control': 'no-cache'\n//         },\n//         body: JSON.stringify({\n//           question,\n//           sessionId: sessionId,\n//           preferFastResponse: isSimpleQuestion && !useStream,\n//           stream: useStream\n//         })\n//       }, 30000); // 30秒超时\n//\n//       // console.log(\"API响应状态:\", JSON.parse(response.body));\n//\n//       if (!response.ok) {\n//         const errorText = await response.text();\n//         throw new Error(`服务器错误 (${response.status}): ${errorText}`);\n//       }\n//\n//\n//\n//       const data = await response.json();\n//       // console.log(\"API原始响应:\", data);\n//       //\n//       // const responseText = await response.text();\n//       //\n//       // // 尝试解析JSON\n//       // let data;\n//       // try {\n//       //   data = JSON.parse(responseText);\n//       //   console.log(\"API响应解析成功:\", Object.keys(data));\n//       // } catch (parseError) {\n//       //   console.error(\"JSON解析错误:\", parseError.message);\n//       //   throw new Error(`JSON解析失败: ${parseError.message}`);\n//       // }\n//       // // const data = reader\n//       //\n//       console.log(\"API响应收到:\", Object.keys(data));\n//\n//       if (data.sessionId) {\n//         console.log(`更新会话ID: ${data.sessionId}`);\n//         setSessionId(data.sessionId);\n//       }\n//\n//       if (data.answer) {\n//         console.log(\"收到后端直接回答\");\n//         return {\n//           directAnswer: true,\n//           answer: data.answer\n//         };\n//       }\n//\n//       if (data.streamConfig) {\n//         console.log(\"收到流式配置:\", {\n//           hasEndpoint: !!data.streamConfig.apiEndpoint,\n//           hasApiKey: !!data.streamConfig.apiKey,\n//           model: data.streamConfig.model\n//         });\n//         return {\n//           directAnswer: false,\n//           streamConfig: data.streamConfig,\n//           requestId: data.requestId\n//         };\n//       }\n//\n//       if (data.quickResponse) {\n//         console.log(\"收到快速响应\");\n//         return {\n//           directAnswer: false,\n//           quickResponse: data.quickResponse,\n//           requestId: data.requestId\n//         };\n//       }\n//\n//       if (data.fallbackToStandard) {\n//         console.log(\"不支持流式响应，回退到标准处理\");\n//         return initiateRequest(question, false);\n//       }\n//\n//       console.log(`收到请求ID: ${data.requestId}`);\n//       return {\n//         directAnswer: false,\n//         requestId: data.requestId,\n//         sessionId: data.sessionId || sessionId\n//       };\n//\n//   }\n//   catch\n//     (error)\n//     {\n//       lastError = error;\n//       retries++;\n//       console.warn(`请求尝试${retries}失败: ${error.message}`);\n//\n//       if (retries < maxRetries) {\n//         const delay = Math.pow(2, retries) * 1000;\n//         console.log(`${delay}ms后重试...`);\n//         await new Promise(resolve => setTimeout(resolve, delay));\n//       }\n//     }\n//\n// }\nthrow lastError||new Error('所有请求尝试均失败');}finally{// 处理完毕后从待处理请求中移除\npendingRequests.delete(questionHash);}}catch(error){console.error('初始化请求失败:',error);throw error;}},[pendingRequests,sessionId,setSessionId]);// 更新流式处理后的会话\nconst updateSessionAfterStreaming=useCallback(async(sessionId,question,answer)=>{try{console.log(\"更新流式处理后的会话:\",sessionId);const response=await fetchWithTimeout(`${API_URL}/status-background`,{method:'POST',headers:{'Content-Type':'application/json','Cache-Control':'no-cache'},body:JSON.stringify({updateSession:true,sessionId:sessionId,question:question,answer:answer})},15000);// 15秒超时\nconst data=await response.json();console.log(\"会话更新响应:\",data);console.log(\"流式处理后会话已更新\");return true;}catch(error){console.error(\"更新流式处理后会话失败:\",error);return false;}},[]);// 处理流式响应\nconst handleStreamingResponse=useCallback(async(streamConfig,onMessageUpdate)=>{try{var _streamConfig$message,_streamConfig$paramet,_streamConfig$paramet2,_streamConfig$paramet3,_streamConfig$message2;console.log(\"设置流式连接...\");// 验证流式配置\nif(!streamConfig||!streamConfig.apiEndpoint||!streamConfig.model||!streamConfig.apiKey){console.error(\"无效的流式配置:\",JSON.stringify({...streamConfig,apiKey:streamConfig&&streamConfig.apiKey?\"[REDACTED]\":undefined},null,2));throw new Error(\"流式配置无效，无法建立连接\");}// 调试信息\nconsole.log(\"流式配置详情:\",{endpoint:streamConfig.apiEndpoint,model:streamConfig.model,messageCount:((_streamConfig$message=streamConfig.messages)===null||_streamConfig$message===void 0?void 0:_streamConfig$message.length)||0});// 创建请求体\nconst requestBody={model:streamConfig.model,messages:streamConfig.messages||[{role:\"user\",content:\"请提供回答\"}],stream:true,temperature:((_streamConfig$paramet=streamConfig.parameters)===null||_streamConfig$paramet===void 0?void 0:_streamConfig$paramet.temperature)||0.7,max_tokens:((_streamConfig$paramet2=streamConfig.parameters)===null||_streamConfig$paramet2===void 0?void 0:_streamConfig$paramet2.max_tokens)||2048,top_p:((_streamConfig$paramet3=streamConfig.parameters)===null||_streamConfig$paramet3===void 0?void 0:_streamConfig$paramet3.top_p)||0.9};// 创建fetch选项\nconst options={method:'POST',headers:{'Authorization':`Bearer ${streamConfig.apiKey}`,'Content-Type':'application/json'},body:JSON.stringify(requestBody)};// 发送请求\nconsole.log(\"发送流式请求到:\",streamConfig.apiEndpoint);const response=await fetchWithTimeout(streamConfig.apiEndpoint,options,60000);// 60秒超时\n// 检查响应状态\nif(!response.ok){const errorText=await response.text();console.error(\"流式API错误响应:\",errorText);throw new Error(`API返回错误状态: ${response.status}`);}console.log(\"流式连接已建立，开始读取...\");// 设置流式读取器\nconst reader=response.body.getReader();console.log(\"Stream connection details:\",{responseOK:response.ok,bodyAvailable:!!response.body,statusCode:response.status});const decoder=new TextDecoder(\"utf-8\");let fullResponse='';// 初始化全局缓冲区\nlet buffer='';while(true){const{done,value}=await reader.read();if(done){console.log(\"流式传输完成\");break;}// 使用流式解码器并追加到缓冲区\nconst chunk=decoder.decode(value,{stream:true});console.log(\"接收到数据块，大小:\",chunk.length);// 将新读取的数据追加到缓冲区\nbuffer+=chunk;// 按行拆分缓冲区内容\nconst lines=buffer.split('\\n');// 可能最后一行数据是不完整的，保留最后一部分\nbuffer=lines.pop()||'';// 逐行处理数据\nfor(const line of lines){if(line.startsWith('data:')){const data=line.slice(5).trim();console.log(\"接收到数据:\",data);if(data==='[DONE]'){continue;}try{const parsed=JSON.parse(data);if(parsed.choices&&parsed.choices[0]&&parsed.choices[0].delta&&parsed.choices[0].delta.content){const content=parsed.choices[0].delta.content;fullResponse+=content;// 更新UI\nonMessageUpdate(fullResponse);}}catch(parseError){// 如果 JSON 解析失败，记录异常，后续可根据实际情况进一步调整重试逻辑\nconsole.warn(\"无法解析流式数据块:\",parseError.message);}}}}console.log(\"流式处理成功完成\");// 更新会话历史\nconst userQuestion=((_streamConfig$message2=streamConfig.messages.find(m=>m.role==='user'))===null||_streamConfig$message2===void 0?void 0:_streamConfig$message2.content)||'';await updateSessionAfterStreaming(sessionId,userQuestion,fullResponse);console.log(\"Updated message with content length:\",fullResponse.length);// 成功时重置失败计数\nsetStreamFailureCount(0);return fullResponse;}catch(error){console.error(\"Streaming error details:\",{message:error.message,stack:error.stack,streamConfig:{hasEndpoint:!!(streamConfig!==null&&streamConfig!==void 0&&streamConfig.apiEndpoint),hasKey:!!(streamConfig!==null&&streamConfig!==void 0&&streamConfig.apiKey),hasModel:!!(streamConfig!==null&&streamConfig!==void 0&&streamConfig.model)}});setStreamFailureCount(prev=>prev+1);return false;}},[sessionId,updateSessionAfterStreaming]);// 改进版的轮询函数\nconst pollForResult=useCallback(async function(requestId,sessionId){let attempts=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;// Don't attempt to poll with an invalid sessionId\nif(!sessionId||sessionId===\"null\"){console.log(\"Cannot poll without valid session ID\");return{status:\"error\",error:\"No valid session ID available\"};}console.log(`轮询中: requestId=${requestId}, sessionId=${sessionId}, attempts=${attempts}`);try{// 超出最大尝试次数时停止\nif(attempts>=MAX_POLL_ATTEMPTS){console.log(`达到最大轮询次数${MAX_POLL_ATTEMPTS}`);return{status:\"timeout\",requestId:requestId,message:\"处理时间较长，请稍后检查结果。\"};}console.log(`正在轮询请求ID: ${requestId}, 会话ID: ${sessionId}, 尝试次数: ${attempts+1}`);// 尝试不同的请求方法来提高成功率\nlet result=null;let success=false;// 方法 1: 使用 JSON 格式的 POST 请求，设置明确的 Content-Type\ntry{console.log(\"尝试方法 1: JSON POST\");const response=await fetchWithTimeout(`${API_URL}/status-background`,{method:'POST',headers:{'Content-Type':'application/json','Cache-Control':'no-cache'},body:JSON.stringify({requestId:requestId,sessionId:sessionId})},10000);// 10秒超时\nif(response.ok){result=await response.json();success=true;console.log(\"方法 1 成功\");}}catch(error){console.log(\"方法 1 失败:\",error.message);}// 方法 2: 使用 URLSearchParams 作为 POST 请求体\nif(!success){try{console.log(\"尝试方法 2: URLSearchParams POST\");const params=new URLSearchParams();params.append('requestId',requestId);params.append('sessionId',sessionId);const response=await fetchWithTimeout(`${API_URL}/status-background`,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded','Cache-Control':'no-cache'},body:params},10000);// 10秒超时\nif(response.ok){result=await response.json();success=true;console.log(\"方法 2 成功\");}}catch(error){console.log(\"方法 2 失败:\",error.message);}}// 如果所有尝试都失败\nif(!success){throw new Error(\"所有请求方法都失败\");}// 处理成功的结果\nif(result.status==='completed'&&result.answer){console.log(\"收到回答:\",result.answer.substring(0,50)+\"...\");return result;}else if(result.status==='failed'){console.error(\"请求失败:\",result.error);return{status:\"error\",error:result.error||\"处理请求时出错\"};}else{// 继续轮询\nconsole.log(`状态: ${result.status}，等待${POLL_INTERVAL}ms后重试`);await new Promise(resolve=>setTimeout(resolve,POLL_INTERVAL));// 修复：确保传递sessionId到轮询函数中\nreturn pollForResult(requestId,sessionId,attempts+1);}}catch(error){console.error(\"轮询错误:\",error);// 增加重试次数\nif(attempts<MAX_POLL_ATTEMPTS-1){console.log(`轮询出错，${POLL_INTERVAL}ms后重试...`);await new Promise(resolve=>setTimeout(resolve,POLL_INTERVAL));// 修复：确保传递sessionId到轮询函数中\nreturn pollForResult(requestId,sessionId,attempts+1);}// 如果达到最大重试次数，返回超时状态\nreturn{status:\"timeout\",requestId:requestId,message:\"处理时间较长，请稍后检查结果。\"};}},[]);// 检查特定请求的答案 - 修复为使用sessionId\nconst checkAnswer=useCallback(async requestId=>{if(!requestId)return null;try{// 修复：传递sessionId而非0\nconst result=await pollForResult(requestId,sessionId,0);return result;}catch(error){console.error(\"检查答案失败:\",error);return{status:\"error\",error:`检查失败: ${error.message}`};}},[pollForResult,sessionId]);// 添加sessionId到依赖数组\nreturn{initiateRequest,handleStreamingResponse,pollForResult,checkAnswer,isProcessing,setIsProcessing,streamFailureCount};}export default useChatApi;","map":{"version":3,"names":["useState","useCallback","useEffect","getApiUrl","GREETING_CACHE","POLL_INTERVAL","MAX_POLL_ATTEMPTS","API_URL","fetchWithTimeout","url","options","timeoutMs","arguments","length","undefined","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","clearTimeout","error","name","Error","fetchWithRetries","maxRetries","lastError","i","console","delay","Math","pow","Promise","resolve","hashString","str","hash","charCodeAt","useChatApi","sessionId","setSessionId","isProcessing","setIsProcessing","pendingRequests","Map","streamFailureCount","setStreamFailureCount","log","localStorage","setItem","removeItem","initiateRequest","question","useStream","shouldDisableStreaming","getItem","questionHash","has","inProgress","set","isSimpleQuestion","includes","normalizedQuestion","toLowerCase","trim","directAnswer","answer","retries","method","headers","body","JSON","stringify","preferFastResponse","stream","ok","errorText","text","status","requestId","data","json","e","get","Object","keys","streamConfig","hasEndpoint","apiEndpoint","hasApiKey","apiKey","model","quickResponse","fallbackToStandard","warn","message","delete","updateSessionAfterStreaming","updateSession","handleStreamingResponse","onMessageUpdate","_streamConfig$message","_streamConfig$paramet","_streamConfig$paramet2","_streamConfig$paramet3","_streamConfig$message2","endpoint","messageCount","messages","requestBody","role","content","temperature","parameters","max_tokens","top_p","reader","getReader","responseOK","bodyAvailable","statusCode","decoder","TextDecoder","fullResponse","buffer","done","value","read","chunk","decode","lines","split","pop","line","startsWith","slice","parsed","parse","choices","delta","parseError","userQuestion","find","m","stack","hasKey","hasModel","prev","pollForResult","attempts","result","success","params","URLSearchParams","append","substring","checkAnswer"],"sources":["/Users/depblu/Documents/GitHub/JasonDepblu.github.io/src/hooks/useChatApi.js"],"sourcesContent":["// src/hooks/useChatApi.js\nimport { useState, useCallback, useEffect } from 'react';\nimport { getApiUrl } from '../utils/apiConfig';\nimport { GREETING_CACHE } from '../utils/greetingCache';\n\n// 轮询间隔和最大尝试次数\nconst POLL_INTERVAL = 3000;\nconst MAX_POLL_ATTEMPTS = 60;\n\nconst API_URL = getApiUrl();\n\n// 辅助函数：带超时的 fetch\nconst fetchWithTimeout = async (url, options, timeoutMs = 30000) => {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    return response;\n  } catch (error) {\n    clearTimeout(timeoutId);\n    if (error.name === 'AbortError') {\n      throw new Error(`请求超时 (${timeoutMs}ms)`);\n    }\n    throw error;\n  }\n};\nconst fetchWithRetries = async (url, options, maxRetries = 3) => {\n  let lastError;\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fetchWithTimeout(url, options);\n    } catch (error) {\n      console.error(`请求失败(尝试 ${i+1}/${maxRetries}):`, error);\n      lastError = error;\n\n      if (i < maxRetries - 1) {\n        // 指数退避\n        const delay = Math.pow(2, i) * 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  throw lastError;\n};\n\n// 简单的哈希函数，用于识别重复问题\nfunction hashString(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) - hash) + str.charCodeAt(i);\n    hash |= 0; // 转换为32位整数\n  }\n  return hash;\n}\n\nfunction useChatApi(sessionId, setSessionId) {\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [pendingRequests] = useState(new Map());\n  const [streamFailureCount, setStreamFailureCount] = useState(0);\n\n  // 监控流式失败计数并处理\n  useEffect(() => {\n    // 如果流式传输多次失败，暂时禁用它\n    if (streamFailureCount > 3) {\n      console.log(\"流式传输多次失败，暂时禁用流式模式\");\n      localStorage.setItem(\"disableStreaming\", \"true\");\n      // 5分钟后重置\n      setTimeout(() => {\n        localStorage.removeItem(\"disableStreaming\");\n        setStreamFailureCount(0);\n      }, 5 * 60 * 1000);\n    }\n  }, [streamFailureCount]);\n\n  // 发起初始请求，获取requestId或直接获取答案\n  const initiateRequest = useCallback(async (question, useStream = false) => {\n    console.log(`发起请求: sessionId=${sessionId}, useStream=${useStream}, 问题长度=${question.length}`);\n\n    // 检查是否暂时禁用流式传输\n    const shouldDisableStreaming = localStorage.getItem(\"disableStreaming\") === \"true\";\n    if (shouldDisableStreaming && useStream) {\n      console.log(\"由于之前的失败，流式传输已暂时禁用\");\n      useStream = false;\n    }\n\n    try {\n      // 创建问题的哈希值以识别重复请求\n      const questionHash = hashString(question);\n\n      // 检查是否已经在处理这个问题\n      if (pendingRequests.has(questionHash)) {\n        console.log(\"这个问题的请求已在进行中\");\n        return { inProgress: true };\n      }\n\n      // 添加到待处理请求\n      pendingRequests.set(questionHash, true);\n\n      try {\n        // 判断是否是简单问题\n        const isSimpleQuestion = question.length < 50 &&\n                                !question.includes(\"如何\") &&\n                                !question.includes(\"为什么\") &&\n                                !question.includes(\"比较\");\n\n        const normalizedQuestion = question.toLowerCase().trim();\n\n        // 检查是否是简单问候语\n        if (GREETING_CACHE[normalizedQuestion] && !useStream) {\n          return {\n            directAnswer: true,\n            answer: GREETING_CACHE[normalizedQuestion]\n          };\n        }\n\n        let retries = 0;\n        const maxRetries = 2;\n        let lastError = null;\n\n        console.log(\"完整 API URL:\", `${API_URL}/rag-background`);\n\n        while (retries < maxRetries) {\n          try {\n            console.log(`尝试请求 ${retries + 1}/${maxRetries}...`);\n            const response = await fetchWithTimeout(`${API_URL}/rag-background`, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                'Cache-Control': 'no-cache'\n              },\n              body: JSON.stringify({\n                question,\n                sessionId: sessionId,\n                preferFastResponse: isSimpleQuestion && !useStream,\n                stream: useStream\n              })\n            }, 30000); // 30秒超时\n\n            if (!response.ok) {\n              const errorText = await response.text();\n              throw new Error(`服务器错误 (${response.status}): ${errorText}`);\n            }\n\n            // 针对背景函数的特殊处理\n            if (response.status === 202) {\n              console.log(\"后台函数接受请求，正在异步处理中...\");\n              // 背景函数通常只返回 minimal 信息，比如 requestId\n              let requestId;\n              try {\n                // 尝试解析响应体（部分背景函数可能包含 minimal JSON 信息）\n                const data = await response.json();\n                requestId = data.requestId;\n              } catch (e) {\n                // 如果解析失败，则尝试从响应头中获取 requestId\n                requestId = response.headers.get('x-request-id');\n              }\n              return {\n                directAnswer: false,\n                requestId: requestId,\n                sessionId: sessionId\n              };\n            }\n\n            // 普通的同步函数响应处理\n            const data = await response.json();\n            console.log(\"API响应收到:\", Object.keys(data));\n\n            if (data.sessionId) {\n              console.log(`更新会话ID: ${data.sessionId}`);\n              setSessionId(data.sessionId);\n            }\n\n            if (data.answer) {\n              console.log(\"收到后端直接回答\");\n              return {\n                directAnswer: true,\n                answer: data.answer\n              };\n            }\n\n            if (data.streamConfig) {\n              console.log(\"收到流式配置:\", {\n                hasEndpoint: !!data.streamConfig.apiEndpoint,\n                hasApiKey: !!data.streamConfig.apiKey,\n                model: data.streamConfig.model\n              });\n              return {\n                directAnswer: false,\n                streamConfig: data.streamConfig,\n                requestId: data.requestId\n              };\n            }\n\n            if (data.quickResponse) {\n              console.log(\"收到快速响应\");\n              return {\n                directAnswer: false,\n                quickResponse: data.quickResponse,\n                requestId: data.requestId\n              };\n            }\n\n            if (data.fallbackToStandard) {\n              console.log(\"不支持流式响应，回退到标准处理\");\n              return initiateRequest(question, false);\n            }\n\n            console.log(`收到请求ID: ${data.requestId}`);\n            return {\n              directAnswer: false,\n              requestId: data.requestId,\n              sessionId: data.sessionId || sessionId\n            };\n\n          } catch (error) {\n            lastError = error;\n            retries++;\n            console.warn(`请求尝试${retries}失败: ${error.message}`);\n\n            if (retries < maxRetries) {\n              const delay = Math.pow(2, retries) * 1000;\n              console.log(`${delay}ms后重试...`);\n              await new Promise(resolve => setTimeout(resolve, delay));\n            }\n          }\n        }\n\n        // while (retries < maxRetries) {\n        //   try {\n        //\n        //       console.log(`尝试请求 ${retries + 1}/${maxRetries}...`);\n        //       const response = await fetchWithTimeout(`${API_URL}/rag-background`, {\n        //         method: 'POST',\n        //         headers: {\n        //           'Content-Type': 'application/json',\n        //           'Cache-Control': 'no-cache'\n        //         },\n        //         body: JSON.stringify({\n        //           question,\n        //           sessionId: sessionId,\n        //           preferFastResponse: isSimpleQuestion && !useStream,\n        //           stream: useStream\n        //         })\n        //       }, 30000); // 30秒超时\n        //\n        //       // console.log(\"API响应状态:\", JSON.parse(response.body));\n        //\n        //       if (!response.ok) {\n        //         const errorText = await response.text();\n        //         throw new Error(`服务器错误 (${response.status}): ${errorText}`);\n        //       }\n        //\n        //\n        //\n        //       const data = await response.json();\n        //       // console.log(\"API原始响应:\", data);\n        //       //\n        //       // const responseText = await response.text();\n        //       //\n        //       // // 尝试解析JSON\n        //       // let data;\n        //       // try {\n        //       //   data = JSON.parse(responseText);\n        //       //   console.log(\"API响应解析成功:\", Object.keys(data));\n        //       // } catch (parseError) {\n        //       //   console.error(\"JSON解析错误:\", parseError.message);\n        //       //   throw new Error(`JSON解析失败: ${parseError.message}`);\n        //       // }\n        //       // // const data = reader\n        //       //\n        //       console.log(\"API响应收到:\", Object.keys(data));\n        //\n        //       if (data.sessionId) {\n        //         console.log(`更新会话ID: ${data.sessionId}`);\n        //         setSessionId(data.sessionId);\n        //       }\n        //\n        //       if (data.answer) {\n        //         console.log(\"收到后端直接回答\");\n        //         return {\n        //           directAnswer: true,\n        //           answer: data.answer\n        //         };\n        //       }\n        //\n        //       if (data.streamConfig) {\n        //         console.log(\"收到流式配置:\", {\n        //           hasEndpoint: !!data.streamConfig.apiEndpoint,\n        //           hasApiKey: !!data.streamConfig.apiKey,\n        //           model: data.streamConfig.model\n        //         });\n        //         return {\n        //           directAnswer: false,\n        //           streamConfig: data.streamConfig,\n        //           requestId: data.requestId\n        //         };\n        //       }\n        //\n        //       if (data.quickResponse) {\n        //         console.log(\"收到快速响应\");\n        //         return {\n        //           directAnswer: false,\n        //           quickResponse: data.quickResponse,\n        //           requestId: data.requestId\n        //         };\n        //       }\n        //\n        //       if (data.fallbackToStandard) {\n        //         console.log(\"不支持流式响应，回退到标准处理\");\n        //         return initiateRequest(question, false);\n        //       }\n        //\n        //       console.log(`收到请求ID: ${data.requestId}`);\n        //       return {\n        //         directAnswer: false,\n        //         requestId: data.requestId,\n        //         sessionId: data.sessionId || sessionId\n        //       };\n        //\n        //   }\n        //   catch\n        //     (error)\n        //     {\n        //       lastError = error;\n        //       retries++;\n        //       console.warn(`请求尝试${retries}失败: ${error.message}`);\n        //\n        //       if (retries < maxRetries) {\n        //         const delay = Math.pow(2, retries) * 1000;\n        //         console.log(`${delay}ms后重试...`);\n        //         await new Promise(resolve => setTimeout(resolve, delay));\n        //       }\n        //     }\n        //\n        // }\n\n        throw lastError || new Error('所有请求尝试均失败');\n      } finally {\n        // 处理完毕后从待处理请求中移除\n        pendingRequests.delete(questionHash);\n      }\n    } catch (error) {\n      console.error('初始化请求失败:', error);\n      throw error;\n    }\n  }, [pendingRequests, sessionId, setSessionId]);\n\n    // 更新流式处理后的会话\n  const updateSessionAfterStreaming = useCallback(async (sessionId, question, answer) => {\n    try {\n      console.log(\"更新流式处理后的会话:\", sessionId);\n\n      const response = await fetchWithTimeout(`${API_URL}/status-background`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache'\n        },\n        body: JSON.stringify({\n          updateSession: true,\n          sessionId: sessionId,\n          question: question,\n          answer: answer\n        })\n      }, 15000); // 15秒超时\n\n      const data = await response.json();\n      console.log(\"会话更新响应:\", data);\n\n      console.log(\"流式处理后会话已更新\");\n      return true;\n    } catch (error) {\n      console.error(\"更新流式处理后会话失败:\", error);\n      return false;\n    }\n  }, []);\n\n  // 处理流式响应\n  const handleStreamingResponse = useCallback(async (streamConfig, onMessageUpdate) => {\n    try {\n      console.log(\"设置流式连接...\");\n\n      // 验证流式配置\n      if (!streamConfig || !streamConfig.apiEndpoint || !streamConfig.model || !streamConfig.apiKey) {\n        console.error(\"无效的流式配置:\", JSON.stringify({\n          ...streamConfig,\n          apiKey: streamConfig && streamConfig.apiKey ? \"[REDACTED]\" : undefined\n        }, null, 2));\n        throw new Error(\"流式配置无效，无法建立连接\");\n      }\n\n      // 调试信息\n      console.log(\"流式配置详情:\", {\n        endpoint: streamConfig.apiEndpoint,\n        model: streamConfig.model,\n        messageCount: streamConfig.messages?.length || 0\n      });\n\n      // 创建请求体\n      const requestBody = {\n        model: streamConfig.model,\n        messages: streamConfig.messages || [{ role: \"user\", content: \"请提供回答\" }],\n        stream: true,\n        temperature: streamConfig.parameters?.temperature || 0.7,\n        max_tokens: streamConfig.parameters?.max_tokens || 2048,\n        top_p: streamConfig.parameters?.top_p || 0.9\n      };\n\n      // 创建fetch选项\n      const options = {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${streamConfig.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      };\n\n      // 发送请求\n      console.log(\"发送流式请求到:\", streamConfig.apiEndpoint);\n      const response = await fetchWithTimeout(streamConfig.apiEndpoint, options, 60000); // 60秒超时\n\n      // 检查响应状态\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(\"流式API错误响应:\", errorText);\n        throw new Error(`API返回错误状态: ${response.status}`);\n      }\n\n      console.log(\"流式连接已建立，开始读取...\");\n\n      // 设置流式读取器\n      const reader = response.body.getReader();\n      console.log(\"Stream connection details:\", {\n        responseOK: response.ok,\n        bodyAvailable: !!response.body,\n        statusCode: response.status\n      });\n      const decoder = new TextDecoder(\"utf-8\");\n      let fullResponse = '';\n\n      // 初始化全局缓冲区\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          console.log(\"流式传输完成\");\n          break;\n        }\n\n        // 使用流式解码器并追加到缓冲区\n        const chunk = decoder.decode(value, { stream: true });\n        console.log(\"接收到数据块，大小:\", chunk.length);\n\n        // 将新读取的数据追加到缓冲区\n        buffer += chunk;\n\n        // 按行拆分缓冲区内容\n        const lines = buffer.split('\\n');\n\n        // 可能最后一行数据是不完整的，保留最后一部分\n        buffer = lines.pop() || '';\n\n        // 逐行处理数据\n        for (const line of lines) {\n          if (line.startsWith('data:')) {\n            const data = line.slice(5).trim();\n            console.log(\"接收到数据:\", data);\n\n            if (data === '[DONE]') {\n              continue;\n            }\n\n            try {\n              const parsed = JSON.parse(data);\n              if (parsed.choices &&\n                  parsed.choices[0] &&\n                  parsed.choices[0].delta &&\n                  parsed.choices[0].delta.content\n              ) {\n                const content = parsed.choices[0].delta.content;\n                fullResponse += content;\n\n                // 更新UI\n                onMessageUpdate(fullResponse);\n              }\n            } catch (parseError) {\n              // 如果 JSON 解析失败，记录异常，后续可根据实际情况进一步调整重试逻辑\n              console.warn(\"无法解析流式数据块:\", parseError.message);\n            }\n          }\n        }\n      }\n\n      console.log(\"流式处理成功完成\");\n\n      // 更新会话历史\n      const userQuestion = streamConfig.messages.find(m => m.role === 'user')?.content || '';\n      await updateSessionAfterStreaming(sessionId, userQuestion, fullResponse);\n      console.log(\"Updated message with content length:\", fullResponse.length);\n\n      // 成功时重置失败计数\n      setStreamFailureCount(0);\n\n      return fullResponse;\n    } catch (error) {\n      console.error(\"Streaming error details:\", {\n        message: error.message,\n        stack: error.stack,\n        streamConfig: {\n          hasEndpoint: !!streamConfig?.apiEndpoint,\n          hasKey: !!streamConfig?.apiKey,\n          hasModel: !!streamConfig?.model\n        }\n      });\n      setStreamFailureCount(prev => prev + 1);\n      return false;\n    }\n  }, [sessionId, updateSessionAfterStreaming]);\n\n\n\n  // 改进版的轮询函数\n  const pollForResult = useCallback(async (requestId, sessionId, attempts = 0) => {\n    // Don't attempt to poll with an invalid sessionId\n    if (!sessionId || sessionId === \"null\") {\n      console.log(\"Cannot poll without valid session ID\");\n      return {\n        status: \"error\",\n        error: \"No valid session ID available\"\n      };\n    }\n\n    console.log(`轮询中: requestId=${requestId}, sessionId=${sessionId}, attempts=${attempts}`);\n\n    try {\n      // 超出最大尝试次数时停止\n      if (attempts >= MAX_POLL_ATTEMPTS) {\n        console.log(`达到最大轮询次数${MAX_POLL_ATTEMPTS}`);\n        return {\n          status: \"timeout\",\n          requestId: requestId,\n          message: \"处理时间较长，请稍后检查结果。\"\n        };\n      }\n\n      console.log(`正在轮询请求ID: ${requestId}, 会话ID: ${sessionId}, 尝试次数: ${attempts + 1}`);\n\n      // 尝试不同的请求方法来提高成功率\n      let result = null;\n      let success = false;\n\n      // 方法 1: 使用 JSON 格式的 POST 请求，设置明确的 Content-Type\n      try {\n        console.log(\"尝试方法 1: JSON POST\");\n        const response = await fetchWithTimeout(`${API_URL}/status-background`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-cache'\n          },\n          body: JSON.stringify({\n            requestId: requestId,\n            sessionId: sessionId\n          })\n        }, 10000); // 10秒超时\n\n        if (response.ok) {\n          result = await response.json();\n          success = true;\n          console.log(\"方法 1 成功\");\n        }\n      } catch (error) {\n        console.log(\"方法 1 失败:\", error.message);\n      }\n\n      // 方法 2: 使用 URLSearchParams 作为 POST 请求体\n      if (!success) {\n        try {\n          console.log(\"尝试方法 2: URLSearchParams POST\");\n          const params = new URLSearchParams();\n          params.append('requestId', requestId);\n          params.append('sessionId', sessionId);\n\n          const response = await fetchWithTimeout(`${API_URL}/status-background`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded',\n              'Cache-Control': 'no-cache'\n            },\n            body:\n              params\n          }, 10000); // 10秒超时\n\n          if (response.ok) {\n            result = await response.json();\n            success = true;\n            console.log(\"方法 2 成功\");\n          }\n        } catch (error) {\n          console.log(\"方法 2 失败:\", error.message);\n        }\n      }\n\n      // 如果所有尝试都失败\n      if (!success) {\n        throw new Error(\"所有请求方法都失败\");\n      }\n\n      // 处理成功的结果\n      if (result.status === 'completed' && result.answer) {\n        console.log(\"收到回答:\", result.answer.substring(0, 50) + \"...\");\n        return result;\n      } else if (result.status === 'failed') {\n        console.error(\"请求失败:\", result.error);\n        return {\n          status: \"error\",\n          error: result.error || \"处理请求时出错\"\n        };\n      } else {\n        // 继续轮询\n        console.log(`状态: ${result.status}，等待${POLL_INTERVAL}ms后重试`);\n        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));\n        // 修复：确保传递sessionId到轮询函数中\n        return pollForResult(requestId, sessionId, attempts + 1);\n      }\n    } catch (error) {\n      console.error(\"轮询错误:\", error);\n      // 增加重试次数\n      if (attempts < MAX_POLL_ATTEMPTS - 1) {\n        console.log(`轮询出错，${POLL_INTERVAL}ms后重试...`);\n        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));\n        // 修复：确保传递sessionId到轮询函数中\n        return pollForResult(requestId, sessionId, attempts + 1);\n      }\n      // 如果达到最大重试次数，返回超时状态\n      return {\n        status: \"timeout\",\n        requestId: requestId,\n        message: \"处理时间较长，请稍后检查结果。\"\n      };\n    }\n  }, []);\n\n  // 检查特定请求的答案 - 修复为使用sessionId\n  const checkAnswer = useCallback(async (requestId) => {\n    if (!requestId) return null;\n\n    try {\n      // 修复：传递sessionId而非0\n      const result = await pollForResult(requestId, sessionId, 0);\n      return result;\n    } catch (error) {\n      console.error(\"检查答案失败:\", error);\n      return {\n        status: \"error\",\n        error: `检查失败: ${error.message}`\n      };\n    }\n  }, [pollForResult, sessionId]); // 添加sessionId到依赖数组\n\n  return {\n    initiateRequest,\n    handleStreamingResponse,\n    pollForResult,\n    checkAnswer,\n    isProcessing,\n    setIsProcessing,\n    streamFailureCount\n  };\n}\n\nexport default useChatApi;"],"mappings":"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,CACxC,MAAO,CACLd,YAAY,CAAE,KAAK,CACnBc,SAAS,CAAEC,IAAI,CAACD,SAAS,CACzBxC,SAAS,CAAEyC,IAAI,CAACzC,SAAS,EAAIA,SAC/B,CAAC,CAEH,CAAE,MAAOlB,KAAK,CAAE,CACdK,SAAS,CAAGL,KAAK,CACjB8C,OAAO,EAAE,CACTvC,OAAO,CAACkE,IAAI,CAAC,OAAO3B,OAAO,OAAO9C,KAAK,CAAC0E,OAAO,EAAE,CAAC,CAElD,GAAI5B,OAAO,CAAG1C,UAAU,CAAE,CACxB,KAAM,CAAAI,KAAK,CAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAEoC,OAAO,CAAC,CAAG,IAAI,CACzCvC,OAAO,CAACmB,GAAG,CAAC,GAAGlB,KAAK,UAAU,CAAC,CAC/B,KAAM,IAAI,CAAAG,OAAO,CAACC,OAAO,EAAIlB,UAAU,CAACkB,OAAO,CAAEJ,KAAK,CAAC,CAAC,CAC1D,CACF,CACF,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,KAAM,CAAAH,SAAS,EAAI,GAAI,CAAAH,KAAK,CAAC,WAAW,CAAC,CAC3C,CAAC,OAAS,CACR;AACAoB,eAAe,CAACqD,MAAM,CAACxC,YAAY,CAAC,CACtC,CACF,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}