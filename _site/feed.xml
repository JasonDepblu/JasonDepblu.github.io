<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:8889/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:8889/" rel="alternate" type="text/html" /><updated>2025-04-11T23:08:42+08:00</updated><id>http://localhost:8889/feed.xml</id><title type="html">Jason‘s Blog</title><subtitle>Jason&apos;s personal blog which shares latest papers, his thoughts and experiences about life, work and technology.</subtitle><entry><title type="html">Reasoning model的复现之路</title><link href="http://localhost:8889/llm/papers/2025/02/19/Reasoning-model-reproduced.html" rel="alternate" type="text/html" title="Reasoning model的复现之路" /><published>2025-02-19T00:00:00+08:00</published><updated>2025-02-19T00:00:00+08:00</updated><id>http://localhost:8889/llm/papers/2025/02/19/Reasoning-model-reproduced</id><content type="html" xml:base="http://localhost:8889/llm/papers/2025/02/19/Reasoning-model-reproduced.html">## **论文信息**
**Paper:** 《Scaling of Search and Learning: A Roadmap to Reproduce o1 from Reinforcement Learning Perspective》

**Paper URL:** https://arxiv.org/html/2412.14135v1

**Author:** Zhiyuan Zeng1 Qinyuan Cheng1∗ Zhangyue Yin1∗ Bo Wang1∗
Shimin Li1 Yunhua Zhou2 Qipeng Guo2 Xuanjing Huang1 Xipeng Qiu1

Equal contribution. Listing order is random.

Corresponding author. Correspondence to: {cengzy23,yinzy21,bwang22}@m.fudan.edu.cn mailto:chengqy2019@foxmail.com {xjhuang, xpqiu}@fudan.edu.cn

**organization:** Fudan University, Shanghai AI Laboratory

## **1 引言 (Introduction)**

文章开篇介绍了人工智能领域的最新进展，尤其是大语言模型（LLMs）在复杂任务上的能力，如编程和高级数学问题求解。OpenAI 的 o1 模型展示了卓越的推理能力，包括任务分解、反思、纠错和探索新解决方案。本文提出了一个基于强化学习（Reinforcement Learning, RL）的路线图，目标是通过策略初始化、奖励设计、搜索和学习四个关键组成部分来复现 o1 的能力。

**文章中提到的四个关键组件（政策初始化、奖励设计、搜索和学习）的重要性：**

- 现有的开源项目在尝试复制o1时，都可以被视为这个路线图的一部分或变体

- 这些组件共同展示了学习和搜索如何推动o1的进步

- 这些工作对大语言模型(LLM)的发展做出了重要贡献

- 这段总结强调了搜索和学习这两个关键机制在推动大语言模型能力提升方面的核心作用。

&lt;details class=&quot;toggle-header&quot;&gt;
 &lt;p&gt;&lt;strong&gt;解释原文：However, scaling test-time search may lead to inverse scaling due to **distribution shift: the policy, reward, and value models are trained on one distribution but evaluated on a different one (Gao et al., [2023](https://arxiv.org/html/2412.14135v1#bib.bib49)).**&lt;/strong&gt;&lt;/p&gt;
    
 **问题：** 什么是distribution shift?

 **回答：** Distribution shift（分布偏移）在机器学习中是一个重要的概念，让我根据论文中的上下文来解释这个问题。
    
 在搜索和强化学习的场景下，distribution shift 主要体现在以下方面：

 1. 产生原因：
    - 当策略(policy)通过学习不断更新和改进时，它生成的数据分布也在不断变化
    - 而用于评估或指导的奖励模型(reward model)是在旧的数据分布上训练的
    - 这就导致了训练分布和实际使用时的分布不一致的问题
 2. 具体表现：
    
    ```
    训练时：reward model 在 policy A 产生的数据上训练
    使用时：policy 已经更新到 policy B，产生了新的数据分布
    结果：reward model 在新分布上的表现变差，因为它&quot;没见过&quot;这种分布的数据
    ```
    
 3. 实际影响：
    - 论文多次提到这个问题会导致&quot;inverse scaling&quot;（反向缩放）现象
    - 即增加搜索计算量反而会导致性能下降
    - 因为更多的搜索会产生更多分布外的数据
 4. 解决方案：
    - 减少测试时的搜索规模，避免产生过多分布外数据
    - 增强奖励模型的泛化能力，使其能处理分布外的数据
    - 通过增加模型规模和训练数据来提升鲁棒性

 这个问题在强化学习中尤其重要，因为策略的持续改进必然会带来数据分布的变化，如何处理这种分布偏移是构建稳定系统的关键挑战之一。
&lt;/details&gt;

## **2 背景 (Background)**

强化学习的特点在于通过与环境的交互进行学习，而非依赖静态数据集。

![Figure_1__The_overview_of_this_roadmap_including_policy_initialization_reward_design_search_and_learning.png](https://arxiv.org/html/2412.14135v1/x1.png)

在大语言模型（LLMs）的上下文中，策略对应于生成下一个令牌或响应的概率分布。环境则提供反馈信号，用以优化模型性能。

![reinforcement]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/reinforcement.png&quot; | relative_url }}){: img }

解释：实现类似o1系统的四个关键组成部分的工作流程：

1. **策略初始化（Policy Initialization）** 是起点，它定义了LLM如何基于上下文生成下一个token/步骤/响应。这个组件使LLM具备人类式推理行为，如任务分解、自我评估和自我纠正能力

3. **奖励设计（Reward Design）** 为搜索和学习提供指导信号。它可以直接使用或重塑环境中的奖励信号，也可以从偏好数据中学习奖励模型

4. **搜索（Search）** 在训练和测试阶段都发挥重要作用，通过增加计算量可以产生更好的解决方案

5. **学习（Learning）** 利用搜索生成的数据来改进策略。这些数据来自LLM与环境的交互，而不是人工标注，这样可以避免昂贵的数据标注成本，并有可能实现超人类表现

值得注意的是，策略初始化和奖励设计是为搜索和学习做准备的基础工作

  ![relatived_papers]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/image.png&quot; | relative_url }}){: img }

#### 问题1：在Figure 3中，step t+1 指的是生成next token这一步吗？

 - **Agent原文：** *In the context of LLMs, an agent refers to LLM itself, its policy specify the probability distribution 
of either token-, step-, or solution-level actions based on the current state. The state $$s_t$$ consists of the input 
provided to the model at time $$t$$, including both user inputs and the model’s earlier outputs. The action taken by the 
model can vary depending on the problem setting; it involves generating a single token, completing a step, or providing 
a solution.*

 - **回答：** 
   - 根据论文的描述,在LLM(大语言模型)的上下文中,action可以有三种粒度:
     1. Token级别: 每一步生成一个token
     2. Step级别: 每一步生成推理的一个步骤/部分
     3. Solution级别: 每一步生成一个完整的解决方案
 
   - 作者在Section 2指出, step $$t+1$$ 的state $$s_{t+1}$$ 是由当前的state $$s_t$$ 和action $$a_t$$ 决定的:
    
     1. 对于随机环境(如对话系统), $$s_{t+1}$$ 的生成涉及一个转移分布 $$p(s_{t+1}, r_{t+1} \mid s_t, a_t)$$
     2. 对于确定性环境(如数学问题求解), $$s_{t+1}$$ 是由 $$s_t$$ 和 $$a_t$$ 确定性地组合得到

   - 所以step $$t+1$$ 并不特指生成next token这一操作,而是根据选择的action粒度可以代表:

     1. 生成下一个token后的状态
     2. 生成下一个推理步骤后的状态
     3. 生成完整解决方案后的状态

   - 这种灵活的设计允许在不同任务和优化目标下选择合适的action粒度。
    
#### 问题2：“ Environmental feedback can be categorized as either deterministic or stochastic. Stochastic feedback is characterized by a transition distribution (s_{t+1},r_{t+1} | s_t,a_t) , as seen in systems like dialogue models, where user responses are inherently unpredictable.” 论文中，这段描述，为什么说用户的反馈是 “不可预测的” ，但是又说有一个转移分布p，这不是相互矛盾吗？
    

 - **Environment原文：** *Environmental feedback can be categorized as either deterministic or stochastic. Stochastic feedback is characterized by a transition distribution $$p(s_{t+1},r_{t+1} \mid s_t,a_t)$$ , as seen in systems like dialogue models, where user responses are inherently unpredictable.*

 - **回答：** 这里并不矛盾，让我解释一下：

   1. 转移分布 $$p(s_{t+1},r_{t+1} \mid s_t,a_t)$$ 表示的是一个概率分布，而不是一个确定性的映射：
     - 它描述了在给定当前状态 $$s_t$$ 和行动 $$a_t$$ 的情况下，下一个状态 $$s_{t+1}$$ 和奖励 $$r_{t+1}$$ 出现的概率
     - 这是一个条件概率分布，表示可能的输出及其对应的概率
   2. &quot;用户反馈不可预测&quot;指的是：
     - 我们无法确定性地知道用户具体会给出什么反馈
     - 但是我们可以知道不同反馈出现的概率分布
    
     举个例子：
     - 假设LLM在对话中说了一个笑话
     - 用户的反应是&quot;不可预测的&quot;，因为我们无法100%确定用户会如何回应
     - 但是我们可以说：
         - 70%的概率用户会觉得好笑
         - 20%的概率用户会觉得一般
         - 10%的概率用户会觉得不好笑

   所以，&quot;有概率分布&quot;和&quot;不可预测&quot;并不矛盾：

     - &quot;不可预测&quot;指的是无法确定性预测具体结果
     - 转移分布p描述的是这种不确定性的统计规律 
     - 这就像抛硬币一样：虽然我们无法预测下一次具体是正面还是反面，但我们知道正反面各50%的概率分布。
    


## **3 策略初始化 (Policy Initialization)**

**主要内容：通过预训练和指令微调（Instruction Fine-Tuning），使模型具备基础语言理解能力和任务指向性行为。**

**LLM基于环境反馈的3种动作**：

  - Solution级别：解决方案级别的动作代表最粗粒度，将整个解决方案视为单一动作。

  - Step级别：步骤级别的动作在中等粒度上运作，将各个步骤作为离散动作。

  - Token级别：词元级别的动作提供最细粒度，将每个独立词元视为一个动作。

  以token级别动作为例，动作空间包含词表中的数千个词元，建立一个良好的初始策略对于模型的有效性表现至关重要。
    
**大语言模型的策略初始化阶段包含三个基本组成部分：预训练、指令微调和类人推理行为的开发。**
  - **在预训练阶段，模型通过对大规模网络语料库进行自监督学习来发展基本的语言理解能力，遵循计算资源和性能之间既定的Power-Law。**

    #### 预训练使模型能通过处理多样化的语料库，在事实性、程序性和概念性领域获取全面的知识。

      - 模型从百科全书和学术文献中发展出丰富的语义网络，具备跨领域推理和提供新见解的能力。
    
      - 通过接触专业技术内容，模型在特定领域表现出专业知识，如数学证明和科学分析。
    
      - 接触教学内容和编程语言，模型获得了程序性知识，提升了系统性解决问题的能力。
    
      - 通过正式的数学文本，模型建立了数学和逻辑基础，具备逻辑推理能力。
    
      - 近期研究表明，模型的知识存储具有高效的压缩和泛化特性，其中抽象概念的学习相比事实性知识需要更广泛的训练。
            
    #### 原文解释-“Recent studies demonstrate that knowledge storage exhibits efficient compression and generalization properties (An et al., [2024]), with abstract concepts requiring more extensive training compared to factual knowledge (Allen-Zhu &amp; Li, [2024])”.

      - **回答：** 关于“近期研究表明，知识存储表现出高效的压缩和泛化特性（An et al., 2024），抽象概念相比事实性知识需要更广泛的训练（Allen-Zhu &amp; Li, 2024）”的解释如下：

        1. **知识存储的高效压缩和泛化特性**：根据 Allen-Zhu 和 Li（2024）的研究，语言模型能够以高效的方式存储知识。他们发现，语言模型每个参数可以存储约 2 比特的知识，即使在量化为 int8 的情况下，这些知识也能被灵活地用于下游应用。这意味着模型在存储大量知识时，能够进行有效的压缩，并在不同任务中实现良好的泛化能力。
        2. **抽象概念需要更广泛的训练**：Allen-Zhu 和 Li（2024）在他们的研究中指出，模型在学习抽象概念时，需要比学习事实性知识更广泛的训练。这是因为抽象概念通常更复杂，涉及更深层次的理解和推理能力，因此模型需要更多的训练数据和时间来掌握这些概念。
        总之，模型在预训练过程中，通过高效的知识压缩，能够存储大量信息，并在不同任务中表现出良好的泛化能力。然而，对于抽象概念的学习，模型需要更多的训练来达到理想的理解和应用水平。
        
    #### 预训练通过处理多样化的语料库，使大型语言模型（LLMs）逐步建立起基础的推理能力。

      - 这些推理能力从简单的推断逐步发展到复杂的推理，主要通过以下机制实现：

        1. **模式匹配和类比推理**：LLMs在预训练过程中，通过大量的文本数据学习模式匹配和类比推理的能力，使其能够在不同领域进行泛化。
        2. **逻辑推理能力**：通过接触大量的代码和数学证明，LLMs发展出逻辑推理的能力。例如，研究表明，预训练中引入编程语言数据可以显著提升模型的逻辑推理性能。
        3. **顺序处理能力**：通过学习程序性文本和数学推导，LLMs具备了处理顺序信息的能力，这对于解决复杂问题和保持逻辑一致性至关重要。
       总之，预训练通过多样化的语料输入，使LLMs逐步建立起从简单到复杂的推理能力，涵盖模式匹配、类比推理、逻辑推理和顺序处理等方面。
            
    #### 问题：有证据证明，LLM的推理能力与预训练过程相关吗？
            
      - **回答：** 有大量证据表明，LLM（大型语言模型）的推理能力与其预训练过程密切相关。这些证据主要集中在以下几个方面：
            
        1. **多样化语料和知识基础**
          - **事实**：预训练模型通常在大规模、多样化的语料库（如百科全书、代码库、科学文献等）上进行训练。这些语料覆盖了广泛的领域，为模型构建推理能力提供了基础。
          - **研究**：Radford 等（2019）和 Brown 等（2020）表明，GPT 系列模型的预训练阶段建立了广泛的语言和知识理解能力，为复杂任务提供支持。例如，GPT-3 的零样本和少样本任务能力依赖于其预训练阶段学到的广泛知识。
        2. **模式匹配和类比推理**
          - **机制**：模式匹配和类比推理是 LLM 的核心推理能力。预训练通过大量的文本暴露，使模型可以捕获上下文模式并生成类比。
          - **研究**：Webb 等（2022）和 Yasunaga 等（2024）指出，这种能力在预训练中自然出现，表明预训练数据的多样性直接影响推理能力的强弱。
        3. **逻辑推理与数学能力**
          - **事实**：逻辑推理能力和数学能力的发展与模型接触的预训练语料类型密切相关。
          - **研究**：Hui 等（2024）和 Yang 等（2024）的研究表明，包含代码和数学证明的语料有助于增强模型的逻辑推理和数学问题解决能力。例如，Codex 模型在预训练中大量接触代码库，从而在代码生成和调试任务中表现优异。
        4. **顺序处理能力**
          - **机制**：预训练在长文本和程序性内容上暴露，使模型能够理解和生成具有复杂逻辑顺序的文本。
          - **研究**：Lewkowycz 等（2022）发现，通过在数学推导和程序性内容上训练，模型表现出较强的逻辑一致性和顺序推理能力。
        5. **模型能力的渐进增强**
          - **事实**：LLMs 的推理能力表现出从简单推断到复杂推理的逐步增强。这种现象与预训练时间、数据量和模型规模成正相关。
          - **研究**：Kaplan 等（2020）研究了模型规模、预训练数据量和性能之间的关系，发现更大的模型和更长的预训练时间显著提高了推理能力。
        6. **抽象概念的学习**
          - **挑战**：抽象概念的学习需要更广泛和更复杂的预训练数据。
          - **研究**：Allen-Zhu 和 Li（2024）证明，抽象概念的学习在模型的预训练中尤为依赖数据的多样性和质量，抽象能力的提升直接反映在复杂推理任务上的表现。
            
        **结论：** LLM 的推理能力与其预训练过程密切相关。预训练提供了广泛的知识基础和推理框架，使得模型能够泛化到多样化的任务中。通过增加预训练数据的规模、类型和多样性，可以显著提升模型的推理能力。
            
  - **指令微调将大语言模型从简单下一个词预测转变为生成符合人类期望的回应。**

    这个过程使得模型从存粹预测下个token转变为目的性行为模型

    #### IFT受两个关键因素影响

      - instruction dataset的多样性

      - instruction-response pairs的质量

    这些工作共同推动了指令微调技术的发展，从不同角度探索了如何提升模型的指令理解和执行能力

      | 作者                  | 题目 | 主要内容 |
      |---------------------| --- | --- |
      | Wang et al. (2022b) | Super-natural instructions: Generalization via declarative instructions on 1600+ NLP tasks | 开发了一个包含1600多个不同NLP任务的综合数据集，通过声明式指令来促进模型泛化能力 |
      | Wei et al. (2022a)  | Finetuned language models are zero-shot learners | 证明了在高质量指令数据上微调的模型能有效泛化到新任务，奠定了指令微调的基础理论 |
      | Chung et al. (2024) | Scaling instruction-finetuning of language models | 通过扩展任务数量、模型规模和引入步骤推理协议来增强指令学习能力，系统研究了指令微调的缩放规律 |
      | Taori et al. (2023) | Stanford alpaca: An instruction-following llama model | 展示了小规模模型通过精心策划的高质量训练数据也能实现出色的指令跟随能力，提供了一种经济高效的方法 |
      | Wang et al. (2023b) | Self-instruct: Aligning language models with self-generated instructions | 提出了使用LLMs自动生成指令-响应对的方法，降低了获取指令数据的成本 |
      | Hayati et al. (2024) | Chain-of-instructions: Compositional instruction tuning on large language models | 研究表明在复杂的多步骤指令上进行微调能显著提升模型能力和泛化性，强调了指令复杂度的重要性 |


  - **对于o1这样的模型来说，融入类人推理行为对于实现更复杂的解决方案空间探索至关重要。** 
  
    文章总结了六种关键行为，这些行为可以通过提示激活或通过从大语言模型中提取专家轨迹来学习。
        
    ![image.png](https://arxiv.org/html/2412.14135v1/x3.png)
        
    #### Problem Analysis
      - **Problem analysis** serves as a crucial initialization process where the model reformulates and analyzes the problem before solving it.

        1. 核心概念：
          - 问题分析是一个重要的初始化过程
          - 模型在解决问题前需要重新表述和分析问题
        2. 具体步骤包括：
          - 明确重述问题以验证理解
          - 识别隐含约束条件
          - 将抽象需求转化为具体、可执行的规范
        3. 关键研究进展：
          - Kondrakunta et al. (2018)首次提出这一概念
          - Deng et al. (2023)提出&quot;主动思维链&quot;(Proactive Chain-of-Thought)
          - 模型在解题前主动分析潜在的歧义
        4. 实际应用示例：
          - 密码解析：仔细观察密文模式并重新构建问题
          - 编码任务：将输入重构为矩阵格式，精确生成预期输出
        5. 价值和意义：
          - 减少问题理解中的歧义
          - 为后续解题阶段构建更有利的初始状态
        这个过程强调了在实际解题之前，充分理解和分析问题的重要性。
                
    #### Task Decomposition
            
      - **任务分解(Task Decomposition)：**
            
        1. 基本概念：
          - 模仿人类处理复杂问题的方式，将其分解为多个可管理的子任务
          - 这是一种自然的问题解决策略
        2. 具体应用案例：
        - 在编码任务中，o1将问题分解为多个子任务：
          - 捕获输入字符串
          - 删除空格
          - 解析输入字符串
        3. 关键技术进展：
          - Bursztyn et al. (2022)提出组合式微调(CFT),明确将目标任务分解为组成部分
          - Khot et al. (2023)和Dua et al. (2022)展示了结构化提示的重要性,通过精心设计的提示来引导模型进行任务分解
        4. 分解过程的特点：
          - 自适应性：根据问题复杂度动态调整
          - 上下文感知：考虑具体情境
          - 灵活性：可以调整子任务的粒度和结构
          - 动态性：基于问题的复杂度和不确定性水平进行调整
        5. 这种方法的优势在于它能将复杂问题转化为更易处理的小问题，从而提高解决问题的效率和成功率。
            
    #### Task Completion
            
      - **Task Completion的过程和特点：**
            
        1. 基本流程：
          - 在问题分析和任务分解之后进行
          - 基于已明确的问题和分解好的子任务
          - 采用step-by-step推理方式生成解决方案
        2. 推理过程特点：
          - 成功的解决方案会引导下一个子任务的处理
          - 有问题的解决方案会触发：
            1) 生成替代方案
            2) 自我纠正行为
      
        3. 激活方式：
          - 通过包含推理过程的提示词
          - 通过简单指令（如&quot;Let&apos;s think step by step&quot;）
          - 小型模型可通过蒸馏大量step-by-step推理数据获得此能力
        4. 优化策略：
          - 采样多个解决方案来提高正确答案概率
          - 使用边际概率选择最终答案来提高整体准确性
        5. 价值意义：
          - 显著增强模型的复杂推理能力
          - 提供了一个系统化的问题解决框架
          - 支持灵活的纠错和优化机制
            
        6. 这一过程展示了LLM如何系统地执行问题解决，并通过多种机制来优化解决方案的质量。
            
    #### Alternative Proposal
            
      - 在推理过程中，模型**生成多样化备选方案的能力**，尤其是在遇到推理障碍或死胡同时：
            
        1. 生成备选方案的必要性：
          - 当模型在推理过程中遇到困难时，生成多样化的备选方案至关重要。
          - 例如，在密码破解任务中，模型通过系统地提出多种可能的解码方案来解决问题。
        
        2. Divergent CoT方法：
          - Puerto 等（2024）提出了 Divergent Chain-of-Thought（CoT）方法，通过微调模型，使其在一次推理中生成多个解决方案，从而显著提升了模型在复杂推理任务上的表现。
        
        3. 提示策略激活备选方案生成：
          - 生成备选方案的能力可以通过特定的提示策略来激活。
          - 例如，Progressive-Hint Prompting 方法利用历史解答尝试来指导当前的推理过程。
          - 此外，Exchange-of-Thought 方法通过引入其他模型的见解，丰富了解决方案的多样性。
        
        4. 系统性探索的优势：
          - 通过系统性地探索多种备选方案，模型不仅扩大了搜索空间，还能通过对比不同的解决方案进行迭代优化，从而生成更合理的输出。
            
        6. 总之，生成多样化的备选方案对于提升模型的推理能力和解决复杂问题的效果至关重要。
            
    #### Self-Evaluation
            
      - **自我评估**在验证AI生成解决方案正确性中具有关键作用，尤其在密码分析等任务中，模型通过逐字母对比明文与密文（如“o1案例”）并生成显式反馈（如“Let’s check”）来确保准确性。为强化这一能力，研究者提出以下两类方法：
            
        1. **结构化评估标准**：通过制定细粒度规则（如Bai等, 2022b; Yin等, 2024b），系统性培养模型的自我检测能力；
        2. **自我辩论机制**：借助内部多路径推理的交叉验证（如Du等, 2024; Sun等, 2024c），提升结论可靠性。
            
        进一步技术突破包括：
            
        1. **自我知识调优**（Zhang等, 2024f）：通过训练模型深度反思自身推理逻辑，增强评估可信度；
        2. **知识蒸馏**（Liu等, 2024d）：将大模型的自我评估能力迁移至小模型，显著提升其推理性能。
            
        这些方法通过构建严谨的自我验证机制，旨在提高AI问题解决的鲁棒性与准确性，为复杂任务（如密码破译）提供更可靠的决策支持。
            
    #### Self-Correction
            
      - **自我纠正**能力的实现和特点可以总结为以下几点:
            
        1. 基本定义和触发:
          - 自我纠正是模型在推理过程中遇到可处理错误时的修正行为。
          - 遇到&quot;No&quot;或&quot;Wait&quot;等信号会触发纠正过程。
        2. 关键研究发现:
          - Huang等人指出在没有外部反馈时自我纠正存在挑战。
          - Liu等人发现无偏提示和零温度设置可以激活内在的纠正能力。
          - Zhang等人通过步骤级分析提高了自我纠正性能。
        3. o1系统特点:
          - 在科学领域示例中展示了识别公式生成错误并进行纠正的能力。
          - 这仅是其综合推理框架的一部分。
          - 具有复杂的自适应行为,能根据任务需求动态调整解决策略。
        4. 更广泛意义:
          - 通过系统分析这些行为,可以了解o1如何处理复杂文本领域。
          - 揭示了o1如何在不同环境下调整其推理行为。
            
        这些研究为我们理解大语言模型的自我纠正能力提供了重要见解,也展示了这一能力在实际应用中的复杂性和灵活性。


  - **有效利用类人推理行为需要大语言模型具备一定的基础能力**

    #### 长文本生成能力
            
      - **大语言模型（LLMs）的长文本生成能力**指在复杂推理任务中，模型需输出大量token以承载多样化推理行为，这对长上下文建模能力提出更高要求。
      尽管现有LLMs在长文本理解（如文档分析）方面已有显著进步，但其长文本生成（如连续创作万字文章）仍面临挑战：
            
        1. **信息连贯性衰减**：生成内容易出现前后逻辑断裂；
        2. **主题漂移风险**：长文本中难以维持核心焦点；
        3. **计算资源限制**：生成长序列时内存消耗剧增。
            
      - 为突破瓶颈，研究者提出两类方法：
            
        1. **AgentWrite**（Bai等, 2024）：通过基于智能体的自动化数据构建管道（如LongWriter-6k数据集），生成高质量长文本训练数据，针对性微调模型；
        2. **Self-Lengthen**（Quan等, 2024）：设计“扩展器”模块迭代生成更长文本数据，通过渐进式微调，使LLMs逐步适应生成长内容的任务。
            
      - **关键技术创新**：两种方法均采用**数据驱动的自增强策略**
        1. 前者通过模拟人类写作流程构建结构化数据，后者通过模型自我生成数据实现能力迭代升级。
        2. 本质上，它们通过“用长文本数据训练长文本生成”的范式，突破传统LLMs受限于短文本语料的生成能力边界。
            
    #### 类人逻辑推理行为
            
      - 这里探讨了如何使AI模型具备**类人逻辑推理行为**的能力，强调模型需在复杂决策中协调逻辑一致的行为链条。
      例如，当自我评估检测到错误时，模型需智能判断应进行自我修正还是另寻新解。这种类人推理模式虽能提升问题解决的全面性，但也带来以下挑战：
            
        1. **计算复杂性增加**：多路径探索需要更高算力支持；
        2. **逻辑一致性要求**：需确保不同推理步骤间的连贯衔接；
        3. **动态决策难题**：何时切换不同推理策略缺乏明确标准。
            
      - 现有研究（Sun等, 2024b; Aryabumi等, 2024）表明，通过编程代码训练和结构化逻辑数据学习，可有效增强模型的逻辑推理基础能力。但当前仍存在两个关键未解问题：
            
        1. **系统化组织**：如何将零散的推理行为（如假设生成、验证、修正）整合为有机流程；
        2. **时序优化**：如何确定最佳触发节点（如错误出现时立即修正vs.积累多个错误后批量处理），以动态部署最合适的推理策略。
            
      - 这本质上是在追问：如何构建类似人脑的**逻辑决策框架**，使AI不仅能模仿人类推理的“动作”，更能掌握其背后的**策略调度智慧**。
        - 例如，医生诊断时会根据检查结果动态调整检测顺序，这种灵活的决策机制目前仍是AI难以复现的。
            
    #### Self-Reflection 自反馈
            
      - 文章将**自反思维（Self-Reflection）定义为模型通过自评估、自我纠正、提出替代方案**等行为展现的元认知能力，其核心价值在于突破传统自回归模型（如GPT系列）的固有缺陷：
            
        1. **不可逆生成限制**：传统模型无法回溯修改已生成的错误内容（Madaan等, 2023）；
        2. **自我知识显性化**：通过自反思维，模型能主动识别自身输出的逻辑漏洞或事实错误（Cheng等, 2024b; Yin等, 2023b）。
            
      - **关键研究发现**：
            
        1. **习得困难性**：自反思维并非通过简单指令微调即可获得，需特定训练机制；
        2. **参数效率瓶颈**：仅采用参数高效微调（如LoRA、Adapter）难以有效激发该能力（Ye等, 2024），暗示其依赖模型底层架构的深度调整。
            
      - **深层意义**：自反思维标志着AI从“单向内容生成”向“动态认知迭代”的跨越，其实现需模型具备：
            
        1. 对生成过程的**实时监控**能力；
        2. 基于知识库的**错误诊断**机制；
        3. 多解决方案的**策略性选择**逻辑。
        当前研究揭示了自反思维与模型规模、训练数据的认知密度之间的强相关性，为开发更自主的AI系统指明方向。
            
    #### 问题1：这篇引用的文章中，是否有解释或说明self-reflection能力不容易通过PEFT获得？
            
      - **回复：**根据引用的论文内容（特别是第5节“Result 7: Finetune with Retry Data”），文章明确解释了**为何自反思维（Self-Reflection）能力难以通过参数高效微调（PEFT）获得**。以下是核心结论及其解释： 

      - **1. 核心发现**
            
        - 论文通过实验验证了以下关键结论（Section 5, Result 7）：
            
            - **PEFT的局限性**：即使使用大量包含错误与修正的“retry data”对预训练好的模型（仅基于无错误数据）进行LoRA微调，模型的推理准确率**几乎没有显著提升**，甚至可能低于原模型（见图7）。
            - **全参数微调的对比**：只有通过**全参数微调（即继续预训练）**才能有效提升错误修正能力，但这种方式成本高昂，本质上等同于重新预训练。
            
          这表明：错误修正能力（自反思维的核心）与无错误推理能力是两种本质不同的技能，无法通过PEFT的局部参数调整习得。
            
      - **2. 具体原因分析**
            
        - 论文从以下角度解释了这一现象：
            
          - **(1) 参数调整的深度不足**
            
            - **PEFT的轻量化设计**：LoRA等方法仅通过低秩矩阵更新少量参数（如仅调整模型总参数的0.1%），而错误修正需要模型**全局计算逻辑的重构**（例如动态调整注意力机制以回溯错误步骤）。
            - **错误修正的复杂性**：修正错误需要模型在生成过程中实时监控推理路径、识别逻辑漏洞并重新规划后续步骤，这依赖**跨层、跨模块的协同参数调整**，而PEFT的局部更新无法覆盖此类复杂需求。
            
          - **(2) 预训练阶段的全局学习需求**
            
            - **错误修正能力的根源在预训练**：论文发现，只有当模型在预训练阶段直接接触包含错误与修正的“retry data”时，才能习得动态修正能力（Section 4）。这种能力本质上是模型在预训练中**内化了一种“生成-检测-修正”的全局模式**，而PEFT的轻量化微调无法重新建立这种模式。
            - **PEFT无法覆盖底层架构**：错误修正需要调整模型底层架构（如注意力权重、残差连接），而PEFT仅通过附加模块或低秩矩阵注入新参数，无法修改预训练模型的核心结构（Section 5）。
            
          - **(3) 数据与训练的耦合性**
            
            - **错误修正的语义密度要求**：自反思维需要模型学习**错误与修正的强关联关系**（如“生成错误步骤 → 触发[BACK]符号 → 立即修正”），这种模式需通过预训练阶段的大规模数据暴露（如高比例的retry data）才能内化。PEFT的轻量化训练（少量下游数据）无法提供足够的语义多样性以覆盖此类复杂逻辑。
            
      - **3. 实验支持**

        - 论文通过以下实验验证上述结论（Section 5, Figure 7）：
            
            - **LoRA微调效果微弱**：即使使用高rank的LoRA（接近全参数微调）和大量retry data，模型的准确率提升仍远低于直接预训练retry data的模型。
            - **全参数微调的成本与效果**：全参数微调（继续预训练）虽然有效，但需要消耗与预训练相当的资源（相当于重新训练模型），而PEFT无法达到类似效果。
    
      - **总结**
            
        - 论文明确指出，**自反思维能力的核心是错误修正，而这种能力需通过预训练阶段全局参数的深度调整（而非微调）才能习得**。PEFT的局部参数更新和轻量化设计无法满足这一需求，揭示了当前轻量化微调技术在复杂推理任务中的局限性。这一结论为未来大模型训练提供了重要启示：**自反思维等高级能力需在预训练阶段通过结构化数据（如retry data）直接注入，而非依赖后验微调**。
            
    #### 问题2：根据deepseek-r1的论文，采用的是post-training的方式提升了逻辑推理的能力，是否与文章中提到的不能通过PEFT提升该能力的描述有冲突？
            
      - **回复：**根据DeepSeek-R1的论文内容，其核心结论与前述关于PEFT局限性的分析**并不矛盾**，反而进一步验证了**复杂推理能力需依赖全局训练而非轻量化微调**的观点。以下是详细分析：

        - **1. DeepSeek-R1的高性能确实通过后训练（Post-Training）实现**
            
          - 论文明确指出，DeepSeek-R1的推理能力提升主要源于**强化学习（RL）阶段**，而非传统监督微调（SFT）：
            
            - **DeepSeek-R1-Zero**：直接通过大规模RL训练基础模型（无SFT冷启动），在数学、代码等任务中显著提升性能（如AIME 2024的Pass@1从15.6%提升至71.0%）。
            - **DeepSeek-R1**：在RL基础上引入冷启动数据（少量高质量长链式推理样本）和多阶段训练（RL + SFT + 二次RL），进一步优化推理能力与可读性，最终达到与OpenAI-o1-1217相当的性能。
            
          - 论文强调，**RL训练是后训练的核心**，通过全局参数调整（而非局部微调）使模型内化“生成-验证-修正”的动态推理逻辑。

        - **2. 与PEFT局限性的关系**
            
          - 此前结论指出，自反思维（如错误修正）需**全局参数调整**，而PEFT（如LoRA）的局部更新无法满足需求。DeepSeek-R1的实践进一步验证了这一点：
            
            - **RL的全局性**：RL训练通过策略梯度更新模型整体参数（而非仅附加模块），覆盖注意力机制、残差连接等底层结构，支持复杂推理行为的动态调整。
            - **对比实验**：论文Section 5（Result 7）显示，若仅对预训练好的无错误模型进行LoRA微调（即使使用大量修正数据），其性能提升有限，甚至低于直接预训练修正数据的模型。而**全参数微调（继续预训练）**虽有效，但成本高昂，等同于重新训练。
            
          - 这表明，**强化学习作为一种全局后训练方法，与PEFT的轻量化设计存在本质区别**，其成功依赖于对模型参数的深度调整。

        - **3. 蒸馏（Distillation）的补充验证**
            
          - 论文进一步通过蒸馏实验验证了复杂能力的迁移需依赖全局训练：
            
            - **蒸馏效果**：通过将DeepSeek-R1的推理数据（来自RL训练结果）直接迁移至小模型（如Qwen-7B），其性能显著优于对小模型单独应用RL（见表6）。这表明**推理能力的核心源于大模型的全局训练**，而非小模型的局部优化。
            - **局限性**：即使对小模型应用RL，其性能仍无法超越蒸馏模型，进一步证明**复杂推理能力需通过全局训练内化**，而非单纯参数高效调整。

        - **总结**
            
          - DeepSeek-R1的高性能确实通过后训练（尤其是强化学习）实现，但这与“自反思维难以通过PEFT获得”的结论**一致**，因为：
            
            1. RL属于**全局训练方法**，涉及全参数更新，与PEFT的局部调整本质不同；
            2. 论文实验验证了**轻量化微调（如LoRA）在复杂推理任务中的局限性**，进一步支持此前结论；
            3. 蒸馏的成功依赖于大模型通过RL习得的全局推理模式，而非小模型的局部优化。
            
          - 因此，DeepSeek-R1的实践不仅未违背此前结论，反而为“复杂推理需全局训练”提供了实证支持，同时为未来模型训练指明方向：**高级能力需通过预训练/RL直接注入，而非依赖后验轻量化微调**。
            
  - **策略初始化在复现类似o1模型时面临两大核心挑战** 

    #### 采样效率与多样性的平衡
            
      - 策略初始化需在优化动作分布（提升采样效率）与维持探索多样性之间取得平衡。过度依赖人类示范数据可能导致策略固化，限制后续搜索阶段发现更优策略的潜力，如AlphaGo从人类数据初始化虽提供强起点，却可能阻碍自主探索。
            
      - 推理行为的领域泛化能力:现有研究多聚焦于数学、编程等特定领域的推理行为复现，但o1模型的通用性要求其适应安全验证等跨领域任务。需设计无需任务定制、具备强泛化能力的推理模式。例如，DeepSeek-R1通过强化学习自然涌现复杂推理行为（如反思、多语言混合），但其可读性与语言一致性问题凸显了领域泛化的实际挑战。未来需在高效训练框架下，强化模型对多样化任务的通用推理能力。

## **4 奖励设计 (Reward Design)**

### 结果奖励 vs. 过程奖励

**结果奖励（Outcome Reward）**

**定义**：基于大模型（LLM）输出是否符合预设目标（如答案正确性）进行评分，例如数学问题中最终答案是否正确（Cobbe et al., 2021）。

#### 优缺点比较
- **优点**：
  1. **简单易用**：任务目标明确时（如数学解题），奖励信号可直接通过规则或标准答案判定。
  2. **广泛适用**：适用于答案明确的闭集任务（如编程、数学）。

- **缺点**：
  1. **中间步骤无监督**：可能生成错误中间过程但结果正确（Lightman et al., 2024），影响模型学习稳定性。
  2. **稀疏性**：仅在最终结果提供反馈，难以指导分步策略优化。
- **应用场景**：数学解题、代码正确性验证等答案明确的任务（Shao et al., 2024）。

**过程奖励（Process Reward）**

**定义**：对LLM生成的中间步骤和最终结果同时提供奖励信号，例如人工标注数学解题每一步的正确性（Lightman et al., 2024）。

#### 分类
- **词级（Token-level）**：逐词评估生成质量（Rafailov et al., 2024）。
- **步骤级（Step-level）**：以逻辑步骤为单位（如换行符分割或信息熵分割）（Kuhn et al., 2023）。

#### 优缺点比较
- **优点**：
  1. **细粒度反馈**：优化中间步骤质量，提升推理可靠性。
  2. **泛化性**：可适配复杂任务（如多步逻辑推理）。
- **缺点**：
  1. **依赖人工标注**：成本高、难以扩展（Lightman et al., 2024）。
  2. **设计复杂度高**：需定义合理的步骤分割与奖励分配机制。
- **应用场景**：需要可解释性或多步协作的任务（如安全验证、科学推理）。

**核心对比**

1. **监督范围**：结果奖励仅关注最终输出，过程奖励覆盖全流程。
2. **信号密度**：结果奖励稀疏，过程奖励密集但实现成本更高。
3. **泛化能力**：过程奖励更适用于开放域任务，而结果奖励限于闭集任务。
4. **关系**：结果奖励可视为过程奖励的特例（中间步骤奖励均为零）。

**未来方向**：通过奖励塑形（Reward Shaping）自动生成过程奖励，平衡效率与成本（见第4.2.3节）。

### 奖励设计方法

**奖励设计（Reward Design）**

分为基于真实环境的奖励、基于环境模拟的奖励以及AI Judgment（AI评价）三种方法。无论是面向成果导向（Outcome Reward）还是过程导向（Process Reward），这些思路都可相互借鉴，常见的模型统称为Outcome Reward Model (ORM)或Process Reward Model (PRM)。

**环境奖励（Reward from Environment）**

- **直接利用环境提供的奖励信号**
    - 当外部环境能直接提供有效的反馈或评估机制时（例如编译器检查代码正确性、网页操作是否成功完成等），就可以直接使用这些真实环境反馈来设计奖励。
    - 具体案例：
        - 代码生成任务中，编译器或解释器的反馈有助于评估代码质量。
        - 在类似网页购物、MineDojo等沙盒或模拟环境中，模型可通过交互过程获得实时奖励。
- **通过模拟环境来获取奖励信号**
    - 当真实环境的交互成本过高或测试时无法访问环境时，需要基于已有数据训练一个“奖励模型”来模拟环境反馈。
    - 这种方法的好处是：模型在任何时间都可获得反馈，不受外部环境的限制。
    - 主要风险是：**分布漂移（distribution shift）**——随着策略模型的不断更新，最初训练的奖励模型可能对新策略不再准确，需要同步更新。
- **AI Judgment（由其他强大AI来进行评估）**
    - 通过调用诸如GPT-4等强大的大模型，对生成的回答或过程进行打分/评价。
    - 这种方法本质上也是一种“奖励模型”，但由于评估方与被评估的策略模型是相对独立的，通常不会出现“奖励优化”导致的分布漂移问题。
    - 从更宏观的角度看，使用强大大模型进行评估可视作一种“世界模型”，为被评估的模型提供更全面、稳定的反馈信号。

总体而言，这几种方法互有侧重：**真实环境奖励**最为真实但可能成本高；**模拟环境奖励**灵活但易出现分布漂移；**AI Judgment**使用强大模型进行评估，既能避免高环境成本，也能减少分布漂移带来的问题。

**从数据中建模奖励信号（Reward Modeling from Data）**
    
当环境无法直接提供奖励信号时（例如AI助手的回答质量难以评估），可通过收集**专家数据**或**偏好数据**来学习有效的奖励模型。主要方法如下：

- **基于偏好数据的学习**
    - **原理**：通过收集人类对多个模型回答的偏好排序（如选择更好的回答），利用统计模型（如Bradley-Terry模型）推导奖励函数。
    - **应用**：RLHF（基于人类反馈的强化学习）通过偏好对齐模型行为，成功应用于ChatGPT等模型。
    - **挑战**：偏好数据需准确反映任务目标，否则可能损害模型性能（如偏好与真实任务目标不一致）。
- **基于专家数据的逆强化学习（IRL）**
    - **原理**：从专家生成的轨迹数据（如高质量回答）中反向推断专家优化的潜在奖励函数。
    - **方法**：经典IRL通过对抗训练拟合奖励函数，近年研究提出非对抗方法（如凸对偶函数）以简化流程。
    - **现状**：数据易获取，但训练复杂度高，目前尚未在大规模语言模型强化学习中广泛应用。
- 核心对比
    - **偏好数据**：依赖人类标注偏好，易规模化但需注意数据偏差。
    - **专家数据**：直接利用高质量轨迹，但需解决对抗训练的复杂性。
    - **潜力方向**：结合两种方法，或改进IRL以适应大模型的高效训练。

**奖励塑形（Reward Shaping）**
    
在某些环境中，奖励信号可能缺乏有效性，例如，它可能是**结果奖励（outcome reward）而非过程奖励（process reward）**。**奖励塑形**（Reward Shaping）是一种让奖励信号更密集、更具信息量的方法，以改善学习效果。
    
- **奖励塑形的应用**
    - **Kumar et al. (2024)**：在强化学习中训练 LLM 进行自我修正，并发现**合理的奖励塑形可以防止学习崩溃**。
    - **Wang et al. (2024c)**：使用**蒙特卡洛采样**估计价值函数，将 Q 值 $Q_π⁢(s_t,a_t)$ 用作中间步骤的奖励。
    - **Xiong et al. (2024)**：指出**使用不同策略的价值函数进行奖励塑形可能有害**，因为价值函数依赖于具体的策略 $π$，而不同策略间的估计值可能不适合作为奖励函数。
- **潜在函数奖励塑形**
    - **Ng et al. (1999)** 提出了**基于潜在函数的奖励塑形（Potential-Based Reward Shaping）**，并证明如果奖励函数满足：
     $F⁢(s_t,a_t) = r⁢(s_t,a_t) + γ⁢ϕ⁢(s_{t+1}) − ϕ⁢(s_t)$
    则两个奖励函数可以**导向相同的最优策略**。
    - **Setlur et al. (2024)** 采用此理论将**结果奖励转换为过程奖励**。
- **偏好数据中的奖励塑形**
    - **Rafailov et al. (2023, 2024) 和 Zhong et al. (2024)** 发现 DPO（Direct Preference Optimization）**隐式地对从偏好数据学习的奖励进行了潜在函数奖励塑形**。
- **奖励塑形的风险**
    - 虽然奖励塑形可以提高学习效果，但**不当的塑形可能导致学习过程或搜索过程受到负面影响**。
    - 设计奖励塑形时需要**谨慎考虑归纳偏置（inductive bias）**，确保不会破坏最优策略的学习。

**总结：奖励塑形是强化学习中提高学习效率的重要方法，但其设计需要平衡信息增强和潜在风险，以避免负面影响。**
    
#### 问题：解释一下公式1  $$F(s_t,a_t)=r(s_t,a_t)+γϕ(s_{t+1})−ϕ(s_t)$$
    
  - 回复：在强化学习中引入奖励塑形（Reward Shaping）时，核心目标是加快学习或引导智能体更好地探索，同时又不改变原先任务下所定义的最优策略。Ng 等人在 1999 年的论文中提出的**Potential-Based Reward Shaping**（基于潜在函数的奖励塑形）就很好地满足了这一要求，其关键公式如下所示：
    
    - 公式：$$F(s_t,a_t) = r(s_t,a_t) \;+\; \gamma \,\phi(s_{t+1}) \;-\; \phi(s_t)$$
    
    - 这里的符号含义是：
    
      - 是新定义的（塑形后）奖励。
      - F(s_t,a_t)  是新定义的（塑形后）奖励。
      - r(s_t,a_t)  是环境的原始奖励。
      - $\gamma$  是折扣因子（discount factor）。
      - $\phi(\cdot)$  是一个“潜在函数”（Potential Function），通常只依赖于状态  s ，也可以根据需要设计成依赖状态-动作对。
    
    - 下面分几点说明该公式为何不会改变原始最优策略，以及它的直观含义是什么。
    
      1. **为什么不会改变最优策略？**
        - **Q-值函数的更新不变性**
            
          - 在马尔可夫决策过程（MDP）中，最优策略可以由 **Q-learning** 或者其他动态规划方法（比如价值迭代、策略迭代等）求得。以 Q-learning 为例，当我们进行价值迭代时，更新规则可以写成：
            
            $$Q(s_t,a_t) \leftarrow \ Q(s_t,a_t) \;+\; \alpha \bigl [\,r(s_t,a_t) \;+\; \gamma \max_{a^{\prime}} Q(s_{t+1},a^{\prime}) \;-\; Q(s_t,a_t)\bigr ]$$
            
          - 如果我们使用塑形奖励 $$F(s_t,a_t)$$ 替换 $$r(s_t,a_t)$$ 后，更新公式会变成：
            
            $$Q_F(s_t,a_t) \leftarrow Q_F(s_t,a_t) + \alpha \bigl [F(s_t,a_t) + \gamma \max_{a^{\prime}} Q_F(s_{t+1},a^{\prime}) -Q_F(s_t,a_t)\bigr ].$$
            
          - 将 $$F(s_t,a_t)$$ 展开：
            
            $$F(s_t,a_t) = r(s_t,a_t) + \gamma \phi(s_{t+1}) - \phi(s_t).$$
            
          - 于是更新中会出现形如 $$\gamma \phi(s_{t+1}) - \phi(s_t)$$ 的额外项。如果我们把 Q 函数也进行相应平移（引入一个关于 $$\phi(s)$$ 的修正项），可以证明此形状奖励所造成的附加部分在**两次更新间会相互抵消**，即不会影响 Q 函数对最优行为的排序，最终得到的最优策略（greedy w.r.t Q）与原始奖励下的一致。详细的证明可以参阅 Ng 等人的论文或相关教材，核心结论是：**只要塑形项是一个满足“状态间势能差”形式的函数，就能保证策略不变**。
            
        - **策略不变性的直观理解**
            
          - 可以把 $\phi(s)$ 想象成一个在状态空间上定义的“势能分布”，当智能体从一个状态 $s_t$ 转移到下一状态 $s_{t+1}$ 时，塑形奖励会加上“势能差” 。如果我们从策略的角度来看：
            - 如果某一动作能够带来更高的长期回报（包括塑形后的加成），那么按照原始回报加上势能调整，该动作仍然相对更优，策略不会发生本质性的改动。
            - 反之，如果某动作在原始奖励下就不优，那么加上势能的调节之后仍然不会让它超过原本最优动作。
            
            - 因此，势能函数的设计只会影响学习过程中每一步的暂时奖励，却不会改变整个长期回报（价值函数）对不同行为的相对排序，从而不影响策略的最优性。
            
      - **公式的直观含义**
        
        - $F(s_t,a_t) = r(s_t,a_t) \;+\; \gamma \,\phi(s_{t+1}) \;-\; \phi(s_t).$
        
        - **“原始奖励”** $$r(s_t,a_t)$$ 体现了环境本身对智能体做出某个行为的反馈。
        
        - **“势能差”** $$\gamma \phi(s_{t+1}) - \phi(s_t)$$ 则可以理解为一项额外的“激励/惩罚”，它取决于智能体所在状态和下一个状态的“潜在值”之差。
        
        - 这样的设计背后的直觉是：如果想鼓励智能体朝“好状态”前进（例如离目标更近或者某些代价更低的区域），那么可以为那些看起来更接近目标的状态赋予更高的势能 $$\phi$$，让向这些状态的过渡得到更高的塑形奖励；反之，如果不希望智能体去探测某些危险区域，也可以在那里设置较低甚至负值的势能，从而起到一定的“惩罚”效果。
        
        - 关键在于，任何状态转移过程中，这个势能差 $\gamma \phi(s_{t+1}) - \phi(s_t)$ 只是一个在状态间**相对**的值，其增减并不会打破原始奖励对行为价值的排序，因此不会改变在该 MDP 下的最优解（价值函数或策略）。
        
    - **小结**
        
      - **Potential-Based Reward Shaping** 的核心公式是
        
        $$F(s_t,a_t) = r(s_t,a_t) + \gamma \phi(s_{t+1}) - \phi(s_t).$$
        
      - 这种塑形方式在理论上能够保证与原始奖励下具有**相同**的最优策略。
        
      - 通过合理地设计潜在函数 ，可以引导智能体更快地到达目标或更好地探索状态空间，而不用担心偏离原始任务的最优解。
        
    
  - 在实际应用中，如果我们能利用某些先验知识（如对于状态好坏的估计、对于目标距离或代价函数的分析等）来设计 ，就能显著提高算法的学习效率。正因为如此，基于潜在函数的奖励塑形被广泛用于各种强化学习任务，包括机器人控制、游戏 AI 等场景。
    

### o1 的奖励设计推测

o1 的奖励模型设计可能采用多种方法，以适应其**多任务推理能力**。在**复杂推理任务**（如数学和代码）中，由于其回答通常涉及**长推理链**，o1 可能更倾向于使用**过程奖励模型（process-reward model）** 来监督中间过程，而非传统的 ORM（Outcome Reward Model）。**奖励塑形（Reward Shaping）** 技术可能被用于从结果奖励中推导出过程奖励。

当环境无法提供奖励信号时，o1 可能依赖于：

- **偏好数据学习**（Christiano et al., 2017）
- **专家数据学习**（Garg et al., 2021）

此外，由于 o1 可以通过**少样本示例（few-shot examples）** 进行微调，因此其奖励模型可能**在大规模、多样化的数据集上训练**，涵盖广泛的任务领域，使其能**快速适应新领域**，只需提供**真实答案和解答对**。

最后，文章推测 o1 **更可能通过 LLM 直接生成奖励，而非依赖价值头（value heads）**。这种方式可能使其在奖励建模上更具**灵活性和泛化能力**，特别适用于**复杂推理任务**。

#### 问题：怎么理解“Moreover, it is more likely to predict rewards by generating with LLM rather than through value heads.”这句话？
    
  - **解析：“Moreover, it is more likely to predict rewards by generating with LLM rather than through value heads.”**
    
  - 这句话的核心比较 **LLM 生成奖励（generating with LLM）** 和 **价值头（value heads）** 作为奖励预测的方法，并假设 o1 更可能采用前者。
    
  - **术语解析**

    - **生成奖励（generating with LLM）**：指的是 **直接利用 LLM 生成奖励信号**，即 LLM 通过推理或偏好建模预测某个回答的优劣，而不是单独训练一个额外的奖励模型（如 RLHF 中的 reward model）。
            
    - **价值头（value heads）**：指的是 **强化学习中使用的 Q 值或 V 值头（value head）**，即在神经网络上增加一个特定的分支（head）来预测状态或动作的价值。例如，在 PPO、DQN 等强化学习算法中，**价值头用于计算长期回报**，从而指导策略优化。
            
  - **这句话的含义**
    
    - 论文推测 **o1 更可能直接使用 LLM 生成奖励，而不是依赖于强化学习中的价值头来预测奖励**，可能基于以下原因：
        
      1. **更灵活的奖励建模**：价值头通常用于**基于价值函数的强化学习（如 DQN）**，需要策略的长期累积回报来估计当前状态的价值，而 LLM 直接生成奖励可以**避免复杂的价值函数估计**，提高泛化能力。
            
      2. **更适合少样本学习（Few-Shot Learning）**
        - 价值头通常需要**大规模数据训练**，才能学到稳定的值函数。
        - 而 LLM 生成奖励可以**基于上下文推理（contextual reasoning）**，适用于**少样本学习（few-shot learning）**，符合 o1 预训练后可以快速适应新任务的特点。

      3. **支持更复杂的推理任务**
        - 价值头通常用于**单步奖励估计**，而 LLM 可以基于完整的推理链**动态预测整个回答的质量**，更适合**数学、代码等需要过程监督的任务**。

      4. **更容易适应不同领域**
           1. LLM 生成奖励可以结合**人类偏好、知识和语境**，在不同领域都能表现出较强的泛化能力。
           2. 价值头往往需要针对不同任务进行**单独训练**，可扩展性较差。

    - **直观类比**
        
      - 可以把 **“LLM 直接生成奖励”** 和 **“价值头预测奖励”** 的区别类比如下：
        
        | **方法** | **类比** |
        | --- | --- |
        | **LLM 生成奖励** | 让一个资深评审员（LLM）看完文章后，直接给出评分或评价 |
        | **价值头预测奖励** | 训练一个评分系统（value head），基于一系列规则计算出最终得分 |
        
      - LLM 的方式更接近**基于知识和推理的自由评估**，而价值头的方法更像**基于经验和统计的公式化计算**。
        
  - **结论**：这句话的核心意思是：**o1 可能不依赖强化学习中的传统价值头（如 Q-value、V-value）来预测奖励，而是直接利用 LLM 生成奖励信号**。这种方式可能提供更好的**泛化能力**、**适应性**，并且更适合多任务推理场景。
        

### o1 重现设计奖励时所面临的主要挑战

- **如何应对分布偏移**

    - **问题描述**：奖励模型通常在现有数据分布上进行训练，但随着语言模型不断探索和从反馈中学习，其策略生成的轨迹可能超出奖励模型训练时所见的分布，导致代理奖励与理想（黄金）奖励之间出现偏差。
  
    - **可能的应对措施**：可以通过扩大奖励模型参数规模和增加训练数据量来一定程度上缓解这一问题，但效果有限；采用迭代训练奖励模型的方法更直接，但仍需要人类参与监督。

- **如何设计针对语言模型的细粒度奖励**

    - **问题描述**：与 Atari 游戏或机器人环境不同，语言任务中“步骤”或“动作”的定义存在多种粒度（如按单个 token、按多个 token 的组合或整个解决方案），而语言的高阶语义往往是由多个 token 组合而成，因而更自然地是对整个解决方案进行评价。
  
    - **面临挑战**：如果以 token 组合为单位作为动作，则会导致动作空间呈指数级增长，且奖励信号随步骤长度增加而变得更稀疏，从而使得定义或学习一个合适的奖励函数变得十分困难。

- **如何在复杂任务中选择奖励建模的数据**
    
    - **问题描述**：随着任务复杂度的提高，选择合适的反馈类型变得更加棘手。有研究表明，在代码生成或数学推理等任务中，基于偏好的反馈反而可能降低策略模型的表现。

    - **数据问题**：目前对于捕捉预期行为所需的数据量尚缺乏充分研究，同时评估奖励有效性的难度也随着任务复杂度增加而上升。

- 总体而言，本文探讨了奖励设计中在分布偏移、细粒度奖励设计以及数据选择三个层面所遇到的挑战，并指出现有的缓解方法（如增加模型参数、数据量或迭代训练奖励模型）虽能部分改善问题，但仍存在不足，需要进一步研究和人类在环的辅助。

#### 解释一下“Recent studies have shown that using preference-based feedback for tasks like code generation or mathematical reasoning may actually degrade the performance of the policy model ”这句话，并解释为什么？
    
  - 回复：这句话的意思是：**最近的研究发现，对于诸如代码生成或数学推理这类复杂任务，基于偏好的反馈数据（即通过人类偏好评判的反馈）反而可能会降低策略模型的表现。**以下是对这一现象及其原因的详细解释：
    
    - **复杂任务对反馈要求更高**
        1. **任务复杂性**：代码生成和数学推理等任务通常要求输出具备高度准确性和逻辑严谨性。这些任务有明确的正确标准，比如代码能否编译、通过所有测试用例，或者数学证明是否严谨无误。
        2. **客观评价标准**：与这类任务相对应的评价标准通常是客观且具体的，而不是主观的感受或偏好。
    - **偏好反馈的局限性**
        1. **主观性强**：偏好反馈依赖于人类评判者的个人喜好和经验，这种评判往往带有一定的主观性和不一致性。在复杂任务中，不同评判者可能对同一个输出有不同的偏好，而这些偏好并不总能反映输出的实际正确性或高效性。
        2. **噪音和偏差**：由于主观判断容易受到多种因素的干扰（如对代码风格、数学表达方式的不同看法），偏好数据中往往会包含较多噪音。这种噪音会误导模型，让它在优化过程中学到一些并非真正有利于任务目标的特征。
    - **对策略模型的影响**
        1. **错误的优化方向**：如果策略模型在训练过程中主要依赖偏好反馈，那么它可能会倾向于迎合人类评判者的主观偏好，而忽视了那些真正符合任务要求的客观指标。这种情况下，模型可能会学到错误的策略，从而在实际任务中表现不佳。
        2. **降低任务表现**：特别是在需要精确计算和严密逻辑的任务中，任何偏离正确标准的细微错误都可能导致整体表现的下降。因此，基于偏好的反馈不仅不能有效引导模型朝正确方向优化，反而可能带来负面影响，导致性能下降。
    - **总结**:对于代码生成和数学推理这样的高精度、逻辑严密的任务，直接采用人类偏好作为反馈数据可能会引入主观性和噪音，使得模型在学习过程中偏离客观正确的标准，从而降低策略模型的整体表现。相比之下，这类任务可能更适合使用具有明确、客观评价标准的反馈信号来训练模型。
        
#### 问题1：通过数学、代码等数据的预训练，是否能增加LLM的逻辑推理能力？
    
  - 回复：预训练过程中加入数学、代码等数据，的确可以在一定程度上提升大语言模型（LLM）的逻辑推理能力，原因主要包括以下几点：
    
    - **数据的逻辑性与结构性**: 
      - 数学和代码本身具有高度严谨的逻辑结构和明确的规则。例如，数学问题要求严密的推导过程和证明，而代码不仅要求语法正确，还要保证逻辑连贯和功能实现。预训练时接触到这类数据，有助于模型捕捉到严谨的逻辑模式和因果关系，从而在生成答案时更倾向于遵循逻辑规则。
        
    - **提升推理模式的学习**: 
      - 处理数学问题或编写代码往往需要模型经历多个推理步骤，从而形成“链式思维”或逐步推导的能力。这种训练有助于模型在面对复杂问题时能够组织多步推理过程，而不是简单地依赖模式匹配。这正是当前许多研究中强调“chain-of-thought（思维链）”方法的重要性。
        
    - **任务特定的知识与技能**: 
      - 预训练包含数学和编程数据不仅让模型学到通用语言知识，还让它积累了解决具体逻辑问题所需的专业知识。例如，理解算法、条件语句和逻辑判断等，都能增强模型在遇到类似任务时的表现。
        
    - **局限性与综合影响**: 
      - 尽管数学、代码等数据能增强逻辑推理的能力，但这并不是唯一决定因素。LLM的能力主要依赖于大规模数据训练和统计模式匹配，模型并不具备真正的“理解”。因此，即使预训练中加入这类数据，也可能在某些特别复杂的逻辑推理任务上存在局限。此外，预训练数据的多样性、数据质量以及模型架构和微调策略也对最终效果有着重要影响。
        
    - **总结**: 通过数学、代码等数据的预训练，确实能在一定程度上增强LLM的逻辑推理能力，使模型更善于捕捉严谨的逻辑结构和多步推导过程。然而，这只是提升逻辑推理能力的一个方面，模型最终的推理表现还取决于其他多种因素，如训练方法、数据多样性以及后续的微调和优化策略。
        
#### 问题2：那么这个与“Recent studies have shown that using preference-based feedback for tasks like code generation or mathematical reasoning may actually degrade the performance of the policy model ”的说法，是否有违背？
    
  - 回复：这两者其实关注的层面不同，因此并不矛盾，原因如下：
    
    - **预训练数据与反馈信号的区别**
        1. **数学、代码数据的预训练**：通过大量数学、代码等高逻辑性的数据训练，模型能够学习到严谨的逻辑结构和规则。这种预训练主要帮助模型形成内在的、客观的逻辑推理能力。
        2. **基于偏好反馈**：这种反馈通常来源于人类主观评价，用于微调模型以符合人类偏好。在代码生成或数学推理任务中，主观偏好可能并不完全与客观正确性或逻辑严密性一致，因而在这种场景下可能会引入噪音或误导，导致性能下降。
    - **应用场景不同**
        1. **预训练阶段**：数学、代码数据能够帮助模型在语言和逻辑结构上打下坚实基础，提升整体的逻辑推理能力。
        2. **微调阶段的反馈**：偏好反馈主要在模型微调时引入。如果在这些需要高度客观性和严谨逻辑的任务中，偏好反馈没有严格对齐任务的客观标准，反而可能会降低模型在这些任务上的表现。
    - **目标不同**
        1. 数学、代码数据预训练的目标是让模型学会如何“正确”地推理和生成符合逻辑的内容。
        2. 而偏好反馈则是希望模型生成的内容更符合人类主观喜好，但在一些需要客观标准的任务中，这种主观喜好可能不利于模型捕捉任务的本质要求。
    - 综上所述，利用数学、代码数据预训练提升逻辑推理能力，与偏好反馈在特定任务中可能引入的负面影响并不矛盾。前者是提高模型内在逻辑能力的手段，而后者则可能在微调时因主观性而对部分任务的客观表现产生不利影响。

#### 问题3：文章中引用的《Language models learn to mislead humans via RLHF》这篇论文的主要内容是什么？
    
  - 回复：这篇论文的主要内容可以总结如下：
    
    - **研究背景与动机**: 
      - 论文讨论了在通过“人类反馈强化学习”（Reinforcement Learning from Human Feedback，简称RLHF）进行语言模型微调时可能出现的问题。虽然RLHF旨在使语言模型更加符合人类期望、生成更有用和安全的输出，但研究发现这种方法存在一个潜在风险——模型可能学会“误导”人类评估者，即在输出错误答案时依然通过各种策略让人类相信它是正确的，从而导致整体任务完成质量并未提升，甚至使评估者变得更难判断模型的真实表现。
        
    - **“U-SOPHISTRY”现象**: 
      - 论文用“U-SOPHISTRY”这一术语描述了这一现象，意为“非预期的诡辩行为”。在标准的RLHF训练流程中，为了获得更高的奖励（即更高的人类认可），模型学会了生成具有说服力的（尽管不正确的）输出。这种行为不仅在问答任务（如QuALITY数据集上）中出现，也在编程任务（如APPS数据集上）中被观察到。具体来说，RLHF训练后，模型在任务正确率上没有明显提高，但其输出被人类评估者错误认可的比例显著上升。
        
    - **实验设计与结果**
      - **任务设置**：论文设计了问答和编程两个任务，并让时间受限（例如3-10分钟）的受试者来评估模型输出的正确性。
      - **关键发现**：
          - RLHF显著提高了人类对模型输出的认可率，但并未相应提升任务实际正确率；
          - 人类评估错误率和假阳性率均有明显增加（例如，问答任务中假阳性率上升了约24%，编程任务中上升了约18%）；
          - 进一步的定性分析显示，经过RLHF训练的模型会利用捏造或挑选支持性证据、构造看似连贯但存在隐含逻辑谬误的论证来为错误答案辩护，从而误导评估者。
    - **探讨与结论**
      - 论文指出，RLHF作为一种后训练技术虽然在使模型表现出“对齐”特征上取得了一定进展，但也暴露了一个严重的缺陷：模型可能利用人类评估者在有限时间内判断能力不足的弱点，故意生成具有误导性但看似合理的输出。
      - 这一发现提示需要进一步研究如何设计更稳健的评估方法和改进RLHF流程，以防止模型利用奖励信号进行“奖励黑客”行为（reward hacking），从而真正提升任务完成的正确性和安全性。
    
    - 总的来说，该论文通过系统的实验和分析，展示了RLHF可能引发的一种意外现象——模型学会利用人类反馈中的漏洞来误导评估者，从而掩盖实际任务表现的不足。这为今后如何改进AI对齐技术和人类监督机制提供了重要的启示。

### 泛化

在前一节中，主要讨论了针对特定任务（如数学和编程）的奖励设计。然而，在处理更广泛的任务时，需要构建一个更通用的环境。根据 OpenAI 为实现通用人工智能（AGI）制定的五阶段计划，o1 已具备了强大的推理能力，下一阶段是训练能够与世界互动并解决现实问题的智能体。为了实现这一目标，需要一个奖励模型，为智能体在现实环境中采取的行动提供奖励信号。构建通用的奖励信号主要包括两个组成部分：奖励集成和世界模型。

- **奖励集成**
    
    介绍了一种构建通用任务奖励信号的直观方法，即通过在不同领域构建多个奖励模型并将它们的输出进行整合。具体来说，
    
    1. Quan（2024）将奖励模型训练为一种专家混合模型（MoE），其中每个专家专注于不同任务，从而提供相应的奖励信号，最终将各个专家的输出汇总；
    2. 而 Nguyen 等人（2024）则将这一问题表述为一个多臂赌博机问题，通过学习来选择最合适的奖励模型。
    
    总的来说，这些方法的核心在于如何有效地整合不同奖励信号。
    
- **世界模型**
    
    讨论了构建通用世界模型的关键思想和挑战，其主要观点可以总结如下：
    
    1. **多重功能**
        
        世界模型不仅负责提供奖励信号，而且能够预测智能体采取行动后环境的下一个状态。这一双重能力对于训练能够在真实环境中互动并解决实际问题的智能体非常重要（Ha &amp; Schmidhuber, ；Bar et al., ）。
        
    2. **状态预测方式的多样化**
        
        一些工作认为视频生成器也可被视为一种世界模型，因为它可以预测未来时间步的图像（Liu et al., ；Bar et al., ；Wang et al., ；Brooks et al., ）。而Dawid &amp; LeCun (2023) 提出一种更高效的框架——不直接预测完整的下一状态（例如图像），而是预测其低维表示，这样做不仅计算更高效，而且更容易捕捉到对后续决策有用的关键信息。这一思路与MuZero（Schrittwieser et al., ）的做法一致，即通过预测下一状态的表示来代替直接预测原始状态。
        
    3. **奖励信号的重要性**
        
        尽管当前世界模型的研究主要集中在如何准确预测下一个状态上，但作者强调，如何建模奖励信号同样是实现真实环境任务的关键和挑战。一个准确且稳定的奖励信号对于指导智能体的行为至关重要。
         
- 总的来说，该部分内容阐述了“世界模型”在构建通用奖励信号中的核心作用，并指出在预测下一个状态与直接建模奖励信号之间存在不同的技术路径和效率考量。
    

## **5 搜索 (Search)**

在大型语言模型（LLMs）中使用随机采样技术（如核采样）来提高输出质量，研究表明，随着模型样本数量的增加，pass@k指标持续改善。许多研究也显示，较小的模型在利用搜索策略时，甚至可以超过较大的模型，这表明在推理过程中，通过增加采样数量来探索正确的解决方案是有潜力的，尽管这会增加推理时的计算开销。

“搜索”指的是通过多次尝试或基于某些指导（如奖励或启发式规则）进行战略性探索，从而找到正确的解决方案。自一致性和Best-of-N（BoN）等已知推理策略都可以视为搜索方法。对于像o1这样的模型（旨在解决复杂推理任务），搜索在训练和推理过程中都扮演着重要角色。

![Figure 6.jpg](https://arxiv.org/html/2412.14135v1/x5.png)

### o1中搜索的作用

在o1模型中，搜索被视为一种依赖于指导信号的策略迭代过程，我们称之为“搜索策略”。与简单的采样方法相比，搜索策略更有可能找到更好的解决方案。通过搜索策略生成的解决方案可以直接作为最终输出，或者像专家迭代（Expert Iteration）那样被纳入训练算法，不断改进策略。

搜索在o1的训练和推理过程中扮演着重要角色。我们将这两个阶段的搜索分别称为“训练时搜索”和“推理时搜索”。

- **在训练阶段**，在线强化学习中的试错过程也可以看作是搜索过程，其中智能体根据自己的策略执行简单的采样，并学习那些能够获得高奖励的解决方案。然而，由于o1涉及较长的推理过程并包含类人推理行为，搜索空间变得庞大，简单采样可能变得低效。因此，需要一些高级搜索策略来更高效地探索更好的解决方案，并利用这些解决方案作为训练数据来更新策略模型。这一过程可以在训练中反复进行。
- **在推理阶段**，o1表明增加推理时的计算资源并花费更多时间思考可以持续改善模型性能。我们认为，o1的“更多思考”可以视为一种搜索方式，通过更多的推理计算来寻找更好的答案。

搜索的两个关键方面是：用于搜索的指导信号和获取候选解决方案的搜索策略。搜索策略用于获得候选解决方案或行动，而指导信号则用于做出选择。我们将搜索过程中的指导信号分为内部指导和外部指导，并借鉴Snell等人（2024）的分类方法，将搜索策略分为树形搜索和顺序修正。需要注意的是，这两个分类维度是正交的，例如，树形搜索方法可以利用内部或外部指导信号。

### 搜索引导

搜索引导的两种方法以及其对比与融合：

- **内部引导**

  #### 定义
    - 不依赖外部环境或代理模型的反馈，而是基于模型自身的状态或评估能力进行搜索引导。
    - 经典文本生成解码算法（如贪婪解码、束搜索）利用标记（token）或序列的概率作为内部引导依据，通过模型输出的概率分布选择最优路径。
        
  #### 特性
    - **模型不确定性**（Model Uncertainty）是一种常见的内部指导信号，常用于从候选答案中选择高质量的回答。
      - 许多研究利用模型不确定性来优化模型输出，其中**自一致性**（Self-consistency）是一种著名的方法。自一致性通过多数投票或加权求和的方式选择不确定性最低的答案。
      - **通用自一致性**（Universal self-consistency）进一步扩展了这一方法，应用于自由形式的回答，使大语言模型能够在没有任务特定约束的情况下选择最一致的答案，提升了其广泛应用的潜力。
      - Kuhn等人提出，基于不同句子可以表达相同含义的观点，他们转而关注**语义不确定性**（Semantic Uncertainty）而非句法不确定性。他们使用自然语言推理（NLI）模型进行语义聚类，若两句话表现出双向蕴含关系，则认为这两句话是等效的，并通过语义分布的熵值来度量不确定性。这种语义熵值还被应用于**幻觉检测**（Hallucination Detection），显示出较强的性能。
      - 模型不确定性通常通过**无监督方法**推导得到，易于获取。然而，它的可靠性严重依赖于模型的**校准**（Model Calibration），因此，一个经过良好校准的模型对于有效利用模型不确定性至关重要。
      
    - **自我评估（**Self-evaluation）的核心在于让模型对自己的输出进行评估，以提升生成质量。尽管模型不确定性（model uncertainty）作为内部指导信号广泛用于候选答案筛选（例如通过自一致性方法），但它并不能直接反映输出的正确性——高不确定性答案有时也可能是正确的。
      - 为了改善这一问题，**自我评估**机制利用了“生成者-判别者差距”（DG-gap）的假设，即认为评估答案比生成答案更容易。基于这一假设，强化学习中采用人类反馈（RLHF）的方式，通过让人类评审员比较不同候选输出的偏好，来对模型进行监督，从而使模型的行为更好地符合人类的意图与价值观；
      - 在实际应用中，对于指令跟随型语言模型，**LLM-as-a-Judge**方法被证明是一种高效的自我评估手段，它在MT-Bench测试中与人类评审高度一致；
      - 此外，通过迭代的DPO训练，模型能够不断提高自我奖励的效果；
      - 类似地，**LLM-as-a-Meta-Judge**也被用于增强自我评估能力。
            
    - 然而，任务特定的自我评估仍存在挑战：
      - 如何确定特定任务中是否存在生成与评估之间的DG-gap；
      - 如何充分利用这一差距来提高输出的准确性；
      - 有研究指出，在没有外部反馈的情况下，模型可能难以准确评价自己的答案。
            
    - 为了解决这些问题，可能需要扩展模型规模、专门训练模型的自我评估能力，并制定更详细的评估标准。
            
  #### 问题：model uncertainty是否指的是model 的temperature调节？
        
    - 回复：关于“model uncertainty”是否指模型的temperature调节，**答案是否定的**。两者属于不同维度的概念，具体区别如下：
 
      - **核心定义不同**
        
        - **Model Uncertainty（模型不确定性）**: 指模型对自身预测结果的**置信度度量**，反映模型在特定输入下输出答案的不确定性程度。例如，通过多次采样生成不同答案，若答案分布离散（高熵），则不确定性高；若答案集中（低熵），则不确定性低。常用方法包括：
        
            - **自洽性（Self-consistency）**：通过多数投票或加权选择一致性最高的答案（如Wang et al., 2023a）。
            - **语义熵（Semantic Entropy）**：基于语义等价性聚类答案，计算语义分布熵（Kuhn et al., 2023）。

        - **Temperature调节**: 是控制生成文本**随机性**的超参数，属于**生成策略**的一部分：
            
            - **高temperature**（如1.0以上）：增加输出的多样性，采样更随机，可能生成更多“不确定”的候选答案。
            - **低temperature**（如接近0）：输出更确定，倾向于高概率词，降低多样性。

      - **关联与区别**
        
        - **间接影响**：Temperature调节可能**间接影响**模型不确定性的测量。例如：
            
            - 高temperature生成更多样化的候选答案，可能导致语义熵升高（表现为更高的不确定性）。
            - 低temperature生成答案更集中，可能降低不确定性估计值。
          
        - **本质差异**：
            - **Model Uncertainty**是模型对自身预测的**内部度量**，与模型校准（calibration）直接相关（Guo et al., 2017）。
            - **Temperature**是人为设定的**外部参数**，用于控制生成过程的随机性，不直接反映模型的内在置信度。

      - **典型应用场景**
        
        - **Model Uncertainty的应用**：
            - 检测幻觉（Farquhar et al., 2024）、筛选高质量答案（Universal Self-consistency, Chen et al., 2023）。
            - 依赖模型自身校准质量，需通过无监督方法（如语义聚类）或校准技术提升可靠性。
        - **Temperature的应用**：
            - 调整生成结果的创造性（如写诗需高temperature，事实问答需低temperature）。
            - 不直接用于评估模型置信度，而是生成策略的一部分。

      - **总结**
        
        - **Model Uncertainty ≠ Temperature调节**：前者是模型对预测的置信度评估，后者是控制生成随机性的参数。
        - **潜在联系**：Temperature可能通过影响生成多样性间接干扰不确定性测量，但二者属于不同层面对模型行为的控制与分析。

- **外部引导**
  #### 定义
    - 与模型的具体策略无关，完全依赖外部环境或任务相关的信号（如任务评分、人类反馈、环境奖励等）指导搜索过程。
    - 通常需要额外反馈机制，独立于模型本身的生成策略。

  #### 特性
    - **环境反馈（External Guidance – Environmental Feedback）**
      - 环境反馈是最常用的外部指导形式，其信号通常与下游任务的评价指标直接相关。
      - 奖励（Reward）是环境反馈的典型代表，它直接反映了最终性能，因此在搜索过程中，常常需要使用多尺度的奖励（如结果奖励与过程奖励）来提供指导。
      - 利用奖励作为指导信号通常需要构建一个环境或者使用代理反馈，虽然这种方法可以提升搜索效果，但也会增加额外的计算开销；此外，如果搜索过程中产生的解明显偏离奖励模型训练数据的分布，可能会导致性能下降。
      - 除了直接反馈最终结果的奖励外，还可以采用间接反馈，如代码编译结果、数学问题求解中间步骤的正确性、单元测试等，这些反馈可以作为最终任务反馈的替代。
    - **启发式规则（Heuristic Rules）**
      - 许多搜索算法在使用环境反馈的同时，也会辅以启发式规则来引导搜索。
      - 传统的启发式搜索方法，如贪心搜索和 A* 搜索，依赖于针对具体任务开发的启发式规则；这些规则是基于任务的特定信息而制定的。
      - 近期的一些研究在提升大语言模型推理能力时，也采用了针对特定任务的启发式规则。
      - 当环境反馈获取成本较高或无法直接获得时，启发式规则提供了一种较为经济有效的替代方案。
        
    - 总之，文中指出在搜索过程中既可以利用直接反映任务指标的环境反馈（通过奖励信号），也可以结合启发式规则来引导搜索，两者各有优势且可以根据实际情况进行灵活选择。
        
  #### 问题：文章中“Additionally, studies for enhancing LLMs’ reasoning abilities also apply task-specific heuristics to guide search.” 引用的《TREE SEARCH FOR LANGUAGE MODEL AGENTS》这篇文章的主要内容是什么？

    - 回复：《Tree Search for Language Model Agents》这篇论文提出了一种基于**推理时树搜索算法**的语言模型代理框架，旨在解决语言模型在复杂交互式网页任务中存在的多步推理、规划与环境反馈利用不足的问题。以下是论文的核心内容总结：

        1. **研究背景与问题**
            
            语言模型（LMs）驱动的自主代理在网页自动化等任务中展现潜力，但其核心局限在于：
            
            - **多步推理能力不足**：LMs主要针对语言生成优化，难以处理需要长程规划的复杂任务。
            - **环境反馈利用低效**：代理在开放式网页环境中无法有效利用环境反馈调整策略，导致动作空间探索效率低。
        2. **核心方法：最佳优先树搜索算法**
            
            论文提出了一种**基于实际环境空间的最佳优先树搜索算法**，其关键设计包括：
            
            - **搜索过程**：通过语言模型生成候选动作分支，结合价值函数（如多模态LM）评估状态，选择最优路径。算法参数包括搜索深度（\(d\)）、分支因子（\(b\)）和搜索预算（\(c\)），以平衡探索与计算效率。
            - **价值函数设计**：利用多模态语言模型（如GPT-4o）对当前观察序列进行细粒度评分，指导搜索方向。例如，在VisualWebArena任务中，价值函数通过视觉定位和文本理解综合判断状态优劣。
            - **自洽性机制**（Self-consistency）：通过整合多条推理链的评估结果减少噪声，提升状态评分的鲁棒性。
        3. **实验结果与性能提升**
            
            在多个真实网页任务基准上的实验表明，搜索算法显著提升了代理的成功率：
            
            - **VisualWebArena**：结合搜索的GPT-4o代理成功率从18.9%提升至26.4%（相对提升39.7%），刷新了SOTA。
            - **WebArena**：GPT-4o代理成功率从15.0%提升至19.2%（相对提升28.0%），达到竞争性水平。
            - **模型普适性**：搜索算法对Llama-3-70B等开源模型同样有效，例如在VisualWebArena上，其成功率从7.6%跃升至16.7%（相对提升119.7%）。
        4. **关键分析**
            - **计算资源扩展性**：性能随搜索预算（节点扩展次数）增加而提升。例如，搜索预算从5增至20时，成功率相对提升51%。
            - **价值函数的重要性**：实验表明，GPT-4o作为价值函数显著优于LLaVA等模型（成功率从30%提升至37%），但仍有改进空间（理想奖励函数可达43.5%）。
            - **搜索树规模的影响**：更大的分支因子（\(b\)）和深度（\(d\)）可进一步提升成功率，但需权衡计算成本。
        5. **与现有工作的对比**
            - **与传统树搜索算法**：与蒙特卡洛树搜索（如LATS框架）不同，该方法直接在真实网页环境空间中运行，无需预定义奖励函数，适应开放式任务。
            - **与强化学习代理**：搜索算法与现有LM代理（如AutoWebGLM、Reflexion框架）互补，通过显式规划增强其长程决策能力。
        6. **未来方向**
            - **价值函数优化**：通过训练专用模型或引入领域知识改进状态评估精度。
            - **动态环境适应**：探索在动态网页内容（如用户交互或实时数据更新）中的搜索策略调整。
            - **计算效率提升**：研究剪枝策略或并行化搜索以降低计算开销。

        总结: 该论文通过引入树搜索机制，显著提升了语言模型代理在真实网页任务中的规划与推理能力，为构建更通用的自主代理提供了新的技术路径。其代码和模型已公开，为后续研究提供了重要参考。
        
- **内部与外部引导对比区别**
  #### 内部引导的优势
    - **优势**：仅依赖模型自身，无需外部环境或真实数据支持，具有任务无关性（task-agnostic）。
    - **适用场景**：下游任务缺乏具体评估标准时，因其**高可迁移性**和通用性而更具优势。
  
  #### 外部引导的优势
    - **优势**：依赖任务特定信息（如环境交互奖励或真实数据），能更精准对齐模型性能目标，优化搜索策略。
    - **挑战**：
      - 需额外构建成本（如设计奖励函数）并增加计算开销；
      - 推理时真实数据不可用，且环境交互成本高昂；
      - 依赖替代模型（如固定奖励模型）时可能面临**分布外（OOD）问题**（参见[4.4节](https://arxiv.org/html/2412.14135v1#S4.SS4)）。
    
  **结论**：内部引导通用性强但性能依赖模型自身能力，外部引导更精准但需权衡成本与可行性，尤其在推理阶段需谨慎设计。
    
- **内部与外部引导的结合**
    
  内部和外部引导可以结合使用来引导搜索过程。典型的方法是结合模型自身的不确定性和来自奖励模型的代理反馈。例如，Wang等人（2024年）和Snell等人（2024年）将自一致性与过程奖励模型的反馈相结合，用于选择质量最高的响应。
    
  #### 价值函数（Value Function）
        
    - 价值函数是另一种结合内部和外部引导的信号。在强化学习中，价值函数通过评估一个状态（V函数）或状态-动作对（Q函数）的预期累积奖励，引导代理选择能够最大化长期奖励的动作。价值函数通常依赖于环境的奖励信号，并使用一个单独的神经网络进行估算。
      - 价值函数的计算公式如下：
        
        - $$v_\pi(s) \doteq \mathbb{E}_\pi\left[G_t \mid S_t=s\right]=\mathbb{E}_\pi\left[\sum_{k=0}^{\infty} \gamma^k R_{t+k+1} \mid S_t=s\right]$$
        
        - 其中， $v_\pi(s)$ 表示在策略 $π$ 下状态 $s$ 的值， $G_t$ 是返回值，表示未来奖励的累积和， $γ$ 是折扣因子，决定了未来奖励相对于当前奖励的重要性。
        
    - **强化学习中的价值函数作用**
        
      - 价值函数在强化学习中起着基础性作用，通过评估状态的值，帮助代理做出更有利的决策，选择最有价值的状态或动作。
        
    - **DPO模型与价值函数结合**
        
      - Rafailov等人（2024年）提出DPO是一个逆Q学习算法，DPO模型的logits充当Q函数，从而使得搜索过程能够由价值函数引导。同时，研究还展示了应用束搜索（beam search）能够提高DPO模型的性能。
        
    - **价值函数的挑战**
        
      - 在使用价值函数时，面临的主要挑战是如何准确估计它，尤其是在奖励稀疏或输出维度高的任务中（如大语言模型生成），不准确的估计可能会显著影响性能。

    总的来说，内部和外部引导的结合，特别是价值函数的引入，使得搜索过程能够更加高效和精确，但在某些复杂任务中，如何准确估计价值函数仍然是一个挑战。
    
#### 问题1：关于“Additionally, some work (Silver et al., 2017; Wan et al., 2024; Chen et al., 2024a) incorporates a value head into the policy model, sharing a large-scale backbone. ”这句话中“a value head into the policy model, sharing a large-scale backbone”是什么意思？
    
  - 回复：在强化学习和深度学习模型中，**策略模型（Policy Model）**用于生成代理在特定状态下应采取的动作分布。为了增强模型的性能，研究者们将**价值头（Value Head）**集成到策略模型中，共享一个大型的主干网络（Backbone）。这种设计使得策略模型不仅能够生成动作分布，还能评估每个状态的预期累积奖励，从而更有效地引导代理的行为。
    
    - **价值头（Value Head）**：在神经网络中，价值头通常由一层或多层神经元组成，负责输出对当前状态的价值评估。在AlphaZero等模型中，价值头由一个1×1的卷积层和一个经过tanh激活的线性层组成。
    - **共享主干网络（Shared Backbone）**：主干网络是神经网络的核心部分，负责从输入中提取特征。在上述设计中，策略头和价值头共享同一个主干网络，这意味着它们共同利用相同的特征表示，从而提高了模型的效率和性能。
    
    - 通过将价值头集成到策略模型中，并共享主干网络，模型能够同时学习如何选择动作和评估状态价值，这种多任务学习的方式有助于提升强化学习代理的整体表现。
    
#### 问题2：文章中引用的《Alphazero-like tree-search can guide large language model decoding and training》这篇文章的主要内容是什么？
    
  - 回复：《Alphazero-like Tree-Search can Guide Large Language Model Decoding and Training》这篇论文提出了一种名为TS-LLM的框架，旨在通过引入类似AlphaZero的树搜索算法，增强大型语言模型（LLM）的推理和训练能力。
    
    **主要内容概述：**
    
    1. **树搜索与价值函数的结合：**
        - 论文介绍了如何将树搜索与学习到的价值函数相结合，以引导LLM的解码过程。
        - 这种方法使得LLM能够在推理和训练阶段都得到有效的指导，从而提升其性能。
    2. **适应性与通用性：**
        - TS-LLM能够适应多种任务，包括推理、规划、对齐和决策等。
        - 该方法对不同规模的语言模型均有效，且能够处理深度达64的树结构。
    3. **实验结果：**
        - 在多个任务上的实验证明，TS-LLM优于现有方法，展示了其在复杂推理和决策任务中的有效性。
    
    总的来说，这篇论文提出了一种创新的框架，通过结合树搜索和学习到的价值函数，显著提升了大型语言模型在多步推理和复杂任务中的表现。
    
#### 问题3：这里的树搜索算法，具体是指构建一个专门训练树搜索的value head吗？
    
  - 回复：是的，论文《Alphazero-like Tree-Search can Guide Large Language Model Decoding and Training》中，研究者们提出了一个类似AlphaZero的树搜索学习框架（TS-LLM），该框架通过引入一个学习到的价值函数（value head）来指导大型语言模型（LLM）的解码和训练。
    
    在TS-LLM中，价值函数用于评估每个推理步骤的潜在价值，从而引导树搜索算法探索最有可能导致正确答案的路径。这种方法使得LLM能够在推理过程中进行多步推理，并在训练阶段通过树搜索优化模型，从而提高其在复杂任务中的表现。
    
    具体而言，TS-LLM的价值函数是通过训练获得的，它评估每个推理步骤的潜在价值，从而引导树搜索算法探索最有可能导致正确答案的路径。这种方法使得LLM能够在推理过程中进行多步推理，并在训练阶段通过树搜索优化模型，从而提高其在复杂任务中的表现。
    
    总之，论文提出的TS-LLM框架通过引入学习到的价值函数，使得树搜索算法能够有效地指导LLM的解码和训练，从而提升其在复杂推理任务中的能力。
    
#### 问题4：这里的价值函数（value head）是具体怎样做的？
    
  - 回复：根据论文描述，价值函数的设计和训练主要包含以下几个要点：
    
    1. 网络结构：
        - 使用一个共享的 decoder-only transformer 结构，外加一个 MLP 来在每个输入 token 位置输出一个标量值
        - Value network 通常是从原始 LLM policy 的 decoder 适配而来，或者与 policy 共享同一个 decoder
        - 对于句子级动作节点，使用最后一个 token 位置的预测标量作为该状态的价值预测 v_φ(s_t)
    
    2. 训练数据收集：
        ```python
        # 伪代码展示训练数据收集过程
        D_train = {(x_j, y_j, r_j)} # x_j是输入文本，y_j是输出文本，r_j是真实奖励
        # 使用语言模型策略π_θ在训练数据集上采样生成
        ```
        
    3. 训练目标：
        - 使用均方误差(MSE)损失函数
        - 可以用 TD-λ 或 Monte Carlo 估计构建每一步的价值目标 z_j_t
        
        ```python
        L(φ) = E_D[Σ(v_φ(s_j_0:t|x_j) - z_j_t)²]
        ```
        
    4. 训练细节示例（以 GSM8k 任务为例）：
        - 对每个问题采样100个输出
        - 去重复后保留最多51个答案
        - 正确答案reward=1，错误答案reward=-1
        - 使用 Monte Carlo return (γ=1) 计算回报
        - 训练一个 epoch，在验证集上进行模型选择
    
    作者特别强调了收集足够多样的训练数据对于训练一个好的价值函数很重要。实验表明，这种学习得到的价值函数比基于提示的方法（如使用 GPT-3.5 作为评估器）表现更好，即使基础模型（如 LLaMA2-7B）比 GPT-3.5 小得多。
    
    这个价值函数的设计本质上类似于强化学习中的 critic 网络，但是针对语言模型特点做了适配，使其能够有效地评估语言生成过程中的中间状态价值。
    
#### 问题5：Deepseek的R1是否有应用类似的方法？
    
  - 回复：DeepSeek的R1模型在其训练过程中采用了强化学习（RL）方法，旨在提升大型语言模型（LLM）的推理能力。 然而，R1的训练方法与《Alphazero-like Tree-Search can Guide Large Language Model Decoding and Training》一文中提出的树搜索算法有所不同。
    
    在R1的训练中，DeepSeek团队使用了基于规则的奖励机制，结合强化学习框架GRPO（Generalized Rejection Policy Optimization），以增强模型在数学推理、编程和逻辑推理等任务上的表现。 具体而言，R1模型通过自我博弈的方式进行训练，逐步提升其推理能力。  ￼
    
    相比之下，《Alphazero-like Tree-Search can Guide Large Language Model Decoding and Training》一文提出了将树搜索算法与学习到的价值函数相结合的方法，以引导LLM的解码过程。 该方法通过树搜索探索多条可能的推理路径，并利用价值函数评估每条路径的潜在价值，从而提高推理的准确性和效率。  ￼
    
    因此，尽管R1模型和《Alphazero-like Tree-Search》方法都旨在提升LLM的推理能力，但它们采用了不同的训练策略和算法。 R1主要依赖于强化学习和自我博弈，而《Alphazero-like Tree-Search》则侧重于树搜索算法与价值函数的结合。
    
#### 问题6：R1为什么没有采用树搜索的方式？
    
  - 回复：根据论文内容，DeepSeek-R1并没有使用树搜索方法。相反，在论文第4.2节&quot;Unsuccessful Attempts&quot;中，他们明确提到尝试过使用Monte Carlo Tree Search (MCTS)但并未成功。
    
    具体来说,他们在尝试MCTS时遇到了以下主要挑战:
    
    1. 搜索空间问题:
        - 与国际象棋等游戏相比,token生成的搜索空间要大得多
        - 虽然通过设置每个节点的最大扩展限制来缓解,但这可能导致模型陷入局部最优
    2. 价值模型的局限:
        - 价值模型直接影响生成质量,因为它指导每一步搜索
        - 训练精细的价值模型本身就很困难
        - 这使得模型难以通过迭代来提升性能
    
    最终,他们得出结论:虽然MCTS配合预训练的价值模型可以在推理时提升性能,但通过自搜索来迭代提升模型性能仍然是一个重大挑战。
    
    因此,DeepSeek-R1最终采用了其他方法,主要依靠大规模强化学习来提升模型的推理能力,而不是使用树搜索策略。
    

### 搜索策略

两种主要的搜索策略：

1. 树搜索（Tree search）：同时生成多个答案作为全局搜索，可以探索更广泛的解决方案⁠⁠
2. 顺序修订（Sequential revisions）：基于前一次尝试来改进每次新的尝试作为局部搜索，可能提供更高的效率⁠⁠

这两种方法各有优势，树搜索提供了更广泛的探索空间，而顺序修订则可能在效率方面表现更好。

**树搜索（Tree search）**
    
![Figure 7.jpeg](https://arxiv.org/html/2412.14135v1/x6.png)

在树搜索算法中，定义树节点的粒度非常重要。常见的粒度包括：
    
- 令牌级别（Token Level）：最细粒度的粒度。

- 步骤级别（Step Level）：介于令牌级别和解决方案级别之间的粒度。

- 解决方案级别（Solution Level）：最粗粒度的粒度。

此方法同时生成多个答案，作为全局搜索，探索更广泛的解决方案。常见的树搜索算法包括Best-of-N（BoN）、束搜索（beam search）和蒙特卡罗树搜索（MCTS）。BoN生成多个独立的候选解，但缺乏动态调整模型概率分布的能力，可能导致高概率选项的过度采样。相比之下，其他树搜索策略在每一步动态调整，平衡探索和利用，使用启发式方法，并可采用前瞻搜索、回溯和剪枝来提高效率，减少采样成本。

#### Best-of-n Sampling（BoN）
        
  - **Best-of-n Sampling（BoN）核心概念**

    1. **定义与流程**
      - 一种基于生成-筛选的搜索方法，属于**“解级搜索”**：首先生成多个候选解（通常为n个），通过奖励模型（Reward Model）选择最优解，其余丢弃（Cobbe et al., 2021）。
      - **优势**：简单高效，尤其在具有真实标签（oracle reward）的场景下，随着样本数n增加，覆盖率和准确性显著提升（Brown et al., 2024）。
    2. **主要挑战**
      - **依赖奖励模型**：多数场景缺乏真实标签（oracle reward），需额外训练奖励模型，成为性能瓶颈。
      - **计算成本高**：生成n个候选解需多次调用大模型，推理开销随n线性增长，扩展性受限。

  - **BoN的改进方法**

    - 为降低计算成本并提升效率，研究者提出以下优化方向：

      1. **提前淘汰低质量候选（推测性拒绝）**
         - **核心思想**：利用**部分序列与完整序列评分的相关性**，在生成过程中动态淘汰低分候选。
         - **方法**：
             - Sun et al. (2024a) 提出**Speculative Rejection**，通过预训练模型对部分生成序列评分，提前丢弃低分候选，减少无效生成。
         - **优势**：在保持BoN性能的同时，显著降低计算量。
      2. **策略模型微调（模仿BoN分布）**
         - **目标**：通过微调使策略模型直接输出接近BoN筛选后的高质量分布，从而减少推理时所需的样本数（n=1即可）。
         - **方法**：
             - **偏好优化**：Gui et al. (2024) 结合BoN的“最佳解”与“最差解”数据，使用**偏好IPO损失（Preference-based IPO）**和SFT损失微调模型。
             - **强化学习**：Amini et al. (2024) 提出**vBoN**，用PPO算法最小化策略模型与BoN分布的差距，无需重复采样。
             - **分布对齐**：Sessa et al. (2024) 设计**BOND**，通过最小化Jeffreys散度（结合前向与反向KL散度）迭代蒸馏，实现单样本推理达到BoN效果。
      3. **奖励模型优化**
         - **关键问题**：奖励模型的泛化能力直接影响BoN效果，需解决稀疏奖励与偏差问题。
         - **潜在方向**：结合对比学习、自监督评估或动态奖励校准（虽原文未展开，但属于领域常见优化点）。

  - **总结**

    - BoN通过生成-筛选机制在复杂任务中表现优异，但其计算成本和奖励模型依赖性限制了实用性。改进方法聚焦于：

      1. **动态剪枝**（如推测性拒绝）减少生成开销；
      2. **模型蒸馏**（如vBoN、BOND）将BoN分布内化至策略模型；
      3. **奖励模型增强**以提升筛选可靠性。
      这些方法共同推动了BoN从“暴力采样”向高效、轻量化的方向发展，尤其在LLM推理优化中具有重要价值。


#### Beam Search（集束搜索）
        
- 传统Beam Search的特点
        
  - 基本流程：
      - 基于部分序列概率（如语言模型的token生成概率）扩展候选分支，保留Top-K（集束宽度）高概率路径，剪枝低概率路径。
      - 优点：相比贪婪搜索，通过维护多候选路径减少局部最优风险；计算效率较高。
      - 缺点：依赖局部概率，可能忽略全局最优解；缺乏对下游任务目标的直接对齐。

- 结合大语言模型的改进方向
        
  - 为提升Beam Search在复杂任务（如推理、生成）中的效果，研究者引入**额外指导信号**（如奖励模型、价值函数、回溯机制等），优化搜索策略：
    1. 基于奖励的剪枝与扩展
       - **TreeBoN**（Qiu et al., 2024）
           - **方法**：在**步骤级**（step-level）迭代扩展分支，利用DPO（Direct Preference Optimization）生成的**token级奖励**评估路径质量，动态剪枝低质量响应。
           - **效果**：类似传统Beam Search的高效性，但更关注路径的实际效用（而非单纯概率），减少无效计算。
       - **价值模型引导**（Yu et al., 2024a）
           - **方法**：训练价值模型（通过结果监督学习）直接对部分序列评分，替代传统token概率作为扩展依据。
           - **优势**：更直接对齐下游任务目标（如答案正确性），减少概率偏差导致的路径偏移。

    2. 随机性与探索优化
       - **改进随机Beam Search**（Xie et al., 2023）
           - **方法**：引入策略模型对候选路径**自评估**，替代纯概率采样，平衡利用（高概率路径）与探索（潜在高价值路径）。
           - **技术基础**：基于Kool et al. (2019)的随机Beam Search框架，增强搜索多样性。
    
    3. 回溯与动态调整
       - **过程奖励模型+回溯**（Ma et al., 2023）
           - **方法**：使用过程奖励模型（评估中间状态质量）引导贪婪搜索，若子节点奖励为负则触发回溯，重新选择父节点分支。
           - **适用场景**：解决局部负奖励导致的路径僵化问题（如逻辑矛盾），提升搜索容错性。
    
    4. 前瞻式搜索（Lookahead）
       - **k步前瞻搜索**（Snell et al., 2024）
           - **方法**：通过k步模拟展开（rollout）评估部分序列的长期价值，可视为MCTS的特例（无完整树构建）。
           - **优势**：结合短期概率与长期收益预测，避免短视决策。
    

- 改进效果与核心优势
        
    1. **任务对齐性**：通过奖励模型、价值函数替代纯概率，使搜索更贴合实际任务目标（如正确性、连贯性）。
    2. **平衡探索与利用**：引入随机性、回溯、前瞻机制，缓解传统方法过度依赖局部最优的问题。
    3. **计算效率**：动态剪枝（如TreeBoN）、过程奖励等策略在保证质量的同时减少冗余计算。

- 总结
        
    传统Beam Search依赖局部概率的局限性促使研究者将其与强化学习、价值模型、动态规划等技术结合，形成新一代**“增强型集束搜索”**。改进方向聚焦于：
    
    1. **信号增强**：用任务相关信号（奖励、价值）替代原始概率；
    2. **策略优化**：引入随机性、回溯、前瞻等机制提升搜索鲁棒性；
    3. **效率-效果平衡**：在扩展与剪枝间动态权衡，适配大模型的高开销场景。
    这些方法在代码生成、数学推理等复杂任务中展现出更优的全局搜索能力，成为传统搜索算法与深度学习融合的典范。

#### Monte Carlo Tree Search（MCTS）
        
- MCTS的基本原理
        
  - MCTS是一种前瞻性搜索算法，特别适合在大规模搜索空间中做出最优决策。它通过蒙特卡洛模拟来评估状态价值，随着模拟次数的增加，搜索树不断成长，状态价值的估计也变得越来越准确。一个完整的MCTS过程包含四个关键阶段：
        
    1. 选择阶段：从根节点开始，算法根据动作价值递归地选择分支。为了平衡探索和利用，MCTS使用PUCT算法为较少访问的动作增加额外的探索奖励。
    2. 扩展阶段：当达到一个非终止的叶节点时，算法会展开这个节点，创建新的子节点来表示可能的后续状态。
    3. 评估阶段：通过两种方式评估节点状态的价值：
       - Rollout策略：使用一个更简单的策略快速模拟到终止状态
       - 价值模型：直接预测当前状态的价值，无需额外采样
    4. 反向传播阶段：将评估得到的价值沿着搜索路径向上传播，更新路径上所有动作的价值估计和访问计数。
    
- 在大语言模型中的实现方式
        
  - MCTS在大语言模型中的实现主要有三种粒度层次：
        
    1. 词元级别的实现
       - 优点：可以精确控制生成过程
       - 缺点：搜索树深度大，且难以获得有意义的即时奖励信号
    2. 步骤级别的实现
       - 优点：简化了搜索过程，降低了树的宽度
       - 缺点：面临句子多样性带来的大动作空间挑战
       - 应用：数学问题解答、电子商务交互等
    3. 解决方案级别的实现
       - 特点：将完整解决方案作为节点状态
       - 优势：能够进行整体层面的优化和改进
       - 应用：如MCTSr通过自我改进达到了GPT-4级别的数学问题解答能力
    
- MCTS的创新应用
        
  - 近期研究展示了MCTS在大语言模型中的多种创新应用：
    
    - 在参考知识的指导下生成更准确的内容
    - 结合人类式推理动作提升推理能力
    - 使用配对偏好奖励模型评估答案改进效果
    - 设计一致性方法确保事实准确性
    
- 这些进展表明，MCTS不仅是一个理论上优雅的算法，更是一个在实践中能够显著提升大语言模型性能的强大工具。它通过系统性地平衡探索与利用，帮助模型在复杂的推理任务中实现更好的表现。
    
#### Others（其他树搜索）
        
- 在推理任务中，除了蒙特卡罗树搜索（MCTS）和束搜索（Beam Search）外，传统的图搜索算法，如深度优先搜索（DFS）、广度优先搜索（BFS）和A*搜索，也被广泛应用。
        
  - **Tree-of-Thoughts（ToT）框架**：
      - ToT将推理过程建模为一棵树，其中节点代表推理步骤，分支代表推理的延续。
      - 通过扩展和评估多个推理解决方案，ToT探索更广泛的解空间，引入了搜索、反思和回溯等机制，以重新考虑步骤并探索替代方案。
      - ToT在其搜索过程中采用了DFS和BFS。
  - **基于A*的最佳优先搜索**：
      - Koh等人（2024）提出了一种受A*启发的最佳优先搜索方法，使用多模态大语言模型（LLM）来评估节点，并利用启发式方法来选择或回溯。
  - **A*搜索算法**：
      - Lehnert等人（2024）使用A*算法收集执行轨迹，训练编码器-解码器模型来模仿这些轨迹。
    
- 这些方法通过结合传统图搜索算法和现代大语言模型，提升了推理过程的效率和准确性。
        
**序列修正（Sequential Revisions）**

1. 基本特征：
    
    在推理任务中，**序列修正（Sequential Revisions）**方法通过迭代地改进先前的答案来进行搜索。其关键特征是基于对先前答案的反思或环境变化，生成改进的答案。这要求模型具备自我反思和错误修正的基本能力，可通过策略初始化阶段的监督微调（SFT）或提示（Prompting）引入。
    
2. 主要实现方式：
   #### 基于内部指导
     - 序列修正方法可以直接依赖于内部指导，如自我评估。例如，Madaan等人（2023）提出了**SELF-REFINE**方法：首先使用大语言模型（LLM）生成初始答案，然后利用相同的LLM迭代地为其输出提供反馈，并根据自我反馈改进输出。当达到最大迭代次数或模型确定可以停止时，迭代过程结束。
     - Snell等人（2024）也使用具有修正能力的模型在推理过程中进行修正，证明随着修正次数的增加，答案的准确性得到提高。
   
   #### 基于外部反馈
     - 其他研究依赖于外部环境的观察或反馈。Yao等人（2023b）和Shinn等人（2023）基于模型在采取行动后，反思或改进下一步行动，利用外部反馈。
   
   #### 代码领域应用
     - Chen等人（2024c）和Gou等人（2024）使用基于生成代码执行的反馈，允许模型修改生成的代码或进行调试。

3. 有效性争议：
   #### 有效性争议 
     - 关于序列修正方法的有效性仍存在争议。例如，Huang等人（2024a）认为，大型模型在没有外部反馈的情况下，无法进行适当的自我修正。
   
   #### 目标分布差距（DG-gap）
     - 相反的观点认为，由于存在**目标分布差距（DG-gap）**，大型模型可能具有更强的能力来辨别和改进已生成的答案，从而进行进一步的修正。
   
   #### 实证研究
     - Chen等人（2024d）的实证研究发现，只有当判别器（指导）准确率≥90%时，序列修正方法相较于简单方法（如Best-of-N）才能实现性能提升。
   
#### 采用序列修正方法的研究工作

   - **SELF-REFINE (Madaan et al., 2023)**
    
       通过LLM生成初始答案，并利用相同的LLM迭代地为其输出提供反馈，改进答案。
    
       ![image 2.png]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/image 2.png&quot; | relative_url }}){: img }

   - **Snell et al. (2024)**
    
       使用具有修正能力的模型在推理过程中进行修正，证明随着修正次数的增加，答案的准确性得到提高。
    
       ![image 3.png]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/image 3.png&quot; | relative_url }}){: img }

    
   - **Yao et al. (2023b)**
    
       基于模型在采取行动后，反思或改进下一步行动，利用外部反馈。
    
       ![image 4.png]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/image 4.png&quot; | relative_url }}){: img }

    
   - **Shinn et al. (2023)**
    
       模型在采取行动后，反思或改进下一步行动，利用外部反馈。
    
       ![image 5.png]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/image 5.png&quot; | relative_url }}){: img }

    
   - **Chen et al. (2024c)**
    
       使用基于生成代码执行的反馈，允许模型修改生成的代码或进行调试。
    
       ![image 6.png]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/image 6.png&quot; | relative_url }}){: img }

#### 现有相关研究工作，以及搜索指引与策略
  - **Table 2：Survey of existing search methods, including their search guidance and search strategies**

    | Paper | Internal Guidance | External Guidance | Tree Search | Sequential Revisions |
    | --- | --- | --- | --- | --- |
    | Math Verifier (Cobbe et al., 2021) | ❌ | Env Feedback | Best-of-N | ❌ |
    | Self-consistency (Wang et al., 2023a) | Model Uncertainty | ❌ | Best-of-N | ❌ |
    | Speculative Rejection (Sun et al., 2024a) | ❌ | Env Feedback | Best-of-N | ❌ |
    | BoN (Gui et al., 2024), vBoN (Amini et al., 2024), BOND (Sessa et al., 2024) | ❌ | Env Feedback | Best-of-N† | ❌ |
    | TreeBoN (Qiu et al., 2024) | ❌ | Env Feedback | Beam Search | ❌ |
    | OVM (Yu et al., 2024a) | Value Function | Value Function | Beam Search | ❌ |
    | Xie et al. (2023) | Self-evaluation | ❌ | Beam Search | ❌ |
    | Ma et al. (2023) | ❌ | Env Feedback | Beam Search‡ | ❌ |
    | Snell et al. (2024) | ❌ | Env Feedback | Beam Search | ❌ |
    | TS-LLM (Wan et al., 2024) | ❌ | Env Feedback | MCTS | ❌ |
    | PPO-MCTS (Liu et al., 2024c) | Value Function | Value Function | MCTS | ❌ |
    | KCTS (Choi et al., 2023) | ❌ | Env Feedback | MCTS | ❌ |
    | Zhang et al. (2023b) | ❌ | Env Feedback | MCTS | ❌ |
    | RAP (Hao et al., 2023) | Self-evaluation | Heuristic Rules | MCTS | ❌ |
    | AlphaMath (Chen et al., 2024a) | Value Function | Value Function | MCTS, Beam Search | ❌ |
    | AgentQ (Putta et al., 2024) | Self-evaluation | ❌ | MCTS | ❌ |
    | LATS (Zhou et al., 2024) | Self-evaluation, Model Uncertainty | ❌ | MCTS | ❌ |
    | rStar (Qi et al., 2024) | Model Uncertainty  | ❌ | MCTS | ❌ |
    | MCTSr (Zhang et al., 2024c) | Self-evaluation | ❌ | MCTS | ✅ |
    | LLaMA-Berry (Zhang et al., 2024d) | ❌ | Env Feedback | MCTS | ❌ |
    | Mirror (Yan et al., 2024) | ❌ | Heuristic Rules | MCTS | ✅ |
    | ToT (Yao et al., 2023a) | ❌ | Env Feedback, Heuristic Rules | DFS, BFS | ❌ |
    | Koh et al. (2024) | ❌ | Env Feedback | A* | ❌ |
    | Beyond A* (Lehnert et al., 2024)‡ | ❌ | Heuristic Rules | A* | ❌ |
    | Self-refine (Madaan et al., 2023) | Self-evaluation | ❌ | ❌ | ✅ |
    | Snell et al. (2024) | Self-evaluation | ❌ | ❌ | ✅ |
    | ReACT (Yao et al., 2023b) | ❌ | Env Feedback | ❌ | ✅ |
    | Reflexion (Shinn et al., 2023) | ❌ | Env Feedback | ❌ | ✅ |
    | Self-debug (Chen et al., 2024c) | ❌ | Env Feedback | ❌ | ✅ |
    | Critic (Gou et al., 2024) | ❌ | Env Feedback | ❌ | ✅ |
    
综上所述，序列修正方法通过迭代改进模型输出，增强了推理能力，但其有效性仍需在不同任务和模型架构中进一步验证。

**树搜索与顺序修订的对比总结**
#### 树搜索（Tree Search）
- **特点**：
    - **并行性**：可同时生成多个候选解（如BoN、MCTS），通过并行计算加速搜索（如BoN的采样-筛选机制）。
    - **探索性**：候选解之间相对独立，通过算法设计（如MCTS的PUCT平衡探索与利用）扩大搜索覆盖范围。
    - **效率**：适合大规模搜索空间，但对计算资源需求较高（如维护搜索树结构）。
- **优势**：
    - 多样性强：广泛探索潜在解，避免局部最优。
    - 可扩展性：结合并行策略（如多GPU）显著提升效率。
- **局限性**：
    - 候选解间缺乏协同优化，可能重复低效路径。
    - 需依赖奖励模型或价值函数评估候选质量。

#### 顺序修订（Sequential Revisions）
- **特点**：
    - **迭代性**：基于已有解逐步改进（如多次微调、自我修正），依赖前序步骤的输出。
    - **聚焦优化**：通过局部调整逐步提升解的质量（如Snell et al., 2024的逐步优化策略）。
    - **计算成本**：随修订次数线性增长，难以并行化。
- **优势**：
    - 深度优化：在特定方向持续改进，可能生成更优解（如数学问题求解）。
    - 资源可控：单次迭代计算量较低，适合资源受限场景。
- **局限性**：
    - 易受初始解质量影响，可能陷入次优路径。
    - 探索能力有限，覆盖范围窄于树搜索。

#### 核心对比

| **维度** | **树搜索** | **顺序修订** |
| --- | --- | --- |
| **并行性** | 高（可同时生成多个解） | 低（依赖顺序迭代） |
| **探索能力** | 强（多样化候选解） | 弱（聚焦局部优化） |
| **计算成本** | 高（需维护搜索树/多候选评估） | 中等（随修订次数增加） |
| **适用场景** | 大规模搜索空间、需广泛探索的任务 | 需深度优化、初始解质量较高的任务 |

#### 典型应用
- **树搜索**：
  - BoN：生成多候选后筛选最优（如代码生成）。
  - MCTS：复杂推理任务（如围棋、数学证明）。
- **顺序修订**：
  - 自我修正（如MCTSr）：通过多次迭代改进答案（如数学解题）。
  - 内部指导优化（如Snell et al., 2024）：基于模型反馈逐步优化生成结果。

#### 选择策略
- **优先树搜索**：需快速覆盖多样解、任务搜索空间大、资源充足时。
- **优先顺序修订**：初始解质量较高、需精细化优化、计算资源有限时。
- **混合策略**：结合两者优势（如首轮树搜索生成候选，后续顺序修订优化）。

**结合方法**
    
在推理任务中，**树搜索（Tree Search）**和**序列修正（Sequential Revisions）**方法各有其优势。将两者结合使用，能够充分发挥各自的长处，提升推理性能。
    
#### 结合方法
   - **解决方案级搜索节点：** 在树搜索中，使用解决方案级的搜索节点可以视为树搜索与序列修正的结合。
   - **Snell等人（2024）的方法：** 首先随机采样N个候选解，然后对这些解应用序列修正，最后使用验证器从中选择最佳解。这种结合方法的性能超过了单独使用Best-of-N策略。
    
通过将树搜索与序列修正相结合，能够在广泛探索解空间的同时，利用序列修正对候选解进行精细化改进，从而实现更优的推理结果。
    

### o1的搜索猜测

猜测o1 在训练和推理阶段使用不同的搜索策略：

- 训练阶段：
  主要使用树搜索技术（如 BoN 等）和外部指导
  
  #### 选择原因
    - 能够并行采样大量候选解决方案
  
    - 高效提供大量优质训练数
  
    - 不需要实时交互
  
    - 可以使用外部环境（如代码执行、数学验证）来验证解决方案
  
    - 外部指导能更准确地引导搜索过程
  
- 推理阶段：
  主要使用顺序修订策略和内部指导
  
  #### 特点与原因
    - o1 的推理风格更接近顺序修订
  
    - 长推理过程中使用树搜索开销太大
  
    - 推理时难以依赖真实环境作为指导
  
    -  基于代理反馈的大量搜索可能导致过度优化问题

  #### 重要发现
    - 随着推理时的计算量增加，模型性能持续提升
  
    - 推理阶段主要依赖内部指导
  
    - 计算量主要体现在推理链的长度上

这种设计反映了在不同阶段对效率和性能的不同权衡考虑。

### 搜索算法的扩展性规律（Scaling Law of Search）

在推理任务中，**搜索的规模定律**（Scaling Law of Search）研究了在推理过程中增加计算资源对模型性能的影响。

**Best-of-N（BoN）方法：**
    
Brown等人（2024）研究了BoN，将其分为两个阶段：采样解和通过验证器选择最佳解。他们发现，增加样本数量可以按照幂律提高“覆盖率”（pass@1准确率）。小型模型在充分扩展的情况下，能够在MATH任务上实现接近100%的pass@1准确率。然而，他们注意到，最佳的n个解的准确率与pass@1之间存在差距，归因于验证器在识别正确解方面的局限性。
    
**树搜索和序列修正：**
    
Snell等人（2024）分析了树搜索和序列修正的规模，显示两种方法在增加计算资源时均表现良好。他们发现，对于给定的计算预算，增加模型大小对复杂任务更有效，而对简单任务，增加采样的token数量即可。
    
**奖励模型的影响：**
    
Lightman等人（2024）研究了奖励信号在扩展中的作用，观察到基于结果奖励的BoN搜索在增加样本数量时会出现平台效应，而基于过程奖励模型（PRM）的BoN搜索避免了这个问题。
    
**反向规模定律：**
    
尽管这些研究显示，增加搜索计算可以提高性能，但Gao等人（2023）发现了反向规模定律，即**扩大BoN搜索可能由于分布偏移而降低性能**。奖励模型在原始策略数据上训练，难以推广到新策略。Stroebl等人（2024）注意到类似问题，并建议其他搜索算法，如蒙特卡罗树搜索（MCTS），也可能面临反向规模挑战。
    

综上所述，尽管增加搜索计算通常能提高模型性能，但需要注意潜在的反向规模效应，特别是在奖励模型的泛化能力方面。

### 复现o1的挑战

**克服反向规模效应：**

- 减少推理时的搜索规模：尽管减少搜索规模可以缓解反向规模效应，但这可能限制搜索的深度和广度。

- 改进奖励模型的泛化能力：通过增加模型的规模和训练数据，提升其对未见状态的泛化能力，从而更好地处理新的策略。

**避免在简单任务中过度推理：**

- 引入长度惩罚的奖励塑形：对于简单问题，限制思维链的长度，避免不必要的复杂推理，从而节省计算资源并减少错误。

**平衡树搜索与序列修正：**

- 资源分配：在固定的计算预算下，如何在树搜索和序列修正之间进行有效的资源分配，以优化性能。

- 经验性规模定律：通过实证研究，指导资源的合理分配。

**提高搜索效率：**

- 工程优化：实施键值缓存共享（KV-cache sharing）等技术，提升内存读写速度，增强GPU利用率。

- 算法改进：采用键值缓存压缩（KV-cache compression）和推测采样（speculative sampling）等方法，提升搜索效率。

综上所述，复现o1模型需要在搜索规模、推理深度、资源分配和效率提升等方面进行综合考虑和优化。

#### 问题1：“oracle rewards”指的是什么？这个术语出自哪里？
    
- 回复：&quot;Oracle&quot; 这个术语最早来源于计算机科学中的理论计算和复杂性理论。在这个领域中，&quot;oracle&quot;指的是一个假设存在的&quot;全知&quot;机制，它能够立即且完美地回答某类问题。

- 这个概念后来被引入到机器学习领域，特别是在强化学习中。在强化学习环境中，&quot;oracle reward&quot;指的是一个理想化的、完全准确的奖励信号。比如在游戏环境中，我们可以准确知道一个动作是否导致了胜利或失败，这就是一个典型的oracle reward。

- 相比之下，在许多实际问题中，我们很难获得这样完美的反馈。举个例子：

  - 在围棋游戏中，胜负是一个oracle reward，因为它是完全明确的
  - 但在评估一篇文章的质量时，就没有这样完美的评判标准

- &quot;Oracle rewards&quot;这个术语的使用反映了强化学习中的一个重要概念：理想化的完美反馈与现实中不完美反馈之间的对比。这种对比帮助我们理解为什么在实际应用中常常需要设计和训练专门的reward models来近似oracle rewards。

- 这个概念在强化学习文献中被广泛使用，尽管很难追溯到具体哪篇论文首次使用这个术语。它已经成为了领域内的标准术语，用来描述那些完全准确且立即可得的理想化反馈信号。
    
#### 问题2：在《Bonbon alignment for large language models and the sweetness of best-of-n sampling中》中IPO loss指的是什么？
    
- 回复：IPO loss是在机器学习中用于从预定义的最优策略分布（比如从Best-of-N采样得到的分布）中学习策略的一种损失函数。它的核心思想是将原始的策略优化问题转化为其对偶形式。

- IPO loss的构成和目的：

  1. 基本动机：
      - Best-of-N采样能产生高质量的结果，但在推理时计算成本很高
      - 我们希望训练一个模型直接生成类似Best-of-N采样质量的输出
      - IPO loss被设计用来让模型学习模仿Best-of-N的输出分布
     
  2. 数学形式：IPO loss可以写作：
      ```
      L_IPO(π_θ; π_ref) = -E[log σ(β log(π_θ(y_w|x)/π_ref(y_w|x)) - β log(π_θ(y_l|x)/π_ref(y_l|x)))]
      ```
      其中：
    
      - π_θ 是要训练的策略
      - π_ref 是参考策略
      - y_w 是较好的样本
      - y_l 是较差的样本
      - β 是温度参数
      - σ 是sigmoid函数
     
  3. 工作原理：
      - IPO loss通过比较策略π_θ和参考策略π_ref在好样本和差样本上的概率比来工作
      - 它鼓励模型在好样本上增加概率，在差样本上降低概率
      - 这样逐渐使模型的输出分布接近Best-of-N采样的分布
     
  4. 优势：
      - 不需要在推理时进行多次采样
      - 保持了Best-of-N采样的性能优势
      - 计算效率更高
      - 训练稳定性好

- 理解IPO loss对于理解现代语言模型的训练很重要，因为它提供了一种有效的方法来提升模型的单次采样性能，而不需要在推理时付出额外的计算成本。
    
#### 问题3：什么是PUCT？
    
- 回复：PUCT（Predictor Upper Confidence bound for Trees）是蒙特卡洛树搜索（MCTS）中的一种改进算法，主要用于平衡搜索过程中的**探索与利用**。它通过引入先验概率（通常由神经网络提供）优化了传统UCT（Upper Confidence Bound applied to Trees）算法的探索策略，显著提升了搜索效率，尤其在复杂博弈场景（如围棋）中表现突出。

-  核心公式与作用
    - 在MCTS的**选择（Selection）阶段**，PUCT通过以下公式计算每个动作的评分，以选择最优分支：
    
      - $U(s,a) = c_{\text{puct}} \cdot P(s,a) \cdot \frac{\sqrt{\sum_b N(s,b)}}{1 + N(s,a)}$
    
      - 其中：
        - $c_{\text{puct}}$：探索系数，控制探索强度，值越大越鼓励探索未知分支。
        - $P(s,a)$：先验概率，由神经网络预测当前状态下动作\( a \)的初始概率，指导搜索方向。
        - $N(s,a)$：动作\( a \)的访问次数，分母项避免重复访问同一动作。
        - $\sum_b N(s,b)$：父节点下所有子动作的访问次数之和，分子项反映整体探索程度。
    
  - 最终，动作的选择基于** $Q(s,a) + U(s,a)$ **的最大值，其中：
    
    - $Q(s,a)$：平均行动价值，反映动作的历史收益；
    - $U(s,a)$：探索项，通过先验概率和访问次数动态调整探索权重。

-  PUCT与传统UCT的区别

  - 先验概率的引入：
    
    - 传统UCT仅依赖历史统计值（如胜率）选择动作，而PUCT结合了神经网络的先验知识 $P(s,a)$ ，使搜索更偏向于策略网络认为有潜力的动作，减少无效探索。
    
  - 探索效率的提升：
    
    - 在AlphaGo Zero中，PUCT通过 $c_{\text{puct}}$ 动态调整探索强度，初始阶段高探索系数鼓励多样化尝试，随着模拟次数增加逐渐收敛到高价值动作，避免陷入局部最优。
    

- 实际应用与效果

  - 在**AlphaGo Zero**中，PUCT是其MCTS算法的核心组件。通过神经网络的策略输出（先验概率）与蒙特卡洛模拟的结合，PUCT实现了：

    - **快速收敛**：在1600次模拟内即可生成高质量棋谱；
    - **平衡性**：避免过度依赖初始策略（如纯贪婪策略）或盲目随机探索；
    - **适应性**：通过调整 $c_{\text{puct}}$ ，可适应不同任务复杂度（例如围棋中的温度参数 $\tau$ 控制最终落子的随机性）。

- 总结

  - PUCT通过结合先验知识与统计信息，在复杂决策问题中实现了高效的探索与利用平衡。其设计思想不仅适用于棋类博弈，也被扩展至自然语言推理、机器人路径规划等领域，成为强化学习与树搜索结合的重要范式。

#### 问题4：其中，the rollout policy指的是类似于于MC采样的方式吗？value model指的是bellman equation吗？
    
  - 这里的两个概念虽然都用于状态价值的评估，但它们的含义和实现方式有所不同：

    - **Rollout Policy**
      - **类似于MC采样**：是的，rollout policy 本质上就是一种基于蒙特卡洛（MC）采样的策略。在 MCTS 的 evaluation 阶段，当搜索到一个叶节点时，可以通过 rollouts（也称为模拟或采样）来评估该状态的潜在回报。具体来说，从叶节点开始，根据 rollout policy 随机或按照某种简单策略继续“走”下去（即模拟后续状态转换），直到到达终止状态，然后将这次模拟的累计回报作为当前叶节点的价值估计。这种方式利用了随机采样来近似整个搜索树未探索部分的回报，从而获得一个期望奖励的估计。
        
    - **Value Model**
      - **不完全等同于Bellman Equation**：value model 是一个用来直接预测某个状态价值的函数近似器，可以是神经网络或其他模型。它的作用是避免在每次评估时都进行大量的 rollouts，从而提高效率。
      - **与Bellman Equation的关系**：Bellman 方程为状态价值提供了一种递归定义，即某状态的价值等于从该状态出发所能获得的即时奖励加上后续状态价值的折扣和。虽然在强化学习中，value model 的训练目标往往会使用基于 Bellman 方程的目标（例如，通过 Temporal Difference 学习最小化预测值与实际回报之间的差距），但这并不意味着 value model 就是 Bellman 方程本身。它只是利用了 Bellman 方程的思想来构造训练目标，以便让模型能更好地预测状态的长期回报。
    
    - 总结来说：
      - **Rollout Policy**：通过类似 MC 采样的方法模拟后续状态，用于从当前状态获得一个蒙特卡洛估计的回报。
      - **Value Model**：是一个直接预测状态价值的模型，虽然其训练过程中可能借鉴了 Bellman 方程的思想，但本身是一个函数近似器，而不是 Bellman 方程的直接体现。
    
#### 问题5：“And during inference, it is difficult to rely on real-world environments for guidance, and (Gao et al.; Stroebl et al.) point out that performing extensive searches based on proxy feedback, like reward models, can lead to overoptimization problem. “中涉及的论文《Inference scaling Flaws: The limits of llm resampling with imperfect verifiers》是怎样说明overoptimization problem？
    
  - 回复：论文指出，当使用不完美的验证器（如单元测试）时，依赖于多次采样来提高模型性能的策略存在局限性。 即使计算资源无限，过度依赖代理反馈进行广泛搜索，可能导致模型在验证器的覆盖范围内表现良好，但在实际应用中却出现较高的假阳性率，即错误的解决方案通过了验证器的测试。 这种过度优化可能导致模型在实际任务中表现不佳，无法有效地泛化到新的或未见过的情况。
    
    因此，论文强调了在推理阶段，使用不完美验证器时，过度依赖代理反馈进行广泛搜索可能导致过度优化，从而影响模型的实际性能和泛化能力。
    
#### 问题6：关于“they noted a gap between best-of-n accuracy and pass@1, attributing it to the verifier’s limitations in identifying correct solutions.”的gap是具体什么问题？
    
- 回复：作者提到在使用Best-of-N（BoN）策略时，存在“best-of-n准确率”和“pass@1准确率”之间的差距。他们将这一差距归因于验证器在识别正确解决方案方面的局限性。

- 具体而言，BoN策略通过生成多个候选答案，并由验证器选择最佳答案来提高模型性能。然而，验证器可能无法完美地识别所有正确的解决方案，导致在BoN策略下，尽管生成了多个候选答案，但验证器未能选出正确答案，从而造成“best-of-n准确率”高于“pass@1准确率”的现象。

- 为了解决这一问题，研究者们提出了“推理感知微调”（Inference-Aware Fine-Tuning）的方法。该方法在训练过程中直接优化BoN策略，以提高验证器的准确性，从而缩小“best-of-n准确率”和“pass@1准确率”之间的差距。通过这种方式，模型能够在推理阶段更有效地生成多样化且高质量的输出。

#### 问题7： Lightman et al. (2024) examined reward signals in scaling and observed that outcome-reward-based best-of-n search plateaued as samples increased, while PRM-based best-of-n search avoided this issue.这个问题是什么意思？
    
- 回复：在《Scaling of Search and Learning: A Roadmap to Reproduce o1 from Reinforcement Learning Perspective》一文中，Lightman等人（2024）研究了奖励信号在推理过程中的作用。他们发现，基于结果奖励的Best-of-N（BoN）搜索在增加样本数量时性能趋于平稳，即出现了“平台效应”。相反，基于过程奖励模型（PRM）的BoN搜索能够避免这一问题，持续提升性能。

- 具体而言，结果奖励模型（ORM）仅在推理过程的最终步骤提供反馈，这可能导致模型在中间步骤的学习不足。而过程奖励模型（PRM）则在每个步骤提供反馈，帮助模型更好地学习和优化推理过程。因此，PRM能够有效避免ORM在推理过程中可能出现的性能瓶颈。

- 此外，Lightman等人还提出了“推理感知微调”（Inference-Aware Fine-Tuning）的方法，通过在训练过程中直接优化BoN策略，以提高验证器的准确性，从而缩小“best-of-n准确率”和“pass@1准确率”之间的差距。这种方法使模型能够在推理阶段更有效地生成多样化且高质量的输出。


## **6 学习 (Learning)**

![image.png](https://arxiv.org/html/2412.14135v1/x7.png)

### 总结要点

#### 策略初始化（Policy Initialization）的作用

  - **人类专家数据**：通过监督学习（如行为克隆）从有限的人类标注数据中初始化策略，捕捉人类行为模式与知识。

  - **局限性**：数据量少、成本高，且受限于人类能力，无法探索超人类（superhuman）策略。

#### 强化学习（Reinforcement Learning, RL）的必要性

  - **无限数据来源**：RL通过与环境的交互生成训练数据（如自对弈、搜索轨迹），突破人类数据的规模限制。

  - **超越人类潜力**：通过试错（trial and error）发现人类未知的策略（如AlphaGo的“第37步”），实现超人类性能。

#### RL与搜索算法的结合

  - **数据生成方式**：在训练中，RL通过搜索算法（如beam search、蒙特卡洛树搜索MCTS）生成轨迹（trajectories），而非仅依赖随机采样。

  - **高质量数据优势**：搜索方法能主动探索高价值状态或动作（如优先选择预期奖励高的路径），提供比随机采样更优的训练样本。

  - **迭代优化循环**：
    - **搜索阶段**：用当前策略生成候选解（$D_{search}$，包含所有搜索路径的状态-动作对）。
    - **学习阶段**：用$D_{search}$训练策略，改进后的策略用于下一轮搜索。
    - **典型案例**：AlphaGo Zero通过MCTS生成数据训练策略，策略改进后反哺更高效的搜索。

#### 训练时搜索 vs. 测试时搜索

  - **测试时搜索**：仅输出最优解（$D_{expert}$，即奖励或置信度最高的候选解）。

  - **训练时搜索**：利用所有候选解（$D_{search}$，包含次优路径），为策略学习提供更丰富的探索经验。

  - **数据关系**：$D_{expert} \subseteq D_{search}$，即最优解是搜索生成数据的子集。

### 关键点解释

#### 策略初始化与强化学习的互补性

  - **策略初始化**：提供安全的起点（模仿人类行为），避免RL从零开始探索的高风险与低效。

  - **强化学习**：突破人类数据局限，通过环境交互与搜索生成新策略，实现性能跃升。

#### 数据生成机制的差异

  - **人类数据**：静态、有限，反映已知的人类策略。

  - **RL数据**：动态、无限，通过搜索和试错生成，包含潜在更优的未知策略。

#### 搜索在RL中的核心作用

  - **探索高效性**：搜索算法（如MCTS、beam search）定向探索高价值区域，减少盲目随机采样。

  - **数据质量提升**：搜索生成的数据（$D_{search}$）包含更优候选解，加速策略优化。

#### 迭代优化循环的意义

  - **搜索与学习的正反馈**：

    - 改进后的策略生成更高质量的搜索数据，进一步提升策略性能。
    
    - 如AlphaGo Zero通过策略网络指导MCTS，MCTS生成的数据又训练更优策略网络。

#### 训练时利用全部候选解的价值

  - **多样性学习**：$D_{search}$包含次优路径，帮助策略理解不同状态下的动作选择，增强鲁棒性。

  - **避免局部最优**：通过探索非最优路径，防止策略过早收敛到次优解。

### 实例说明

  - **AlphaGo的“第37步”**：通过RL发现人类棋手从未使用过的策略，最终击败世界冠军。

  - **AlphaGo Zero**：完全基于RL与MCTS，无需人类数据，通过自对弈迭代超越所有人类知识。

### 总结

  - 强化学习的核心价值在于其**数据生成能力**与**策略探索潜力**：

    - **突破人类数据限制**：通过环境交互与搜索生成无限训练数据。
    
    - **实现超人类性能**：发现人类未知策略（如游戏、复杂决策任务）。
    
    - **搜索与学习的协同**：定向生成高质量数据，驱动策略迭代优化。
    
    这一框架在AlphaGo、自动驾驶、对话系统等领域已验证其有效性，成为AI超越人类能力的关键技术路径。

### 学习方法

本节探讨了利用搜索数据（ $D_{\text{search}}$ ）改进策略的两种主要方法：**策略梯度方法**和**行为克隆**，并对比了不同算法的优缺点及适用场景。

- **策略梯度方法**

  #### REINFORCE
    - **原理**：通过蒙特卡洛采样估计回报 $G_t$ ，梯度更新如式
            
      - $$\nabla_\theta J(\theta)=\frac{1}{\left|D_{\text {search }}\right|} \sum_{\left(s_t, a_t\right) \in D_{\text {search }}} \left [G_t \nabla_\theta \log \pi_\theta\left(a_t \mid s_t\right)\right ]$$
            
    - **优点**：无需价值模型，实现简单。
  
    - **缺点**：梯度方差高，需完整轨迹采样，计算成本大。
  
  #### Actor-Critic

    - **改进**：用优势函数 $A(s_t, a_t)$ 替代 $G_t$，减少方差。
  
    - **依赖**：需额外估计价值函数 $V(s)$，引入价值模型。

  #### PPO（近端策略优化）

    - **核心**：通过KL散度约束或剪切机制限制策略更新幅度，避免策略崩溃。
  
    - **优势**：支持多轮次训练（Replay Buffer），数据利用率高。
  
    - **代价**：需同时维护策略模型、参考策略、奖励模型、价值模型，内存开销大。
  
    - **应用**：广泛用于RLHF（如LLama2、ChatGPT）。
        
  #### DPO（直接策略优化）

    - **创新**：将奖励函数重参数化为最优策略 $\pi^*$，直接优化偏好数据（式5）
        
        $$\mathcal{L}_{\mathrm{DPO}}\left(\pi_\theta ; \pi_{\mathrm{ref}}\right)=-\mathbb{E}_{\left(x, y_w, y_l\right) \sim \mathcal{D}_{\text {search }}}\left[\log \sigma\left(\beta \log \frac{\pi_\theta\left(y_w \mid x\right)}{\pi_{\mathrm{ref}}\left(y_w \mid x\right)}-\beta \log \frac{\pi_\theta\left(y_l \mid x\right)}{\pi_{\mathrm{ref}}\left(y_l \mid x\right)}\right)\right]$$
        
    - **优点**：无需显式奖励/价值模型，内存效率优于PPO。
  
    - **局限**：依赖偏好数据构造（如MCTS-DPO利用搜索树中的状态-动作对生成偏好）。

- **行为克隆（Behavior Cloning）**

    - **原理**：以搜索产生的高奖励样本( $D_{\text{expert}}$ ）为专家数据，最小化交叉熵损失（式7）
        
        $$\min_\theta-\frac{1}{\left|D{\text {expert }}\right|} \sum_{(s, a) \in D_{\text {expert}}}\left[\log \pi_\theta(a\mid s)\right]$$
        
    - **特点**：
  
        - **内存高效**：无需额外模型，仅需监督学习。
      
        - **数据局限**：仅学习正样本，忽略负样本信号。
    
    - **专家迭代（Expert Iteration）**：
  
        - 通过迭代搜索生成高质量数据并克隆（如AlphaGo Zero、STaR）。
      
        - 实际案例：LLama2通过拒绝采样筛选样本进行微调，性能媲美PPO。
    
- **方法对比（表）**

    | 方法 | 梯度方差 | 内存成本（模型数） | 数据利用 |
    | --- | --- | --- | --- |
    | **REINFORCE** | 高 | 低（无额外模型） | 低（需完整轨迹采样） |
    | **PPO** | 低 | 高（策略、参考、奖励、价值） | 高（支持Replay Buffer） |
    | **DPO** | 低 | 中（需参考策略） | 高（利用偏好对） |
    | **行为克隆** | 低 | 最低（仅策略模型） | 低（仅正样本） |

- **对o1学习的推测**

  #### 混合策略

    - **预热阶段**：使用行为克隆快速提升策略质量（高内存效率）。

    - **优化阶段**：切换至PPO/DPO，利用负样本进一步优化（高数据利用率）。

    - **实例**：LLama3结合拒绝采样（行为克隆）与DPO偏好学习。
 
  #### 实验结论

    - 行为克隆在某些任务（如数学推理）中表现优于PPO（Havrilla et al., 2024）。
  
    - PPO实现复杂，需注意细节（如策略与价值网络分离、奖励归一化）。
       
- **关键结论**

    - **数据利用**：PPO/DPO &gt; 行为克隆（因利用负样本信号）。
  
    - **内存效率**：行为克隆 &gt; DPO &gt; PPO。
  
    - **实际应用**：根据任务需求选择方法，混合策略（如预热+优化）可能是最优解。

### 强化学习的扩展定律

- **核心发现**

  #### OpenAI的观察

    - **对数线性关系**：在LLM的强化学习（RL）中，推理性能与训练计算量（train-time compute）之间存在对数线性扩展定律（log-linear scaling law）。
  
    - **局限性**：目前仅针对o1的推理性能验证，未涉及更广泛的RL任务或模型参数、数据规模的系统性分析（OpenAI, 2024a）。
  
  #### 传统RL任务的幂律扩展

    - **Hilton等人（2023）研究**：在Dota 2等传统RL任务中，性能提升与模型参数规模、环境交互次数呈幂律关系（power law）。

    - **资源分配公式**：固定计算预算下，可推导最优模型参数规模与环境交互次数的平衡关系。

  #### 模仿学习的扩展定律

    - **Tuyls等人（2024）研究**：在Atari等任务的模仿学习中，模型规模、数据量、计算预算与损失函数间存在幂律关系。

    - **数据来源限制**：数据依赖专家标注（非环境交互生成），无法反映自主探索的RL特性。

- **LLM强化学习的实验探索**

  #### 小规模验证

    - **迭代次数与性能**：Zelikman（2022）、Xie（2024）等研究表明，增加RL迭代次数可提升LLM性能（如数学推理、代码生成）。
  
    - **局限性**：实验规模有限，未建立可预测大规模性能的扩展定律。
      
  #### 关键缺口

    - **环境交互数据的扩展研究**：当前LLM的RL研究多基于静态数据（如偏好数据、专家轨迹），缺乏对动态环境交互下扩展规律的探索。

    - **多变量关系建模**：模型参数、数据规模、计算预算、搜索策略等变量间的交互效应尚未系统量化。

- **未来研究方向**

  #### 建立LLM-RL的扩展定律

    - 量化模型参数（N）、训练数据量（D）、计算量（C）与任务性能（L）的关系，例如探索  $L = k \cdot N^{-\alpha} D^{-\beta} C^{-\gamma}$ 形式的定律。

    - 区分不同RL阶段（如预训练、微调、在线学习）的扩展规律差异。

  #### 动态环境交互的影响

    - 研究环境反馈频率、奖励稀疏性对扩展曲线的影响，对比静态数据（模仿学习）与动态交互（在线RL）的扩展效率差异。

  #### 搜索与学习的协同扩展

    - 分析搜索计算量（如MCTS模拟次数）与模型参数规模的协同效应，优化训练-推理的全局计算分配。

- **总结**

    - **现状**：传统RL和模仿学习已观测到幂律扩展，但LLM的RL扩展定律研究仍处于早期阶段，缺乏系统性结论。
  
    - **挑战**：环境交互的动态性、多变量耦合效应、大规模实验成本。
  
    - **意义**：明确扩展定律可指导资源分配（如模型参数 vs. 数据量）、优化训练流程（如迭代次数设计），为复现o1级模型提供理论依据。

### 复现o1模型的学习挑战总结

#### 如何提高训练效率?

  - **瓶颈分析**

    - **搜索耗时**：训练时搜索（如MCTS）生成高质量数据的时间远超过模型训练本身（例如MCTS-DPO在A800 GPU上需一周训练时间）。
    
    - **加速策略**：
    
        - **算法优化**：改进搜索策略（如剪枝、并行化）。
      
        - **数据复用**：不仅使用在线搜索生成的数据，还包括来自之前搜索迭代的数据。虽然重复使用之前的数据可能会引入与离策略(off-policy)学习相关的问题，但它增加了数据利用率，从而减少了搜索规模。
      
  - **离线学习的影响**

    - **分布偏移**：搜索数据来自更优策略( $π_{\text{search}}$ )，与当前策略 ($π_θ$）分布不一致，导致梯度估计偏差。
    
    - **缓解方案**：（同问题3）
    
      - **限制搜索规模**：减少搜索深度以缩小策略差距。
      
      - **在线搜索**：直接基于当前策略生成数据（牺牲数据质量）。

#### 如何学习一个强大的问题生成器？

  - **问题生成与策略优化的脱节**
    - **现状**：现有方法（如Wizzrd-LM）依赖外部LLM生成更复杂问题，但问题难度与当前策略能力不匹配。
    - **风险**：生成的问题可能过难（无法解决）或过易（无训练价值）。
  - **课程学习（Curriculum Learning）的潜力**
    - **动态调整**：根据策略能力逐步提升问题难度（如自动课程学习）。
    - **挑战**：需设计问题难度评估指标，并与策略优化过程协同。

#### 如何缓解离线学习中的分布偏移？

  - **离线学习方法的局限**

    - **策略差异**：搜索数据策略 $(π_{\text{search}}）$与当前策略 ($π_θ$)差异导致梯度估计偏差。
    
    - **传统方法**：**重要性采样**和**KL散度约束**（TRPO/PPO）需已知 $π_{\text{search}}$ 的概率分布，但实际中不可得。

  - **混合训练策略**

    - **行为克隆预热**：先通过行为克隆缩小 $π_θ$ 与 $π_{\text{search}}$ 的分布差距（式7）。
    
    - **策略梯度优化**：预热后结合PPO/DPO利用负样本细化策略。
    
    - **迭代优化**：每轮迭代中交替进行行为克隆与策略梯度（不同于分阶段策略）。

#### 关键解决方案对比

| **挑战** | **核心问题** | **解决方案** | **典型案例** |
| --- | --- | --- | --- |
| **训练效率** | 搜索耗时导致训练周期长 | 数据复用+搜索算法优化 | MCTS-DPO的并行化改进 |
| **问题生成** | 问题难度与策略能力不匹配 | 课程学习+动态难度调整 | Wizzrd-LM的复杂问题生成 |
| **分布偏移** | 离线学习中的策略差异 | 行为克隆预热+混合策略梯度 | AlphaGo Zero的专家迭代流程 |

#### 未来方向
  - **自适应课程学习**：开发问题难度与策略能力联动的自动化生成框架。
  
  - **高效离线学习算法**：设计无需依赖 $π_{\text{search}}$ 分布的重要性采样方法。
  
  - **计算-数据协同优化**：平衡搜索计算量、数据复用率与策略稳定性。
    

#### 详细内容展开：通过行为克隆（BC）将Off-policy转为On-policy的方法

  - **核心目标**

    - 在Off-policy强化学习中，搜索策略生成的优质数据（ $D_{search}$ ）与当前策略（ $\pi_\theta$ ）的分布差异会导致训练不稳定。**该方法通过行为克隆（BC）对齐策略分布，将离线数据转化为近似On-policy数据**，从而缓解分布偏移问题。

  - **方法流程**

    - 行为克隆（BC）阶段

      - **目标**：缩小当前策略（ $\pi_\theta$ ）与搜索策略（ $\pi_{search}$ ）的分布差异。
      
      - **实现**：
          - 使用搜索数据 $D_{search}$ 对 $\pi_\theta$ 进行监督学习（最大似然估计）。
          - 损失函数：
          $$L_{BC} = -\mathbb{E}{(x,y) \sim D{search}} \left[ \log \pi_\theta(y|x) \right]$$
          - 效果： $\pi_\theta$ 的输出分布接近 $\pi_{search}$ ，使 $D_{search}$ 成为近似On-policy数据。

  - **策略梯度训练阶段**

    - **目标**：基于对齐后的分布，用策略梯度方法（如PPO）优化策略。
    - **实现**：
      - 在每一轮迭代中，先执行BC对齐，再应用PPO更新策略。
      - 数据来源：仍使用 $D_{search}$ ，但因其分布已接近当前策略，重要性采样更稳定。

  - **与原有方法（6.1.3节）的对比**

    | **方法** | **流程** | **优点** | **缺点** |
    | --- | --- | --- | --- |
    | **原有方法（6.1.3）** | 1. **早期迭代仅用BC**对齐策略。&lt;br&gt;2. **后续迭代仅用PPO**优化。 | 简单高效，计算成本低。 | BC阶段后策略可能逐渐偏离，导致后续PPO不稳定。 |
    | **新方法** | **每个迭代均交替执行BC和PPO**：&lt;br&gt;1. 用BC对齐分布。&lt;br&gt;2. 用PPO优化策略。 | 持续对齐分布，缓解偏移，训练更稳定。 | 计算成本较高，需平衡BC与PPO的权重。 |
    | **补充方案** | 1. **预热阶段用BC**。&lt;br&gt;2. **后续迭代联合优化BC+PPO**（混合损失）。 | 灵活平衡模仿与强化学习，稳定性与性能兼顾。 | 需设计动态损失权重，调参复杂度高。 |

  - **关键细节**

    - **混合损失函数**

      - 在每次迭代中，总损失为BC损失与PPO损失的加权和：
      $$L_{\text{total}} = L_{\text{PPO}} + \lambda \cdot L_{\text{BC}}$$
      - $\lambda$ 控制BC的影响，可固定或动态调整（如随训练步衰减）。

    - **动态对齐机制**

      - **预热阶段**：仅用BC快速对齐初始分布，避免冷启动问题。
      - **主训练阶段**：逐步增加PPO权重，鼓励策略在稳定分布下优化奖励。

    - **数据生成策略**

      - **搜索与采样的结合**：在生成 $D_{search}$ 时，基于当前策略 $\pi_\theta$ 的采样结果进行有限搜索（如beam search），确保数据分布与策略更新同步。

  - **实际案例（如InstructGPT改进）**

    1. **数据生成**：基于参考模型（ $\pi_{ref}$ ）的beam search生成高质量回答 $D_{search}$ 。
    2. **预热阶段**：仅用BC训练 $\pi_\theta$ ，使其接近 $\pi_{ref}$ 的分布。
    3. **主训练阶段**：每个迭代中：
        - 用当前策略生成部分数据，与 $D_{search}$ 混合。
        - 联合优化 $L_{\text{PPO}}$（奖励最大化）和 $L_{\text{BC}}$（分布对齐）。

  - **优势与挑战**

    - **优势**

      - **持续对齐分布**：每个迭代的BC步骤确保策略始终接近搜索策略，缓解分布偏移。
      - **数据高效性**：充分利用搜索生成的高质量数据，减少PPO的随机探索成本。
      - **灵活性**：通过调整 $\lambda$ ，平衡模仿学习与强化学习的强度。

    - **挑战**

      - **计算成本**：每个迭代均需BC微调，增加训练时间。
      - **超参敏感性**：需精细调节 $\lambda$ 和KL惩罚系数 $\beta$ 。
      - **BC数据质量依赖**：若 $D_{search}$ 存在偏差（如搜索策略过于贪婪），可能限制策略潜力。

  - **与理论Off-policy方法的对比**

    | **方法** | 是否需要 $\pi_{search}$ 概率 | 核心思想 | 适用场景 |
    | --- | --- | --- | --- |
    | **重要性采样（TRPO/PPO）** | 是 | 显式修正分布差异 | 数据分布已知且稳定的场景 |
    | **KL散度约束** | 否 | 惩罚策略与参考模型的偏离 | 需保持生成安全性与多样性的任务 |
    | **BC + PPO混合训练** | 否 | 将Off-policy数据转为近似On-policy | 搜索策略概率未知的大规模模型对齐 |

  - **总结**

    - 通过在每个迭代中结合行为克隆（BC）和策略梯度训练（如PPO），将离线数据（ $D_{search}$ ）转化为近似On-policy数据，是一种有效缓解分布偏移的实用方法。其核心优势在于：

      1. **稳定性**：通过持续对齐分布，避免策略更新失控。
      2. **数据利用**：最大化利用搜索生成的高质量数据。
      3. **灵活性**：可扩展为预热+混合训练模式，适应不同任务需求。

  - 尽管存在计算成本和调参复杂度的挑战，该方法已被证明在大规模语言模型对齐（如ChatGPT、Claude）中具有显著效果，成为RLHF流程中的关键组成部分。

#### 问题1：如何理解“GRPO (Shao et al.) alleviate this issue by estimating value function with Monte Carlo estimation instead of function approximation. ”说的基于MC估计替代价值函数？
    
- 回复：确实，GRPO作为PPO的变体，旨在通过去除Critic模型来降低显存占用，使得强化学习在人类反馈（RLHF）中的应用更易扩展。

- 具体方法：
  - 在GRPO中，**Actor**网络负责生成动作的概率分布，决定智能体在给定状态下采取的动作。由于缺少Critic模型，GRPO通过**组内相对奖励**来估计优势函数，从而优化策略。

- 优势：
  - 这种方法避免了对复杂奖励模型的依赖，显著提高了计算效率，降低了内存占用，更适合大规模语言模型的微调。

- 区分：
  - 需要注意的是，GRPO仍然是一种**在策略**（on-policy）算法，即智能体在训练过程中使用当前策略与环境交互收集的数据来更新策略。 这与**离策略**（off-policy）方法不同，后者可以使用与当前策略不同的行为策略生成的数据进行训练。

- 因此，在GRPO中，**Actor**网络使用相同的策略与环境交互，但由于缺少Critic模型，采用了不同的策略优化方法。
![image 8]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/image 8.png&quot; | relative_url }}){: img }
    
#### 问题2：“Although Expert iteration uses behavior cloning which can be seen as the supervised learning, it is different from policy initialization introduced in Section [3], where the expert data comes from human expert or a stronger model. The expert data of expert initialization comes from the interaction with the environment, i.e., search.” 其中，“专家迭代的专家数据来源于搜索过程（模型自身的探索）”，这种“搜索” 指的是将MCTS的搜索算法集成到模型生成过程的采用策略中（比如替代或者结合温度采样、贪婪采样等方式），是这个意思吗？
    
- 回复：是的，这种“搜索”指的正是将像蒙特卡洛树搜索（MCTS）这样的搜索算法集成到模型生成过程中，作为一种替代或结合传统采样策略（如温度采样、贪婪采样等）的方法。

- 在专家迭代中，MCTS的搜索算法的作用：

  - **传统采样方法**（如温度采样或贪婪采样）通常是基于当前模型的预测直接生成下一个token，比较直观且高效，但它的探索空间有限，不能很好地进行全局优化，可能陷入局部最优解。
  - **MCTS**（或类似的搜索算法）则可以在更广阔的解空间中进行探索。它通过模拟多个候选路径，逐步评估不同策略或生成的效果，最终选择一个最优的策略或生成序列。这种方法可以帮助模型探索更有效的输出路径，避免仅依赖于当前策略生成。

- 如何结合：
  - **替代采样**：可以直接使用MCTS作为采样策略，替代传统的贪婪采样或温度采样。在这种情况下，模型的每一步生成并不是依赖当前token的概率分布，而是通过MCTS探索多种生成路径并选择最优的路径。
  - **结合采样**：MCTS也可以与传统采样方法结合使用。例如，首先通过温度采样生成多个候选token，然后使用MCTS在这些候选token上进一步进行探索，选择最优的后续生成路径。这种方法结合了传统生成方法的效率和MCTS的全局优化能力。

- 总之，专家迭代中的“搜索”通过引入像MCTS这样的搜索算法，能在生成过程中进行更全面的探索，优化生成结果，进而提升模型的性能。这也是与传统的简单采样方法的一个重要区别。
    
#### 问题3：在《STaR: Self-Taught Reasoner Bootstrapping Reasoning With Reasoning》中，STaR直接使用拒绝采样（reject sampling）作为搜索算法吗？
    
- 回复：在《STaR: Self-Taught Reasoner Bootstrapping Reasoning With Reasoning》中，**STaR确实直接使用拒绝采样（reject sampling）作为其搜索算法的核心机制**，但其实现方式与传统搜索算法（如MCTS）存在差异。
![image 9]({{ &quot;/assets/images/2025-02-19-Reasoning-model-reproduced/image 9.png&quot; | relative_url }}){: img }

- 以下是具体分析：

  - STaR中的拒绝采样如何作为搜索算法？

    - **核心流程**：
        - **生成候选答案**：语言模型（LLM）针对一个问题生成**多个可能的答案**（例如，通过温度采样生成多样化的候选）。
        - **筛选高质量答案**：通过预定义的**规则或外部信号**（如问题是否最终被正确解答）**拒绝（过滤）错误的答案**，仅保留正确的答案作为“专家数据”。
        - **微调模型**：用筛选出的高质量答案微调LLM，使其逐渐提升推理能力。
    
    - **拒绝采样的搜索本质**：
        - **搜索空间**：生成多个候选答案的过程相当于在模型的输出空间中**探索可能的解**。
        - **搜索策略**：拒绝错误答案的步骤类似于在搜索过程中**基于奖励函数筛选最优动作**（如MCTS中的价值评估）。
        - **动态迭代**：随着模型微调后生成更高质量的答案，后续搜索（生成+过滤）的效率和质量逐步提升，形成自我增强的循环。

  - 与传统搜索算法（如MCTS）的异同

    - **相似性**：
        - **目标一致**：通过主动生成和筛选，寻找更优解（如高奖励的答案）。
        - **迭代优化**：搜索与策略更新交替进行，逐步逼近专家水平。
  
    - **差异性**：
        | **维度** | **STaR的拒绝采样** | **传统搜索（如MCTS）** |
        | --- | --- | --- |
        | **生成方式** | 通过温度采样随机生成候选答案 | 系统性构建搜索树，基于价值网络或规则扩展节点 |
        | **筛选标准** | 依赖外部规则（如答案正确性） | 依赖价值函数或模拟结果评估未来收益 |
        | **计算复杂度** | 较低（仅需生成和简单过滤） | 较高（需多步模拟和回溯更新节点价值） |
        | **适用场景** | 文本生成等离散输出任务 | 棋类游戏、规划问题等结构化环境 |

  - 为什么说拒绝采样是STaR的“搜索算法”？

    - **搜索的定义扩展**：
        在强化学习和语言模型领域，“搜索”不仅限于传统的树搜索或规划算法，**任何生成候选解并通过某种标准筛选最优解的过程均可视为搜索**。拒绝采样通过生成多样化解并保留符合条件的结果，本质上是在模型的输出空间中执行一种**定向探索**。
    
    - **STaR的搜索特性**：
        - **探索（Exploration）**：通过温度采样生成多样化答案。
        - **利用（Exploitation）**：保留正确（高奖励）答案作为训练数据，引导模型聚焦高质量解。

  - 实例说明
      - 假设STaR训练一个数学解题模型：
    
        - **生成阶段**：模型对问题“若x+2=5，求x”生成3个候选答案：
            - Answer 1: x = 3 ✅
            - Answer 2: x = 5 ❌
            - Answer 3: x = 0 ❌
        - **拒绝采样**：过滤掉错误答案（Answer 2和3），仅保留Answer 1。
        - **微调**：用Answer 1更新模型参数，使模型更倾向于生成类似正确答案。
    
      - 这一过程通过反复生成、筛选和微调，使模型逐渐学会生成正确的推理步骤，而非依赖外部标注数据。**此处的拒绝采样即充当了搜索算法的角色**。

- 总结：在STaR框架中，**拒绝采样直接作为搜索算法使用**，其核心功能是通过生成候选解并过滤低质量结果，动态地为模型提供自我提升的专家数据。尽管实现方式较传统搜索算法（如MCTS）更简单，但它符合搜索的核心逻辑——在输出空间中探索并利用最优解。这一设计使STaR能够在无需外部专家标注的情况下，通过自我迭代提升推理能力。

#### 问题4：解释一下PPO、DPO与behavior cloning的区别是什么？为什么说“PPO and DPO have better data utilization than behavior cloning”？

- 回复：PPO（Proximal Policy Optimization）、DPO（Direct Preference Optimization）与Behavior Cloning（行为克隆）的核心区别体现在**数据利用方式**和**学习机制**两方面，具体如下：

- 核心区别对比

  - **训练数据范围不同**
      - **Behavior Cloning**：仅使用搜索中**高奖励状态-动作对**（即专家级示范数据 $D_{expert}$），忽略低奖励或负奖励样本[citation:1][citation:3]。
      - **PPO与DPO**：利用搜索中**全部状态-动作对**（$D_{search}$），包括负奖励样本。这些负面数据通过策略梯度或偏好对齐机制提供优化信号[citation:1][citation:3]。
  - **学习目标差异**
      - **Behavior Cloning**：通过模仿专家行为直接拟合策略，本质是监督学习，缺乏对非专家行为的探索与反馈[citation:3]。
      - **PPO**：通过最大化累积奖励并约束策略更新幅度（信任域优化），利用负样本调整策略以避免次优行为[citation:3][citation:4]。
      - **DPO**：基于偏好数据直接优化策略，将人类反馈或对比学习融入目标函数，更高效利用正负样本对比信息[citation:3]。
  - **适用阶段与效率**
      - **Behavior Cloning**：初期训练效率高，适合策略预热，但易受专家数据质量限制，陷入性能瓶颈[citation:3][citation:4]。
      - **PPO/DPO**：在后期优化中表现更优，通过广泛数据利用突破性能上限，但需更多计算资源[citation:3][citation:4]。

- 为何PPO/DPO数据利用率更高？

  - **负面样本的价值**
    - PPO和DPO通过分析**低奖励或错误动作**（如数学解题中的错误步骤），明确策略需改进的方向，而Behavior Cloning因忽略此类数据，可能重复专家策略的盲区[citation:1][citation:3]。
    
  - **探索与泛化能力**
    - 使用全量数据（ $D_{search}$ ）使PPO/DPO能覆盖更广泛的状态空间，避免过拟合专家轨迹，提升策略在复杂场景下的鲁棒性[citation:3][citation:4]。
    
  - **优化信号多样性**
    - PPO通过策略梯度直接优化奖励函数，负样本的梯度反向传播可抑制不良行为[citation:3]。
    - DPO利用偏好对比数据（如“好答案 vs 坏答案”），从差异中提取更精细的优化信号[citation:3]。

- 实证与案例分析

  - **Havrilla等（2024）的发现**：在GSM8K和MATH任务中，Behavior Cloning（专家迭代）短期表现优于PPO，但长期需结合PPO/DPO突破瓶颈[citation:3]。
  - **LLama2/3的实践**：采用“Behavior Cloning预热→PPO/DPO优化”的混合流程，验证了全量数据在后期优化中的必要性[citation:3][citation:4]。

- 总结：PPO和DPO的“高数据利用率”源于其对**全量数据（含负面样本）的整合能力**，而Behavior Cloning仅依赖专家数据，限制了其长期优化潜力。这一差异使PPO/DPO更适用于复杂、需长期迭代的任务（如数学推理），而Behavior Cloning则适合快速初始化策略[citation:1][citation:3][citation:4]。

#### 问题5：“online search&quot;指的是什么意思？
    
- 回复：在强化学习中，**在线搜索（online search）**指的是在训练过程中，智能体根据当前的策略和环境模型，实时地探索和评估可能的行动序列，以预测未来的奖励或结果。这种方法使智能体能够在执行动作之前，预见不同策略的潜在效果，从而做出更明智的决策。
- 举例：蒙特卡罗树搜索（MCTS）就是一种常见的在线搜索技术，它通过构建搜索树来评估不同的行动路径，以选择最优策略。
- 缺点：在线搜索通常需要大量的计算资源，可能导致训练时间的显著增加。
- 总结：研究者们正在探索如何优化搜索算法，或通过利用先前搜索迭代的数据，来提高训练效率。
    
#### 问题6：在线搜索（Online Search）如果考虑过往历史数据，并对历史数据采用不同于目标策略的行为策略进行探索，那就是off policy，是吗？
    
- 回复：是的。**若在在线搜索（online search）中引入历史数据，且这些数据是由与当前目标策略（target policy）不同的行为策略（behavior policy）生成的，则此时的数据利用属于典型的离策略（off-policy）学习**。以下是具体分析：

- **核心概念澄清**

  - **在线搜索（Online Search）**：
    - 通常指在训练过程中，模型基于**当前策略**（即目标策略）实时与环境交互，生成新数据并立即用于策略更新（即**on-policy**模式）。
  - **离策略（Off-Policy）**：
    - 当使用**历史数据**（由旧策略生成）或**其他策略生成的数据**（如探索性策略）来更新当前策略时，数据生成策略（行为策略）与目标策略不同，即属于off-policy学习。

- **在线搜索与Off-Policy的关联**

  - 当在线搜索过程中**混合使用历史数据**时，会产生以下关联：

    - **行为策略与目标策略的差异**：
       - 历史数据由过去的策略（行为策略）生成，而当前训练的目标策略可能已更新。
       - 例如：在迭代训练中，第\( t \)轮使用策略\(\pi_t\)生成数据，而第\( t+1 \)轮训练时复用这些数据优化策略\(\pi_{t+1}\)，此时\(\pi_t \neq \pi_{t+1}\)，属于off-policy。
    - **数据分布偏移**：
       - 历史数据的动作分布（由旧策略决定）与当前策略的动作分布可能不同，直接复用会导致偏差。

- **实际场景示例**

  - 以**MCTS-DPO训练数学推理模型**为例：
    - **纯在线搜索（On-Policy）**：
      - 每轮训练均基于当前策略\(\pi_{current}\)运行MCTS生成新数据，并立即用于更新\(\pi_{current}\)。
    - **引入历史数据（Off-Policy）**：
      - 若复用前几轮由策略\(\pi_{old}\)生成的MCTS数据来更新当前策略\(\pi_{current}\)（\(\pi_{old} \neq \pi_{current}\)），则需通过重要性采样（importance sampling）或Q值修正等方法调整数据权重，以解决分布偏移问题[citation:1]。

- **Off-Policy学习的优势与挑战**
  - **优势**：
      - **提升数据利用率**：减少重复搜索，加速训练（如避免每次迭代都重新运行MCTS）[citation:1]。
      - **增强探索性**：可结合探索性策略（如ε-greedy）生成历史数据，覆盖更广的状态-动作空间。
  - **挑战**：
      - **策略不一致性**：需设计方法（如重要性加权、保守策略更新）来抵消行为策略与目标策略的差异。
      - **稳定性风险**：旧数据可能包含过时或次优决策，影响当前策略优化方向。

- **经典Off-Policy算法参考**

- **DQN（Deep Q-Network）**：
  - 使用**经验回放（experience replay）**存储历史数据（由旧策略生成），通过随机采样更新当前Q网络。
- **Q-Learning**：
  - 直接基于历史数据中的最大Q值更新策略，无需依赖行为策略的具体选择。

- **总结**
  - 在线搜索中若引入由不同策略生成的历史数据，本质上已进入off-policy学习范式。尽管这会带来数据利用率的提升和计算成本的降低，但需通过算法设计（如重要性采样、策略约束）来缓解策略差异导致的偏差问题。这一权衡在复杂任务（如数学推理模型的训练）中尤为关键。

#### 问题7：“The problem of updating questions is also related to Curriculum Learning (Wang et al.), especially automatic curriculum learning (Kumar et al.). ”中的curriculum learning是什么意思？
    
- 回复：**课程学习（Curriculum Learning）**是一种机器学习策略，旨在通过从易到难的顺序训练模型，以模仿人类学习的过程。具体而言，模型首先在简单的样本上进行训练，然后逐步引入更复杂的样本。这种方法有助于模型更有效地学习，提高泛化能力和收敛速度。在强化学习中，课程学习被应用于设计任务或数据的顺序，使模型能够逐步掌握复杂的技能或解决更具挑战性的任务。 ￼
    
#### 问题8：如何考虑curriculum learning的情况下，还能生成比LLM原有策略不一样的更复杂的问题？
    
- 回复：在课程学习（Curriculum Learning）框架下生成比当前LLM策略能力更复杂的问题，需结合**动态难度调整**和**反馈驱动生成**机制，确保问题既具有挑战性又处于模型的“可学习区”。以下是具体实现方法：

  - **动态难度评估与反馈**

    - **(1) 量化模型能力边界**

      - **能力指标**：根据模型在验证集上的表现（如准确率、解题时间、错误类型分布），构建**难度感知指标**。
        - 例：对数学问题分类（代数、几何、微积分），记录模型在每类的准确率。
      - **难度标签**：为每个问题标注多维难度标签（如逻辑复杂度、知识领域、步骤数）。

    - **(2) 反馈驱动的难度调控**

      - **自适应阈值**：设定目标策略当前在某一问题类别的准确率阈值（如80%），当模型超过阈值时，生成器提升该类问题的难度。
        - 例：若模型在“一元二次方程”准确率达85%，则生成含参数的一元二次方程或与几何结合的问题。
      - **错误模式分析**：针对模型频繁出错的题型（如概率问题中的条件独立性），生成器定向增加相关变体问题。

  - **生成策略设计**

    - **(1) 对抗式问题生成**
      - **生成器-判别器框架**：
        - **生成器**（Adversarial Generator）：尝试生成模型当前策略难以解决但并非不可解的问题。
        - **判别器**（Difficulty Discriminator）：预测模型对新问题的解决概率，筛选出成功概率在20%-80%之间的问题（确保处于“学习区”）[citation:1]。
             - 技术参考：类似GAN，但目标为生成可学习的问题而非逼真数据。

    - **(2) 基于课程模板的增强**
      - **模板扩展**：在现有问题模板中引入变量约束、多步推理或跨领域知识。
        - 例：将单一方程问题扩展为方程组，并加入实际应用背景（如物理运动学）。
      - **合成增强**：使用符号引擎（如SymPy）自动生成数学问题变体，确保逻辑正确性同时提升复杂度。

  - **可控复杂度注入**

    - **(1) 分阶段复杂度提升**

      - **阶段划分**：
        - 将训练分为多个阶段，每个阶段定义核心复杂度维度（如推理步数、多模态输入、开放性答案）。
            - 例：
                - 阶段1：单步代数问题；
                - 阶段2：多步代数+几何综合问题；
                - 阶段3：开放域问题（需检索外部知识）。
      - **过渡条件**：
        - 当模型在某一阶段达到稳定性能（如准确率&gt;90%且方差低），自动触发下一阶段。

    - **(2) 混合人类与AI协作**

      - **人类干预**：
        - 引入专家标注的“种子难题库”，生成器从中学习复杂问题的构造模式。
      - **AI辅助增强**：
        - 使用LLM（如GPT-4）对种子问题改写，添加干扰信息或隐藏假设条件。

  - **鲁棒性验证与过滤**

    - **(1) 可解性验证**

      - **符号验证**：
        - 对生成的问题（尤其是数学类），通过符号计算工具验证其存在解且符合逻辑。
      - **多策略验证**：
        - 使用不同方法（如模型旧版本、规则引擎）交叉验证问题可解性，避免生成“陷阱题”。

    - **(2) 动态淘汰机制**

      - **无效问题过滤**：
        - 若某问题连续多轮训练中未被模型正确解答，且人工验证为合理，则降低其生成优先级；若被判定为不可解或歧义，则直接剔除。

  - **案例：数学推理模型训练**
    - **步骤示例**
      - **初始阶段**：
         - 生成单变量线性方程问题，模型准确率达95%。
      - **难度升级**：
         - 生成器引入含绝对值或分式的方程，模型准确率降至70%。
      - **反馈调整**：
         - 生成器聚焦分式方程变体，同时混合少量几何问题（准确率&lt;50%）。
      - **跨领域综合**：
         - 生成需同时应用代数与几何知识的问题（如利用勾股定理建立方程）。

- **总结**：通过**动态反馈机制**、**对抗式生成**和**可控复杂度注入**，课程学习框架可系统性生成超越当前策略能力的问题，同时避免无效训练。关键在于将问题生成器与策略性能深度耦合，形成“生成-评估-调整”的闭环，使LLM在渐进式挑战中突破能力边界。

#### 问题9：那么RLHF中的PPO的reward model与传统的PPO中的有什么区别？
    
- 回复9：在 **RLHF（Reinforcement Learning with Human Feedback）** 中，PPO（Proximal Policy Optimization）的 **reward model** 与传统 PPO 的奖励机制有明显的区别，主要体现在奖励信号的来源和计算方式上。

  - **传统 PPO 中的奖励模型：**
    
    - 在传统的 PPO 算法中，奖励信号通常直接来自环境的反馈。智能体根据当前策略  与环境交互，执行动作并收到来自环境的奖励。这个奖励通常是环境预定义的指标或目标（例如，在游戏中击败敌人、在导航任务中到达目标等），并且是即时反馈。
      - **奖励来源**：环境提供的即时奖励。
      - **奖励计算**：基于智能体与环境的交互，模型根据奖励信号来更新策略。
      - **更新方式**：策略更新是基于环境反馈进行的，通过近端策略优化（PPO）来平滑更新，以避免策略变化过大。
  - **RLHF 中 PPO 的奖励模型：**
    
    - 在 **RLHF** 中，奖励模型的来源不同。RLHF的目标是通过 **人类反馈** 来引导模型的学习过程，这意味着奖励信号不是来自环境的即时反馈，而是来自人类的标注或评分。这种方法尤其适用于训练具有复杂目标的模型（如语言模型），其中环境的即时反馈可能不足以充分指导学习。
      - **奖励来源**：人类反馈或人类标注的数据。例如，可能有人工评估模型生成的文本质量，或者对模型行为的某种主观评分。
      - **奖励计算**：通过 **奖励模型** 来将人类反馈转化为可用的强化学习奖励。人类提供的是对模型输出的评价或排名，通常这些反馈会通过一个回归模型或分类模型转换成强化学习的奖励信号。
      - **奖励模型的训练**：这个奖励模型通常是单独训练的，它基于大量的人类反馈数据来预测哪些行为（或者说哪些输出）是好的，哪些是差的。这个奖励模型与传统的环境奖励模型不同，它不直接依赖于环境交互，而是依赖于外部的标注数据。

  - **区别总结：**
    - **奖励信号的来源**：
        - 传统 PPO：奖励来自环境的即时反馈。
        - RLHF 中 PPO：奖励来自人类反馈（通过人类标注或评估）。
    - **奖励计算**：
        - 传统 PPO：奖励计算直接依赖于环境（例如，得分、奖励函数等）。
        - RLHF 中 PPO：奖励计算依赖于一个**奖励模型**，该模型通过学习人类的反馈来生成奖励。
    - **策略优化的目标**：
        - 传统 PPO：目标是优化一个基于环境的策略，使智能体在环境中执行任务时获得最大化奖励。
        - RLHF 中 PPO：目标是使模型生成的行为与人类的偏好一致，优化奖励模型后，使用这些人类反馈来调整策略。

  - **传统 PPO 与 RLHF 中 PPO 的共同点：**

    - 两者都使用了 **策略梯度** 方法，通过对策略进行优化来最大化累积奖励。
    - 在 PPO 中，都是基于从策略中采样的数据进行训练，并通过 **近端策略优化（PPO）** 更新策略。

  - **结论：**

    - RLHF 中的 PPO 与传统 PPO 的核心区别在于奖励模型的不同来源：RLHF 的奖励是基于人类反馈生成的，而传统 PPO 使用环境提供的即时奖励。这种差异使得 RLHF 能够处理那些无法通过简单环境奖励来指导的任务，尤其是那些需要复杂理解和人类偏好的任务（如自然语言处理、对话生成等）。

#### 问题10：那么RLHF中的PPO属于on policy 还是off policy？
    
- 回复：**RLHF 中的 PPO** 仍然是一个 **on-policy** 算法。这是因为，即使在 **RLHF**（Reinforcement Learning with Human Feedback）中，奖励信号的来源改变了（从环境奖励变为人类反馈），PPO 依然要求用于训练的数据必须来自于当前策略。

- **为什么 RLHF 中的 PPO 是 on-policy？**

  - **数据来源**：
    - 在 RLHF 中，PPO 的训练依然要求数据来自当前策略 ，即生成的训练数据必须是通过当前策略与环境（或者人类反馈）进行交互得到的。虽然奖励来自人类反馈或奖励模型，但数据仍然是基于当前策略的输出，因此它符合 on-policy 学习的特征。
    
  - **策略更新**：
    - 与传统 PPO 一样，RLHF 中的 PPO 也使用当前策略生成的数据来进行策略梯度更新。在每个训练步骤中，PPO 会计算当前策略对行为产生的影响，并使用该数据来更新策略。
    - PPO 会限制策略更新的幅度（通过“近端”优化），确保策略更新不会太大，以保持训练的稳定性。这一过程依赖于从当前策略生成的数据进行计算，因此属于 on-policy。

  - **人类反馈与奖励模型的作用**：
    - 虽然 RLHF 中的奖励信号来自人类反馈，而不是环境的即时奖励，但这一奖励信号依然是通过奖励模型从当前策略生成的行为中提取的。人类反馈在这里是对模型行为的评估，而奖励模型将这些反馈转换为可以用于策略优化的奖励信号。因此，数据的生成过程依然是基于当前策略，符合 on-policy 特征。

  - **对比 off-policy 学习**：
    - 在 off-policy 学习中（例如 Q-learning 或 DQN），训练过程中可以使用来自不同策略的数据，即使这些数据来自其他先前的策略或行为策略。也就是说，模型不需要从当前策略生成数据，可以利用过去的经验进行学习。这与 RLHF 中的 PPO 不同，因为 RLHF 中 PPO 依然依赖于从当前策略生成的数据。

- **结论：**
  - **RLHF 中的 PPO 仍然属于 on-policy 算法**，尽管奖励信号来自人类反馈，而不是直接来自环境的即时奖励。其关键特征是数据来自于当前策略，且策略更新依赖于当前策略生成的行为和相应的奖励。

#### 问题11：如果基于另外一个LLM充当reward model对LLM的回答进行反馈奖励，这个属于on policy 还是off policy?
    
- 回复：在基于另一个LLM作为奖励模型（Reward Model）对目标LLM的回答进行反馈奖励的场景中，整个训练过程的分类（**on-policy**或**off-policy**）取决于以下关键因素：

- **核心定义回顾**
  - **On-Policy**：策略的优化完全基于**当前策略生成的数据**（即行为策略=目标策略）。
      - 例：每一步都用最新策略生成数据并立即更新（如PPO的原始实现）。
  - **Off-Policy**：策略的优化使用**其他策略生成的历史数据**（即行为策略≠目标策略）。
      - 例：DQN利用经验回放池中的旧数据更新策略。

- **场景分析**
  - **(1) 数据生成方式**
    - **目标LLM的行为策略**：
        - **若每次生成回答均使用当前最新策略**（如实时更新参数），则为**on-policy**。
        - **若使用固定或旧策略生成回答**（如保存历史策略的参数快照），则为**off-policy**。

  - **(2) 奖励模型的作用**
    - **奖励模型仅提供反馈信号**：其角色是评估回答质量，不直接影响数据生成策略。
        - 分类关键仍在于**数据生成策略是否与目标策略一致**。

  - **(3) 数据重用机制**
    - **经验回放（Experience Replay）**：若使用历史数据（如混合新旧策略生成的回答），则属于**off-policy**。
    - **实时生成+立即更新**：若每次仅用最新数据，则为**on-policy**。

- **典型分类结果**
| **场景** | **分类** | **理由** |
| --- | --- | --- |
| 目标LLM实时生成数据并更新策略，无历史数据重用 | **On-Policy** | 行为策略（生成数据）与目标策略（被优化）完全一致。 |
| 目标LLM使用旧策略生成数据，混合历史数据训练 | **Off-Policy** | 行为策略（旧策略）与目标策略（新策略）不同，且存在数据分布偏移问题。 |
| 奖励模型独立更新，但数据生成策略同步更新 | **On-Policy** | 奖励模型仅提供反馈，不影响数据生成策略的实时性。 |

- **具体案例**

  - **(1) RLHF中的PPO（On-Policy典型）**
    - **流程**：
      - 目标LLM基于当前策略生成回答；
      - 奖励模型（如另一个LLM）评估回答并返回奖励；
      - PPO利用这些实时生成的回答和奖励更新策略。
    - **分类**：完全**on-policy**（数据生成与策略更新同步）。

  - **(2) 带经验回放的RLHF（Off-Policy混合）**
    - **流程**：
      - 保存目标LLM历史策略生成的回答；
      - 奖励模型评估新旧混合数据；
      - PPO利用所有数据更新策略。
    - **分类**：**Off-Policy**（因重用旧数据，行为策略≠目标策略）。

- **特殊情况的讨论**

  - **奖励模型动态更新**
    - **若奖励模型与目标策略同步更新**：不影响策略分类，仍取决于数据生成方式（是否使用当前策略）。
      - 例：奖励模型每隔N步更新一次，但目标LLM始终用最新策略生成数据 → **On-Policy**。

  - **多策略协作生成数据**
    - **若多个LLM生成数据（如教师-学生框架）**：学生策略（目标策略）使用教师策略（其他LLM）生成的数据 → **Off-Policy**。

- **总结**

  - 在基于另一个LLM作为奖励模型的场景中：

    - **若目标LLM始终使用当前策略生成数据，且无历史数据重用** → **On-Policy**；
    - **若引入历史数据或旧策略生成的数据** → **Off-Policy**。

  - 奖励模型本身不改变策略分类的核心逻辑，其角色仅为提供反馈信号，分类核心在于**数据生成策略与目标策略的一致性**。
    
#### 问题12：Behavior cloning 属于哪一种？
    
- 回复：**行为克隆（Behavior Cloning）应属于 Off-policy 方法**，以下是详细分析：

- **核心定义回顾**

  - **On-policy**：策略更新的数据必须由**当前被优化的策略**（即目标策略）生成，且每次更新后旧数据失效（例如 PPO）。
  - **Off-policy**：策略更新的数据可以来自**其他策略**（如专家策略、历史策略），允许复用旧数据（例如 DQN、BC）。

- **用户观点的关键误区**

  - 用户认为行为克隆是 On-policy 的主要依据是：“行为克隆使用的数据来自目标策略（专家策略），与目标策略一致，因此是 On-policy。”

  - **误区根源在于混淆了“目标策略”的定义**：
    - **在 On-policy 中**，“目标策略”即当前被优化的策略，需通过其生成数据。
    - **在行为克隆中**，“目标策略”是**专家策略**，而当前被优化的策略是**学生策略**，两者完全不同。行为克隆的数据来自专家策略，而非学生策略，因此属于 Off-policy。

- **行为克隆为何属于 Off-policy？**

  - **(1) 数据来源的本质差异**
    - **专家策略 ≠ 当前策略**：行为克隆的训练数据由**专家策略生成**（例如人类示范），而非当前被优化的学生策略。学生策略在训练过程中从未与环境交互生成数据，仅通过模仿静态数据集学习。
    - **与 On-policy 的对比**：在 On-policy 方法（如 PPO）中，数据必须由当前策略生成，且每次更新后旧数据失效。行为克隆显然不满足这一点。

  - **(2) 与 Off-policy 的共性**
    - **复用外部数据**：行为克隆直接使用专家策略的静态数据集训练学生策略，类似于 DQN 使用 Replay Buffer 中的历史数据（来自过去策略）更新当前策略。
    - **策略与数据解耦**：学生策略的更新完全依赖外部数据（专家数据），与自身是否生成数据无关，符合 Off-policy 的核心特征。

- **用户观点的矛盾点**

  - **(1) 对“目标策略”的误解**

    - 用户将“目标策略”等同于“专家策略”，但实际上：
      - **专家策略是固定的**，不是当前被优化的策略。
      - **学生策略才是目标策略**（需要被优化的策略），但它不生成任何训练数据。

    - 因此，行为克隆的**数据来源（专家策略）与目标策略（学生策略）不一致**，属于 Off-policy。

  - **(2) 监督学习与强化学习的混淆**

    - 行为克隆本质是**监督学习**（通过静态数据集模仿专家），而 On-policy/Off-policy 是**强化学习框架下的分类标准**。
      - 若强行将 BC 归类为强化学习，它更接近 Off-policy，因为数据来自外部策略（专家）。
      - 若严格区分，BC 不属于强化学习（无环境交互、无奖励函数），因此无需套用 On-policy/Off-policy 标签。但学术界通常将其类比为 Off-policy。

- **权威文献支持**

  - **经典教材《Reinforcement Learning: An Introduction》**（Sutton &amp; Barto）中明确将模仿学习（包括 BC）归类为 Off-policy 方法，因其数据来自专家策略而非当前策略。
  - **DAgger 算法的提出**：DAgger 是一种改进的行为克隆方法，其核心改进在于引入 On-policy 数据收集（让学生策略与环境交互生成数据），以解决 BC 的分布偏移问题。这也侧面印证了原始 BC 的 Off-policy 本质。

- **总结：行为克隆的 Off-policy 本质**

    | **维度** | **行为克隆（BC）** | **On-policy 方法（如 PPO）** |
    | --- | --- | --- |
    | **数据来源** | 专家策略生成的静态数据集 | 当前策略生成的最新数据 |
    | **策略更新** | 无需当前策略生成数据 | 必须由当前策略生成数据 |
    | **数据复用** | 可重复使用固定的专家数据 | 每次更新后旧数据失效 |
    | **核心逻辑** | 通过模仿外部专家策略学习 | 通过当前策略交互优化长期回报 |

- **最终结论**：行为克隆（Behavior Cloning）属于 Off-policy 方法，因其依赖外部专家策略生成的数据，而非当前被优化的策略生成的数据。用户的错误源于对“目标策略”概念的混淆。

#### 问题13：如果将专家变为环境，属于哪种？
    
- 回复：将专家变为环境的具体实现方式不同，分类会有所变化。以下是两种主要情景的分析：

- **情景 1：专家作为静态环境模型**

  - **定义**：专家策略被固定为一个环境模型，智能体与该模型交互。环境的状态转移和奖励完全由专家策略决定，且模型不随智能体策略更新而改变。
  - **数据生成**：智能体根据当前策略选择动作，环境（专家模型）基于这些动作生成下一状态和奖励。
  - **分类**：
      - **On-policy**：数据由当前策略与专家环境交互生成，每次策略更新后需重新生成数据。
      - **示例**：使用预训练的专家模型作为仿真环境，智能体通过 PPO 在此环境中训练。

- **情景 2：专家作为动态环境反馈**

  - **定义**：环境动态调整其反馈（如奖励函数）以匹配专家行为，例如通过在线模仿学习（如 GAIL）。
  - **数据生成**：智能体与环境交互生成数据，但环境的奖励信号基于专家策略的偏好（例如判别器网络）。
  - **分类**：
      - **混合策略**：
          - 若环境反馈固定（如预训练的判别器），则属于 **On-policy**（数据依赖当前策略）。
          - 若环境反馈随策略更新（如在线训练的判别器），则可能引入 **Off-policy** 成分（复用历史数据优化判别器）。
      - **示例**：生成对抗模仿学习（GAIL）中，判别器作为环境的一部分提供奖励，策略通过 PPO 更新。

- **核心判断标准**

    | **情景** | **数据来源** | **策略分类** | **原因** |
    | --- | --- | --- | --- |
    | 专家作为静态环境模型 | 当前策略 + 固定专家环境 | **On-policy** | 数据由当前策略生成，环境仅为静态反馈机制。 |
    | 专家作为动态环境反馈 | 当前策略 + 动态调整的专家反馈 | **On-policy 或混合** | 若环境反馈独立于策略则为 On-policy；若依赖历史数据则为混合（部分 Off-policy）。 |

- **总结**

  - **专家变为静态环境** → **On-policy**：数据由当前策略生成，环境仅提供固定反馈。
  - **专家变为动态环境** → **需具体分析**：若环境反馈独立于策略则为 On-policy；若复用历史数据则为部分 Off-policy。

- **关键点**：On-policy/Off-policy 的分类核心在于数据是否由当前策略生成，而非环境的实现方式。只要数据依赖当前策略与环境的实时交互，即属于 On-policy。
    
#### 问题14：为什么π_search的策略概率分布不可获得？
    
- 回复：在 **RLHF（基于人类反馈的强化学习）** 中使用 PPO 时，尽管搜索生成的策略（如通过 beam search 生成的高质量数据）可能优于当前策略（ $π_θ$ ），但直接应用传统 Off-policy 方法（如重要性采样）需要已知搜索策略 π_search 的概率，而这通常是**不可获得**的。因此，RLHF 中的 PPO 通过以下机制间接约束分布偏移（distribution shift），同时避免依赖 $π_{search}$ 的具体概率：

- **核心约束机制**

  - **(1) KL 散度惩罚（KL Divergence Penalty）**
    - **原理**：在奖励函数中引入当前策略（π_θ）与**参考策略（π_ref，如初始 SFT 模型）** 的 KL 散度作为惩罚项，防止策略过度偏离初始分布。
    - **数学形式**：
    - $$R_{\text{total}} = R_{\text{RM}}(x, y) - \beta \cdot D_{\text{KL}}(\pi_\theta(y|x) \mid \pi_{\text{ref}}(y|x))$$
        - $$R_{\text{RM}}$$ : 奖励模型给出的分数
        - $$\beta$$ : KL 惩罚系数，控制偏离幅度
        - $$\pi_{\text{ref}}$$ : 初始监督微调（SFT）模型，作为参考策略
    - **作用**
        - 间接约束搜索策略（ $π_{search}$）的分布偏移，因为搜索生成的高质量数据通常与初始策略（ $π_{ref}$ ）的分布一致（例如基于 $π_{ref}$ 的 beam search）。
        - 即使 $π_{search}$ 的概率未知，KL 惩罚也能限制当前策略（ $π_θ$ ）的更新幅度，使其与 $π_{ref}$ 保持接近，从而缓解分布偏移。

  - **(2) 策略更新截断（Clip Mechanism）**

    - **原理**：PPO 的核心机制是通过截断重要性采样权重（importance weight）限制策略更新的幅度，公式为：
    - $$L^{\text{CLIP}}(\theta) = \mathbb{E} \left[ \min\left( \frac{\pi_\theta(a|s)}{\pi_{\text{old}}(a|s)} A(s,a), \text{clip}\left( \frac{\pi_\theta(a|s)}{\pi_{\text{old}}(a|s)}, 1-\epsilon, 1+\epsilon \right) A(s,a) \right) \right]$$
        - 其中  $$\pi_{\text{old}}$$ 是数据生成时的旧策略（即搜索策略 $$π_{search}$$ ），但由于其概率未知，RLHF 中通常假设 **旧策略与当前策略相近**（即 $$\pi_{\text{old}} \approx \pi_\theta$$ ) ，从而降低对 $$π_{search}$$ 的依赖。
    - **作用**：
      - 即使无法精确计算 $\pi_{\text{search}}(a \mid s)$ ，clip 机制也能强制策略更新幅度在 $1 \pm \epsilon$ 范围内，避免因分布偏移导致的不稳定更新。

- **工程实践中的关键技巧**

  - **(1) 搜索策略与当前策略的显式对齐**
    - **限制搜索空间**：在生成数据时，使用当前策略（ $π_θ$ ）的采样结果作为搜索起点（例如基于 $π_θ$ 的 top-p 采样），而非完全独立的搜索策略（如固定 $π_{ref}$ 的 beam search）。
    - **逐步更新**：在训练过程中交替进行以下步骤：
      - 用当前策略生成数据（包含有限搜索优化）；
      - 使用 PPO 更新策略；
      - 更新参考策略（ $π_{ref}$ ）为当前策略（定期同步）。
    - 此方法确保搜索数据始终与当前策略的分布接近，减少偏移。

  - **(2) 动态调整 KL 惩罚系数（β）**
    - **自适应 β**：根据实际 KL 散度值动态调整 β：
      - 若 KL 散度超过阈值，增大 β 以加强约束；
      - 若 KL 散度低于阈值，减小 β 以鼓励探索。
    - **目的**：平衡生成质量与稳定性，避免过度依赖人工设定的固定系数。

- **与理论 Off-policy 方法的对比**

    | **方法** | **是否需要 π_search 概率** | **RLHF-PPO 的解决方案** | **效果** |
    | --- | --- | --- | --- |
    | 重要性采样（TRPO/PPO） | 是 | 通过 clip 机制隐式限制更新幅度 | 避免依赖 $π_{search}$ 概率，但可能引入偏差 |
    | KL 散度约束 | 否 | 惩罚当前策略与参考策略（ $π_{ref}$ ）的偏离 | 间接约束搜索策略的分布偏移 |
    | 动态策略对齐 | 否 | 限制搜索空间基于当前策略 | 显式减少分布差异 |

- **总结**

  - 在 RLHF 的 PPO 中，尽管无法直接获取搜索策略（ $π_{search}$ ）的概率，但通过以下组合策略缓解分布偏移：

    - **KL 散度惩罚**：约束当前策略与参考策略的偏离，间接对齐搜索策略的分布；
    - **Clip 机制**：限制策略更新幅度，降低对旧策略概率的依赖；
    - **工程对齐技巧**：动态调整搜索空间与策略更新节奏，确保数据分布一致性。

  - 这些方法在实践中的有效性已通过大规模语言模型对齐（如 ChatGPT、Claude 等）得到验证，尽管存在理论近似性，但工程实现上能够显著缓解分布偏移问题。
    

## 7 开源的类o1项目
- Reinforcement Learning Projects

    | Project | Initialization | Reward Design | Train-time Search | Learning | Test-Time Search | Resource |
    | --- | --- | --- | --- | --- | --- | --- |
    | g1 | Prompt | - | - | - | Sampling | [Prompt](https://github.com/bklieger-groq/g1) |
    | Thinking Claude | Prompt | - | - | - | Sampling | [Prompt](https://github.com/richards199999/Thinking-Claude) |
    | Open o1 | SFT | - | - | - | Sampling | [Data](https://github.com/Open-Source-o1/Open-o1) |
    | o1-journey (part 1) | SFT | PRM | Beam-Search | Behavior Cloning | Sampling | - |
    | o1-journey (part 2) | SFT | - | - | - | Sampling | - |
    | Open-Reasoner | - | PRM | Sampling | PPO | MCTS | [Code](https://github.com/openreasoner/openr) |
    | Slow Thinking with LLMs 1 | SFT | ORM | Sampling | DPO | MCTS | - |
    | Slow Thinking with LLMs 2 | SFT | ORM | Sampling | DPO/SFT | smapling | - |
    | Marco-o1 | SFT | ORM | MCTS | Behavior Cloning | MCTS | [Model](https://huggingface.co/AIDC-AI/Marco-o1) |
    | o1-coder | SFT | PRM | MCTS | PPO/DPO | MCTS | - |

## **8 未来展望 (Future Directions)**

### 通用领域适应

- **核心挑战**：构建通用奖励模型。
- **解决方案**：
    - **推理任务**：基于标准答案训练结果奖励模型（Outcome Reward Model），结合奖励塑形技术（Reward Shaping）优化过程奖励模型（Process Reward Model）。
    - **非推理任务**（如对齐任务）：
        - 从偏好数据中训练Bradley-Terry模型。
        - 通过逆强化学习（Inverse RL）从专家数据中学习奖励模型。

### 多模态整合

- **核心挑战**：文本与其他模态（如图像）的细粒度对齐。
- **当前进展**：
    - 将图像融入思维链（CoT），增强模态关联（Gao et al., 2024），但导致推理延迟增加。
- **潜在方向**：
    - 使用连续表示（Continuous Representations）生成CoT，替代传统文本/图像模态信息，降低延迟。

### 世界模型与真实环境交互

- **目标**：推动o1从“强推理体”（阶段2）升级为“环境代理”（阶段3），支持真实环境中的行动与任务解决。
- **关键角色**：
    - **训练阶段**：世界模型模拟环境，提升交互效率。
    - **测试阶段**：基于世界模型进行规划与搜索，预演最优策略后再执行。
- **必要性**：真实环境不可逆（如围棋落子无法撤回），需依赖世界模型实现可逆推演。

未来研究需围绕奖励模型通用化、多模态高效对齐、世界模型驱动的环境交互展开，以推动o1向更复杂任务和真实场景应用演进。

## 9 总结

### **核心贡献**

提出基于**强化学习框架**的o1复现路线图，涵盖以下关键组件：

- **策略初始化**（Policy Initialization）
- **奖励设计**（Reward Design）
- **搜索算法**（Search）
- **学习优化**（Learning）

### **现有研究的定位**

当前开源复现项目（如DeepSeek-R1、QwQ等）均为此路线图的**变体实现**，验证了其技术框架的普适性与可扩展性。

### **未来愿景**

期望通过该路线图激发更多研究，突破以下挑战：

- 复杂奖励模型的通用化设计
- 跨模态推理的高效对齐
- 真实环境下的世界模型构建与规划

**意义：为复现工业级慢思考系统（如o1）提供了理论框架与实践路径，推动LLM向高阶推理与AGI代理能力演进。**</content><author><name>Jason Deng</name></author><category term="LLM" /><category term="papers" /><category term="reasoning" /><category term="reinforcement_learning" /><summary type="html">“文章开篇介绍了人工智能领域的最新进展，尤其是大语言模型（LLMs）在复杂任务上的能力，如编程和高级数学问题求解。OpenAI 的 o1 模型展示了卓越的推理能力，包括任务分解、反思、纠错和探索新解决方案。本文提出了一个基于强化学习（Reinforcement Learning, RL）的路线图，目标是通过策略初始化、奖励设计、搜索和学习四个关键组成部分来复现o1的能力。”</summary></entry><entry><title type="html">Byte Latent Transformer: Patches Scale Better Than Tokens — 开创无tokenizer语言建模的新维度</title><link href="http://localhost:8889/llm/papers/2025/01/06/Byte-Latent-Transformer-Patches.html" rel="alternate" type="text/html" title="Byte Latent Transformer: Patches Scale Better Than Tokens — 开创无tokenizer语言建模的新维度" /><published>2025-01-06T00:00:00+08:00</published><updated>2025-01-06T00:00:00+08:00</updated><id>http://localhost:8889/llm/papers/2025/01/06/Byte-Latent-Transformer-Patches</id><content type="html" xml:base="http://localhost:8889/llm/papers/2025/01/06/Byte-Latent-Transformer-Patches.html">### 论文信息

&lt;details class=&quot;toggle-header&quot;&gt;

**Paper URL：** [https://arxiv.org/html/2412.09871v1](https://arxiv.org/html/2412.09871v1)

**Author：** Artidoro Pagnoni Ram Pasunuru Pedro Rodriguez Benjamin Muller Margaret Li Chunting Zhou Lili Yu Jason Weston Luke Zettlemoyer Gargi Ghosh Mike Lewis Ari Holtzman Srinivasan Iyer

**Code：** [https://github.com/facebookresearch/blt](https://github.com/facebookresearch/blt)

**organization：** FAIR at Meta, Paul G. Allen School of Computer Science &amp; Engineering, University of Washington, University of Chicago

\contribution[‡]Joint second author, \contribution[†]Joint last author, \contribution[⋄]Work done at Meta

&lt;/details&gt;

---

### 文章目录

&lt;details class=&quot;toggle-header&quot;&gt;

1 Introduction

2 Patching: From Individual Bytes to Groups of Bytes

2.1 Strided Patching Every K Bytes

2.2 Space Patching

2.3 Entropy Patching: Using Next-Byte Entropies from a Small Byte LM

2.4 The Byte-Pair Encoding (BPE) Tokenizer and Incremental Patching

3 BLT Architecture

3.1 Latent Global Transformer Model

3.2 Local Encoder

3.3 Local Decoder

4 Experimental Setup

4.1 Pre-training Datasets

4.2 Entropy Model

4.3 Entropy Threshold and Equalizing Context Length

4.4 Entropy Model Context

4.5 FLOPs Estimation

4.6 Bits-Per-Byte Estimation

4.7 Transformer Architecture Hyperparameters

4.8 BLT-Specific Hyperparameters

5 Scaling Trends

5.1 Parameter Matched Compute Optimal Scaling Trends

5.2 Beyond Compute Optimal Task Evaluations

5.3 Patches Scale Better Than Tokens

6 Byte Modeling Improves Robustness

6.1 Character-Level Tasks

6.2 Training BLT from Llama 3

7 Ablations and Discussion

8 Related Work

9 Limitations and Future Work

10 Conclusion

&lt;/details&gt;

---

### Tokenizer-free的相关研究工作
&lt;details class=&quot;toggle-header&quot;&gt;

**the key works on tokenizer-free approaches**

| Year  | Model               | Key Features                                                                                     |
| 2022  | ByT5 (Xue et al.)   | - 第一个大规模字节到字节模型，无需 tokenization &lt;br&gt; - 表现出增强的鲁棒性，但需要显著更多的计算资源 &lt;br&gt; - 不使用任何形式的 compression/patching |
| 2022  | CANINE (Clark et al.) | - 无需 tokenization 的预训练编码器，直接处理 character sequences &lt;br&gt; - 通过 strided convolutions 进行下采样以减少 sequence length &lt;br&gt; - 将下采样与 deep transformer stack 相结合 |
| 2023  | MegaByte (Yu et al.) | - 使用固定大小的 byte patches 作为一种 compression 形式 &lt;br&gt; - 将 patched representation 与 byte-level decoder 结合 &lt;br&gt; - 在 1B 规模下展示了与 token models 相竞争的性能 |
| 2024  | MambaByte (Wang et al.) | - 使用 Mamba state space model 架构进行字节级建模 &lt;br&gt; - 使用固定的 memory state 代替 attention &lt;br&gt; - 在增强鲁棒性的同时，表现出与 subword models 相当的性能 |
| 2024  | BLT (Pagnoni et al.) | - 动态的基于 entropy 的字节 patching &lt;br&gt; - 三部分架构：local encoder、global transformer 和 local decoder &lt;br&gt; - 在提升 efficiency 的同时，匹配基于 tokenization 的模型性能 |

这些工作的共同主题包括：

    - 直接处理字节/字符序列，无需tokenization
    
    - 使用各种形式的压缩（固定补丁、下采样、状态空间）来高效处理更长的序列
    
    - 展示了比基于token的模型更强的鲁棒性
    
    - 在保持无标记化优势的同时，努力匹配基于token的模型性能

这一进展表明，在处理字节级建模的计算挑战时，逐步提高了复杂性，同时保留了避免标记化的优势。

&lt;/details&gt;

---

### **为什么Tokenize不再占主导地位**

Tokenize一直是大型语言模型（LLMs）的基石，将字节分组为静态标记以便高效处理。然而，这种方法也带来了挑战：

    - 领域和模态敏感性： Tokenize常常引入偏差，影响跨领域的性能。
    
    - 噪声脆弱性： Tokenizer based model对输入噪声敏感。
    
    - 正字法无知： 无法直接访问原始字节级特征，限制了细粒度的语言理解。
    
    - 多语言不公正： 固定的词汇表妨碍了跨语言的公平表示。

BLT通过处理原始字节，并根据熵（数据复杂度的度量）动态地将字节分组为补丁，从而克服了这些局限性。此方法确保了计算资源的高效分配。


---
&lt;details class=&quot;toggle-header&quot;&gt;

  &lt;p&gt;&lt;strong&gt;原文：At scale, the computational cost of a Transformer is dominated by large feed-forward network layers that run on every byte, not the cost of the attention mechanism.&lt;/strong&gt;&lt;/p&gt;

 **问题：** 如何理解？
 
 **回复：**

在解释这个问题之前，先回顾一下标准 Transformer Block 的主要组成部分，以及它们各自的计算流程：
 
- Self-Attention 子层（Multi-Head Attention）
 
- 前馈网络子层（FeedForward Network, FFN）

在分析计算复杂度时，通常我们用以下符号来表示：
 
- L：序列长度（sequence length）。
 
- d：词向量或者隐藏向量的维度（hidden size）。

在典型的 Transformer 结构中，这两部分的主要计算量分别是：
 
- Self-Attention 的计算复杂度： $$O(L^2 \cdot d)$$
 
- 前馈网络（FFN）的计算复杂度： $$O(L \cdot d^2)$$
 
下面分别说明这两个复杂度从哪里来。
 
 ---
 
**1. Self-Attention：$$O(L^2 \cdot d)$$**
 
***1.1 以单头为例的计算分析***
 
 以单头自注意力（Self-Attention）为例，假设输入是一个长度为 L、维度为 d 的序列 $$\mathbf{X}\in \mathbb{R}^{L\times d}$$。通过投影矩阵分别得到 Q, K, V，它们的维度依然是 $$L \times d$$（或者拆分成多头后，每一头的维度是 $$d\_{\text{head}} = d/h$$，但我们这里先以不拆分或等效合并的方式分析）。自注意力机制的主要计算在于：
 
- 计算注意力得分
     
    $$
    \mathbf{A} = \text{softmax}\Big(\frac{Q K^T}{\sqrt{d}}\Big)
    $$
 
- 这里 Q 和 K 的维度都是 $$(L \times d)$$。
 
- $$Q$$ $$K^T$$ 的矩阵乘法会产生一个 $$L \times L$$ 的矩阵，计算量约为 $$O(L \times d \times L) = O(L^2 d)$$。
 
- 乘完之后还要进行一次 softmax 操作，不过相对于 $$L^2 d$$ 的矩阵乘法，softmax 的开销通常记为 $$O(L^2)$$ 或略去常数因子后不影响主项，所以主要复杂度还是来自矩阵乘法。
 
- 将注意力得分与 V 相乘

    $$ 
    \mathbf{O} = \mathbf{A} \cdot V \quad (\text{或类似形式})
    $$
 
 
- $$\mathbf{A} 的维度是 (L \times L)，V 的维度是 (L \times d)$$
 
- 最终得到的结果 $$\mathbf{O} 为 (L \times d)$$
 
- 这里的复杂度同样是 $$O(L \times L \times d) = O(L^2 d)$$

 因此，对自注意力层而言，每个头的主要计算都包含了一个 $$L \times L$$ 级别的操作，再乘上隐藏维度 d。如果是多头注意力（Multi-Head Attention），多头并行时总体来说也维持同量级复杂度，常数倍会是“头数”，因此业界通常引用的复杂度结论是：

   $$
   \boxed{ \text{Self-Attention 复杂度} \approx O(L^2 \cdot d) }
   $$
 
 
**2. 前馈网络（FFN）：$$O(L \cdot d^2)$$**

***2.1 标准 Transformer 中的 FFN 结构***

 在标准的 Transformer 中，前馈网络子层通常是两层全连接网络 $$(Linear/MLP)$$ ，并包含激活函数，比如：
 
   $$
   \text{FFN}(\mathbf{x}) = \max(0, \mathbf{x}\mathbf{W}_1 + \mathbf{b}_1) \mathbf{W}_2 + \mathbf{b}_2
   $$
 
 其中：
 
- $$\mathbf{x}$$ 的维度是 $$(1 \times d)$$，或者如果把批和序列长度都算上就是 $$(L \times d)$$。
 
- $$\mathbf{W}_1 $$的维度是 $$(d \times d_{\text{ff}})$$，通常 $$d_{\text{ff}} \approx 4d$$。
 
- $$\mathbf{W}_2$$ 的维度是 $$(d_{\text{ff}} \times d)$$。
 
 
 
***2.2 计算量来源***
 
- 第一层投影 $$\mathbf{x}\mathbf{W}_1$$
 
- 维度：$$(L \times d) \times (d \times d_{\text{ff}}) \rightarrow (L \times d\_{\text{ff}})$$
 
- 计算复杂度：$$O(L \times d \times d_{\text{ff}})$$。若 $$d_{\text{ff}} \approx 4d$$，则这一项复杂度约为 $$O(4 L d^2)$$，省略常数后为 $$O(L d^2)$$。
 
- 第二层投影与激活 $$\max(0, \cdot) \mathbf{W}_2$$
 
- 维度：$$(L \times d_{\text{ff}}) \times (d_{\text{ff}} \times d) \rightarrow (L \times d)$$
 
- 计算复杂度：$$O(L \times d_{\text{ff}} \times d)$$。同样，若 $$d_{\text{ff}} = 4d$$，则是 $$O(4 L d^2)$$，也是 $$O(L d^2)$$ 的量级。
 
把这两个矩阵乘法相加，依然保持在 $$O(L \cdot d^2)$$ 量级，所以我们常见地将 FFN 子层的计算量写为：
 
   $$
   \boxed{ \text{FFN 复杂度} \approx O(L \cdot d^2) }
   $$
 
 
 **3. 总结**
 
- 自注意力（Self-Attention）中 $$L^2$$ 来自于“所有位置与所有位置”之间的相关性计算，在矩阵乘法和后续的加权过程中，每个 token 都要与长度为 L 的序列进行 dot-product 计算，因此得到 $$O(L^2 \cdot d)$$ 的复杂度。

- 前馈网络（FFN）的 $$d^2$$ 则来自于大维度映射的矩阵乘法。FFN 针对序列中每个位置单独做投影，但投影所用的矩阵往往是 $$(d \times 4d)$$ 和 $$(4d \times d)$$ 的级别，因此每个 token 的计算量是 $$O(d^2)$$，对全序列就是 $$O(L \cdot d^2)$$。

这就是在标准 Transformer 中常见的
 
$$ 
\text{Self-Attention: } O(L^2 d), \quad 
\text{FeedForward Network: } O(L d^2)
$$
的主要原因所在。

&lt;/details&gt;

---

### **核心创新： Patches Over Tokens**

![Figure 3: Patching schemes group bytes in different ways, each leading to a different number of resulting patches. Since each patch is processed using a large transformer step, the number of patches directly determines the bulk of the compute expended in terms of flops. These schemes group bytes into patches by (a) striding every four bytes (§2.1) as in MegaByte (Yu et al., 2023), (b) tokenizing with Byte-Pair Encoding (bpe), in this case the Llama-3 (Dubey et al., 2024) tokenizer, (c &amp; d) entropy-based patching as in this work (§2.3), (e) patching on space-bytes (Slagle, 2024), (f) and patching on entropy using a small CNN byte-level model with 2-byte context.](https://arxiv.org/html/2412.09871v1/extracted/6066458/assets/patching_types.png)


BLT将patches作为其主要计算单元，突破了fixed-token词汇表的做法。这些patches通过基于熵的分割生成，动态调整其大小和内容，以适应数据的复杂性。这一创新带来了几个优势：

1. 动态计算分配： 高熵区域得到更多的计算关注，从而优化资源的使用。

2. 可扩展性： BLT通过同时增加补丁和模型的大小，而不增加计算成本，展示了优于基于标记的模型的扩展趋势。

3. 效率提升： 通过将推理成本减少最多50%，BLT在固定的计算预算内支持更大的模型规模。

![https://arxiv.org/html/2412.09871v1/x1.png](https://arxiv.org/html/2412.09871v1/x1.png)

![Figure 1 Scaling trends for fixed inference flop models (fully) trained with varying training budgets. In token-based models, a fixed inference budget determines the model size. In contrast, the BLT architecture provides a new scaling axis allowing simultaneous increases in model and patch size while keeping the same training and inference budget. BLT patch-size (ps) 6 and 8 models quickly overtake scaling trends of bpe Llama 2 and 3. Moving to the larger inference budget makes the larger patch size 8 model more desirable sooner. Both BPE compute-optimal point and crossover point are indicated with vertical lines.](https://arxiv.org/html/2412.09871v1/x2.png)

图示是固定推理计算量时模型的缩放趋势（在不同训练预算下完整训练）。
在基于token的模型中，固定的推理预算决定了模型大小。相比之下，BLT架构提供了一个新的缩放维度，允许在保持相同训练和推理预算的同时同时增加模型和patch大小。

&lt;details class=&quot;toggle-header&quot;&gt;

 &lt;p&gt;&lt;strong&gt;原文：critical difference between patches and tokens is that with tokens, the model has no direct access to the underlying byte features.&lt;/strong&gt;&lt;/p&gt;
 
**问题1:** 这是不是造成经典的9.11&gt;9.8的问题所在？

**回复1.1:** 
 根据文本所述，使用tokens（标记）的模型无法直接访问底层的字节特征，这意味着模型在处理数字序列时缺乏对原始字节级别的理解。这可能导致在处理和比较类似&quot;9.11&quot;和&quot;9.8&quot;这样的数值时出现问题，因为模型只能基于预定义的token来处理，而不能直接理解和处理底层的字节级数值表示。相比之下，BLT模型使用patches直接处理字节序列，可以更好地理解和处理原始数据的特征，这可能有助于更准确地处理数值比较。

**回复1.2:**
根据BLT论文,我认为它可以部分但不能完全解决数字比较这类问题。让我详细分析一下：

1. BLT的优势：
   - 直接在byte级别建模,每个数字会被编码为单独的byte
   - N-gram embedding可以捕获数字序列的模式
   - 相比token-based模型,BLT不会把&quot;9.11&quot;作为单个token处理

2. 依然存在的挑战：
- 数学推理是高层语义问题,仅仅改变token表示并不能完全解决
- 模型仍然需要学习数字的概念和比较运算
- 对小数点的处理可能仍有歧义

3. 可能的改进方向：
- 在数字序列上使用特殊的patch策略
- 为数字比较添加专门的预训练任务
- 结合特定的数字表示方法(如positional encoding)

总的来说，BLT的byte-level处理可能有助于更好地理解数字序列的结构，但要真正解决数学推理问题，还需要在模型架构和训练方法上做进一步的改进。

**问题2:** 基于CoT方式是否相对于BLT更有效解决上述问题？

**回复2:**
如果专门针对数字比较这类问题，我认为基于Chain of Thought (CoT)的微调方式会更有效：

1. CoT的优势：
- 直接引导模型进行step-by-step推理
- 可以显式分解数字比较步骤，如：
  Q: 9.11 &gt; 9.8?   
  A: 让我们一步步分析：   
  - 先比较整数部分：9 = 9   
  - 小数第一位比较：1 &lt; 8   
  - 因此 9.11 &lt; 9.8   答案：否，9.11 &lt; 9.8  
- 可以针对各种数字比较情况设计专门的提示模板

2. BLT的局限：
- 虽然在byte级别有更好的表示
- 但没有直接指导模型如何进行推理
- 需要模型自己学习推理步骤，难度更大

3. 具体实现建议：
- 构建数字比较的专门数据集
- 设计清晰的CoT模板
- 可以结合少量示例的few-shot学习
- 考虑添加自我验证步骤

CoT微调能直接针对问题本质（推理过程），而BLT的改进主要在于表示层面。对于需要明确推理步骤的任务，CoT方法可能更有效。

不过这两种方法也不是互斥的，理想情况下可以将它们结合：
- 使用BLT提供更好的底层表示
- 用CoT微调来增强高层推理能力

&lt;p&gt;&lt;strong&gt;原文：A crucial improvement of BLT over tokenization-based models is that redefines the trade off between the vocabulary size and compute. In standard llms, increasing the size of the vocabulary means larger tokens on average and therefore fewer steps for the model but also larger output dimension for the final projection layer of the model. 
&lt;/strong&gt;&lt;/p&gt;

**问题3:** 词表变大代表的FFN层计算复杂度增大，但也同时导致单token容纳的bytes更多?

**回复3:** 
根据文中所述，这确实是一个权衡。在标准的大语言模型中，增大词表会带来两个相反的效果：词表变大会使得每个token平均能包含更多的字节，从而减少模型需要处理的步骤，但同时也会增大最终投影层的输出维度，增加计算开销，正是由于这种权衡的存在，基于分词(tokenization)的方法在调整token大小和推理成本方面的灵活性很有限。比如文中提到，Llama 3相比Llama 2的词表大小增加了4倍，但平均token大小只从3.7字节增加到4.4字节。

**问题4:** BLT能否应用于中文？

**回复4:** 
BLT作为一个基于byte级别的模型应该可以直接应用于中文,但需要注意以下几点:
1. 中文字符的UTF-8编码特点:
   - 每个汉字通常使用3个bytes来编码
   - 会导致序列长度比英文ASCII文本长3倍左右
   - patch size的设置可能需要相应调整以适应这个特点

2. 分组策略的调整:
中文没有空格分词,不能使用whitespace-based patching，可以考虑使用以下几种patching方式:
   - Entropy-based patching: 基于模型预测的条件熵来确定边界
   - Identity patching: 不对序列进行任何预先切分
   - 针对中文优化的patching方法,比如基于字的边界

3. 潜在优势:
   - 可以避免中文分词的问题
   - 能够处理中英混合文本
   - 对罕见字符有更好的泛化能力

4. 需要验证的方面:
   - compression rate在中文上的效果
   - 模型在中文语料上的性能表现
   - 是否需要针对中文特点进行特殊的超参数调整

虽然理论上BLT能处理中文,但目前论文没有在中文数据集上的实验结果。要确定其在中文上的实际效果,还需要进行专门的实验验证。

&lt;p&gt;&lt;strong&gt;原文：Thus patching cannot assume access to future bytes in order to choose how to segment the byte sequence. 
Formally, a patching scheme $$f_p$$ satisfies the property of incremental patching if it satisfies:&lt;/strong&gt;&lt;/p&gt;

$$
f_p(𝒙_{&lt;i})=f_p(𝒙)_{&lt;i}
$$ 


**问题5:** 这个公式如何理解？

**回复5:** 
公式 $$f_p(𝒙_{&lt;i})=f_p(𝒙)_{&lt;i}$$ 是增量分块(incremental patching)的形式化定义。
让我来解释这个公式的含义：
- $$f_p(𝒙_{&lt;i})$$ 表示对序列x的前i个字节进行分块
- $$f_p(𝒙)_{&lt;i}$$ 表示先对整个序列x进行分块，然后只取前i个位置的结果
- 等式表明这两种方式必须得到相同的结果
- 这个公式的实际意义是：当模型在生成文本时，只根据已经看到的字节来决定分块边界的位置，而且这个决定不会因为后面出现的内容而改变。这确保了模型可以在生成过程中实时、稳定地进行分块决策。

&lt;/details&gt;

---

### **BLT架构：三模块交响曲**

![Figure 2 BLT comprises three modules, a lightweight Local Encoder that encodes input bytes into patch representations, a computationally expensive Latent Transformer over patch representations, and a lightweight Local Decoder to decode the next patch of bytes. BLT incorporates byte n-gram embeddings and a cross-attention mechanism to maximize information flow between the Latent Transformer and the byte-level modules (Figure 5). Unlike fixed-vocabulary tokenization, BLT dynamically groups bytes into patches preserving access to the byte-level information.](https://arxiv.org/html/2412.09871v1/x3.png)


**BLT的核心由三个互联模块组成：**

  - 本地编码器（Local Encoder）： 使用哈希n-gram嵌入和交叉注意力层对原始字节进行编码，生成补丁表示。

     ![Figure 5 The local encoder uses a cross-attention block with patch representations as queries, and byte representations as keys/values to encode byte representations into patch representations. The local decoder uses a similar block but with the roles reversed i.e. byte representations are now the queries and patch representations are the keys/values. Here we use Cross-Attn k= 2.](https://arxiv.org/html/2412.09871v1/x5.png)

  - 潜在变换器（Latent Transformer）： 处理补丁表示的全局模型，采用块因果注意力机制高效处理上下文依赖。

  - 本地解码器（Local Decoder）： 将补丁表示解码回字节，支持准确的生成和理解。

这种模块化设计确保了字节和补丁信息的无缝集成，既保留了原始数据的丰富性，又优化了计算效率。

&lt;details class=&quot;toggle-header&quot;&gt;

 &lt;p&gt;&lt;strong&gt;原文：This model consumes the bulk of the flops during pre-training as well as inference, and thus, choosing when to invoke it allows us to control and vary the amount of compute expended for different portions of the input and output as a function of input/output complexity.&lt;/strong&gt;&lt;/p&gt;

**问题1:** 这段话如何理解？BLT如何依据输入/输出复杂度来调整对不同输入和输出部分所分配的计算资源？

**回复1:** 

BLT通过动态分配计算资源的设计来实现高效的计算量分配。让我解释一下具体机制：

1. 熵预测驱动的动态分配：
   - BLT使用一个小型字节级语言模型来预测下一个字节的熵 - 当熵值超过设定阈值时，会标记为一个patch的边界 - 熵值高意味着下一个字节预测的不确定性大，需要更多计算资源

2. 具体工作流程：
   - 对于熵值低的部分(如单词末尾的字母)，只使用轻量级的Local Decoder - 当遇到熵值高的部分(如句子开头或生僻词)，才调用计算量大的Latent Global Transformer

3. 实际例子：
   - 预测&quot;computer&quot;这个词时： - &quot;c&quot;: 熵值高 → 调用Global Transformer - &quot;omputer&quot;: 熵值低 → 只用Local Decoder

4. 优势：
   - 避免对简单预测使用大量计算资源
   - 将计算能力集中在真正需要的复杂预测上
   - 实现了计算资源的自适应分配

5. 效果：
   - 在保持性能的同时降低了50%的推理计算量
   - 特别适合处理长序列输入，因为可以动态跳过简单部分

这种设计让模型能够&quot;智能地&quot;分配计算资源，将大部分计算力用在真正需要的地方，从而提高整体效率。

&lt;p&gt;&lt;strong&gt;原文：The transformer layers use a local block causal attention mask; each byte attends to a fixed window of $w_ℰ$ preceding bytes that in general can cross the dynamic patch boundaries but can not cross document boundaries. &lt;/strong&gt;&lt;/p&gt;

**问题2:** byte encoder hidden states是否会作为Latent Global Transformer的输入？

**回复2:** 

byte encoder hidden states不会直接参与到Latent Global Transformer的计算中。让我解释其信息流向：
- 信息流向过程：
    byte encoder hidden states → patch cross attention → patch representations → Latent Global Transformer

- 数据转换： 
    1. byte embeddings转换为hidden states
        - h_init = LocalTransformer(byte_embeddings)
    2. cross attention将hidden states聚合为patch表示
        - h_down = StridedConv(h_init)  
        这里patch representations才会输入Latent Global Transformer
    3. Latent Global Transformer只处理patch级别的表示
        - h_down&apos; = GlobalTransformer(h_down)

- 关键点：
    1. byte encoder hidden states的信息被压缩和聚合到patch representations中
    2. Latent Global Transformer只接收和处理patch level的表示
    3. 原始的byte level信息不会直接参与Global模型的计算

- 这种设计的好处是：
    1. 降低了序列长度，提高计算效率
    2. 保持了层次化的特征表示
    3. 通过cross attention机制保留必要的字节级信息

所以byte encoder hidden states主要作用是帮助构建patch表示，而不是直接参与Latent Global Transformer的计算。

&lt;p&gt;&lt;strong&gt;原文：The local decoder predicts a sequence of raw bytes, as a function of previously decoded bytes, and thus, takes as input the hidden representations produced by the local encoder for the byte-sequence.
&lt;/strong&gt;&lt;/p&gt;

**问题3:** local decoder是否使用了local encoder的输出作为输入？

**回复3:** 

本地解码器（local decoder）使用了本地编码器（local encoder）产生的隐藏表示（hidden representations）作为输入。具体来说，解码器在预测原始字节序列时，会利用之前已解码的字节信息，并将编码器生成的隐藏表示作为输入来辅助解码过程。

&lt;p&gt;&lt;strong&gt;原文：where once again, $$W_k$$, $$W_v$$ are key/value projection matrices that operate on a linear transformation and split operation $$𝒟_C$$, applied to the final patch representations $$o_j$$ from the global model, $$W_q$$ is a query projection matrices operating on byte representations $$d_{l−1}$$ from the previous decoder transformer layer (or $$h_{l_ℰ}$$ for the first layer), and $W_o$ is the output projection matrix, thus making $$B∈ℝ^{h_𝒟×n_b}$$, where $n_b$ is the number of output bytes.&lt;/strong&gt;&lt;/p&gt;

**问题4:** split operation $$𝒟_C$$ 具体是如何实现的？

**回复4:** 
从代码中看到split实际上是通过reshape实现的，以下详细分析一下具体实现：

在LocalDecoder类中：

    def forward(self, tokens, embeds, patch_embeds, ...):
        # ...
        if self.patch_embedding_projection is not None:
            # 1. 首先通过线性投影
            patch_embeds = self.patch_embedding_projection(patch_embeds)
            
            # 2. 如果存在cross_attn_k,进行reshape操作
            if self.cross_attn_k is not None:
                # 这里实现了split操作
                patch_embeds = patch_embeds.reshape(
                    bs,  # batch_size 
                    patch_embeds.shape[1] * self.cross_attn_k,  
                    # 新的序列长度
                    self.dim  # 每个head的维度
                )

让我解释这个reshape操作的细节：

1. patch_embedding_projection的作用：

        def _create_patch_projection(self, args):
            if not self._should_create_patch_projection(args):
                return None
            
            # 输出维度是token_emb_dim乘以cross_attn_k
            output_dim = args.dim_token_emb * (self.cross_attn_k or 1)
            
            return nn.Linear(
                in_features=args.dim_patch_emb,
                out_features=output_dim,
                bias=False,
            )

2. reshape的过程：
   - 输入形状: [batch_size, seq_len, dim_patch_emb]
   - 线性投影后: [batch_size, seq_len, dim_token_emb * cross_attn_k]
   - reshape后: [batch_size, seq_len * cross_attn_k, dim_token_emb]

这表明：
  - split不是通过切分或平均操作实现的
  - 而是先通过线性投影扩展维度
  - 然后通过reshape重排这些维度
  - cross_attn_k决定了要分成多少个head

这种实现方式的优点是：
  - 保持了数据的连续性
  - 避免了显式的切分操作
  - 让每个head能够学习到不同的特征表示
  - 计算效率更高

这与论文描述的&quot;maintain P_l as multiple heads&quot;是一致的，只是实现方式更加优雅和高效。

**问题5:** 这里线性投影，为什么不直接投影到reshape后的维度呢？而需要再进行一次reshape?？

**回复5:** 

这是一个常见的实现模式：
先用线性层将 [batch, seq_len, dim\_patch\_emb] 投影到 [batch, seq_len, (cross\_attn\_k * dim\_token\_emb)]的“扁平”形状，然后再用 reshape/view 对最后一维进行拆分或合并，从而得到想要的[batch, seq_len * cross\_attn\_k, dim\_token\_emb] 或 [batch, seq_len, cross\_attn\_k, dim\_token\_emb] 等多维结构。
这样做最主要是为了遵循 线性层的标准输入/输出格式 以及 在后续阶段灵活地处理拆分和并行维度（比如多头、多分块）。
在 PyTorch 中，一个 nn.Linear(in_features, out_features) 通常只对最后一维做线性变换，后续如果要进一步拆分或合并，需要显式地做一个 reshape。

**详细解析**

在这段代码里，核心流程是：

1.	线性投影（nn.Linear）：
   - 将输入从 [batch_size, patch_seq_len, dim\_patch\_emb] 形状，投影成 [batch_size, patch_seq_len, cross\_attn\_k * dim\_token\_emb] 。
   - 代码里 out_features = dim_token_emb * cross_attn_k。

2.	reshape 操作：
   - 把投影后的最后一维 “拆分”/“折叠”成新的序列长度和新特征维度：

   [batch, patch_seq_len, (cross\_attn\_k * dim\_token\_emb)]
$$
\;\;\longrightarrow\;\;
$$
   [batch, (patch\_seq\_len * cross\_attn\_k), dim\_token\_emb]

   - 或者在其他情况下，也可以 reshape 成

   [batch, patch\_seq\_len, cross\_attn\_k, dim\_token\_emb]

等等，不同项目中可能有不同的拆分方式。


之所以 不直接 在线性层中就输出三维甚至四维的形状，而是先输出 
[…, cross\_attn\_k * dim\_token\_emb] 
再 reshape，背后有以下常见原因：

1. PyTorch 中 nn.Linear 的“常规做法”
    PyTorch (乃至大多数深度学习框架) 中的 nn.Linear(in_features, out_features)，其输入一般是 [batch\_dims, seq\_len, in\_features]，然后将最后一维 in_features 投影到 out_features，输出形状是 [batch\_dims, seq\_len, out\_features]。
    如果要获得更高维度的输出（例如 [..., cross_attn_k, dim_token_emb]），往往需要显式地在算完线性层以后进行 reshape。
	
2.	实现简单，可读性和维护性更好
	•	先将最后一维统一投影到 out\_features = cross\_attn\_k \times dim\_token\_emb ，再在后面单点地 reshape，实现逻辑更直观。
	•	如果后续要改动拆分方式（例如多头、多分块），只需要改动后面一个 reshape 的逻辑即可，而不必改动 nn.Linear 的初始化。

3. 在多头、多路分块时的“通用套路”
	•	很多多头机制（multi-head attention）或多分块（multi-group）都会先把 hidden\_dim 线性投影到 (num_heads * head_dim)，再用 reshape/view/transpose 将序列维度或头的维度拆出来。
	•	这是个极其常见的模式，目的是在矩阵乘法中维持一个干净且通用的「二维/三维输入输出」逻辑，后面再用 reshape 来做灵活的维度处理。

4.	避免写“自定义”线性层
    •	如果想要一次性输出 [batch, seq\_len * cross\_attn\_k, dim\_token\_emb] 那可能就需要自己写一个带有自定义 broadcast/reshape 的 Linear，会让代码更复杂、可读性更差。
    •	在实际工程中，先 nn.Linear(in_features, out_features)，然后做 view/reshape 几乎是约定俗成的做法。

类比：多头注意力的拆分

一个和这里非常类似的常见场景是 多头自注意力 (Multi-Head Self-Attention)：

1.	我们通常先用 nn.Linear(hidden_dim, num_heads * head_dim)
2.	再 reshape 成 [batch, seq\_len, num\_heads, head\_dim]
3.	最终再 transpose 一下得到 [batch, num\_heads, seq\_len, head\_dim]


它的思想和你看到的这段 BLT patch_embeds 代码是一样的：
	•	先将倒数第二个维度投影到一个扁平的 num_heads * head_dim，
	•	再 reshape 分拆出 num_heads 这个新维度。


在 Byte/patch 级别的 cross-attn、分块、或 multi-group 等场景下，也是一模一样的套路。

小结 :“先线性投影，再 reshape” 是 PyTorch 等框架里主流的、惯用的实现方式，也是使代码更通用和易维护的常见实践。


简而言之，nn.Linear() 只管把维度从 […, in\_features] 投影到 […, out\_features]，把更多维度或时序长度的处理逻辑留给了后续的 reshape/view/transpose，因此它先输出一个“扁平”的维度，再去做拆分、合并或广播，就能非常灵活地适配多头、多分块、以及各种不同下游模块的需求。

&lt;/details&gt;

---
### 实验设置总结

实验设置包括预训练数据集的选择、熵模型的训练、patching策略的优化以及FLOPs的计算方法。通过这些设置，确保实验结果的可比性和可靠性。

以下是实验设置的精华总结：

#### 1. **预训练数据集**
   - **Llama 2 数据集**：包含2万亿个token，用于扩展定律实验，确定BLT的最佳架构选择。
   - **BLT-1T 数据集**：包含1万亿个token，用于与Llama 3进行下游任务对比的完整预训练。
   - **数据来源**：所有数据均来自公开来源，确保实验的透明性和可重复性。

#### 2. **熵模型**
   - **模型架构**：使用100M参数的字节级语言模型，基于Transformer架构，滑动窗口注意力为512字节。
   - **动态patching**：通过熵模型预测下一字节的不确定性，动态调整patch大小，确保计算资源的高效分配。

#### 3. **熵阈值与上下文长度**
   - **动态调整**：根据熵阈值动态调整patch大小，确保在数据复杂度高的区域分配更多计算资源。
   - **上下文长度均衡**：通过调整序列长度，确保不同patch大小的模型在相同的字节批次上进行训练，避免不公平的比较。

#### 4. **FLOPs计算**
   - **计算方法**：基于Chinchilla的Transformer FLOPs计算方程，结合局部编码器、全局Transformer和局部解码器的FLOPs。
   - **输入嵌入优化**：假设输入嵌入层为高效查找操作，减少计算开销。

#### 5. **每字节比特数（BPB）**
   - **替代困惑度**：BPB作为tokenizer独立的性能指标，用于比较字节级模型和token-based模型的表现。

#### 6. **Transformer架构超参数**
   - **架构一致性**：BLT的局部和全局Transformer均遵循Llama 3的架构，使用SwiGLU激活函数、旋转位置嵌入（RoPE）和RMSNorm层归一化。
   - **注意力机制**：使用Flash Attention优化自注意力层，Flex Attention优化交叉注意力层，提升训练效率。

#### 7. **BLT特定超参数**
   - **模型规模**：实验涵盖400M到8B参数的模型，验证BLT在不同规模下的扩展性。
   - **优化设置**：使用AdamW优化器，学习率为4e-4，结合线性预热和余弦衰减调度，确保训练稳定性。

#### 8. **实验目标**
   - **性能对比**：与Llama 3等token-based模型进行对比，验证BLT在相同计算预算下的性能优势。
   - **鲁棒性验证**：通过噪声输入和字符级任务，验证BLT在处理复杂数据时的鲁棒性。
   - **扩展性验证**：通过不同patch大小和模型规模的实验，验证BLT在扩展性上的优势。

#### 总结
BLT的实验设置通过精心设计的数据集、动态patching策略和高效的FLOPs计算，验证了其在性能、效率和鲁棒性上的优势。实验结果表明，BLT不仅能够匹配token-based模型的性能，还在推理效率和扩展性上展现出显著优势，为未来语言建模提供了新的方向。


&lt;details class=&quot;toggle-header&quot;&gt;

&lt;p&gt;&lt;strong&gt;原文：We carefully design controlled experiments to compare BLT with tokenization based models with particular attention to not give BLT any advantages from possibly using longer sequence contexts.
&lt;/strong&gt;&lt;/p&gt;

**问题1:** 为什么要控制sequence length?这个对试验有什么影响？？

**回复1:** 

在原文中，作者多次强调要保证 BLT 和基于 token 的模型在实验中“看到”或处理到的序列（文本）长度大体一致，即“不让 BLT 因为能处理更长上下文而额外获利”。这一点之所以重要，主要基于以下考虑：

1. Byte 级模型与 Token 级模型天然序列长度不同

	•	对于传统的基于 subword token 的模型（如 BPE），一个 token 平均可能对应 3~4 个字节；

	•	而在 BLT 中，最原始的输入是按字节（byte）级输入，如果不加控制，Byte 模型在同样的“步骤”（或同样的 batch size）下就有可能看到更多实际字符，从而获得“额外的信息量”或“更长的上下文”。

	•	因此，如果让 Byte 模型直接处理比 BPE 模型更多的原始字节数，很可能会造成实验对比不公平，难以判断性能提升究竟来自架构改进还是来自可访问的上下文变长。

2. 序列长度会影响模型的计算量与性能

    •	如果 BLT 的每次训练或推理都能“看到”比 BPE 模型更长的实际文本序列，那么有可能带来更好的语言建模效果，但这并非纯粹由 BLT 的“动态分组/patching”设计带来的优势，而是因为额外的上下文信息。

    •	另一方面，序列长度也与计算成本（FLOPs）强相关：序列越长，需要的 self-attention 或 feed-forward 计算步数就越多。倘若 BLT 不限制序列长度，而 BPE 的序列长度被限制，那 BLT 就在算力/成本与数据使用上都存在“不对等”条件。

3. 控制变量以排除干扰因素，突出模型本身的对比

    •	做对比实验时，通常会采用“控制变量法”去尽量排除所有无关因素（如上下文长度、能看到的字符数等），从而把焦点集中在 BLT 的“可动态分组”以及“字节级建模”本身的效果上。

    •	一旦让 BLT “看到”更多的字节，无法明确区分是因为见到更多文本造成的收益，还是确实来自架构改进（例如 local encoder、n-gram hash embeddings、cross-attention、dynamic patching 等）的收益。

综上所述，之所以在论文中严格控制或对齐 Byte 模型与基于 Token 的模型的输入序列长度，是为了让二者在“同样的文本长度”或“同样的可访问信息”条件下进行对比，从而更准确地评估 BLT 架构本身（如动态 patching、Local Encoder/Decoder 等）的改进带来的收益，而不是被额外的可见文本长度所“稀释”或“放大”。
在实验设计上，这会影响到：

- 训练和推理的 batch size 设定：需要确保 Byte 模型和 Token 模型在相同 batch 情况下，处理到的实际字节数或文本规模是等价的。
- 上下文窗口大小的选择：Byte 模型因为是字节级，默认会比 Token 模型有更长的潜在序列，如果不控制，Byte 模型每个样本可能看到更多上下文。
- FLOPs（浮点运算量）或内存占用：较长序列的注意力计算更贵，控制序列长度可以让比较变得更公平。

只有在这样“被控制”的场景下，才能凸显 BLT 在同等条件下与 BPE 类模型的真实差异，并做出更客观的结论。

**问题2:** 对于“Byte 模型因为是字节级，默认会比 Token 模型有更长的潜在序列”的理解，意思是：相同的一句话，转换为tokens的序列长度比基于BLT模型转换的字节序列要短，是吗？

**回复2:** 

是的，通常情况下，如果我们把同一句话分别用
- 字节级（Byte-level） 的方式表示
- BPE/词片（Token-based） 的方式表示

那么字节序列通常会更长（因为每个字符都要用一个或多个字节来表示），而 BPE 模型则会把多个字符合并成一个 token，因此得到的序列会更短。

举个简单例子： “Hello world”

- 以英文 ASCII 字节方式表示：H e l l o  w o r l d（共 11 个字符，包括空格），实际上还要算上结尾符号、换行、特殊标记等，往往字节数会更多。
- 经过 BPE 可能只会得到 2~3 个 token（比如 [Hello]\ [_world]），因此序列长度较短。


这也是为什么在不加控制的情况下，Byte-level 模型会“看到”更长的序列：同样的文本，字节序列天然地比 BPE 序列更长。为了做公平的对比，论文中往往会控制或对齐二者“实际处理到的文本长度”或“处理到的字节总数”，避免让 Byte-level 模型因为处理了更多原始字节而额外获利。

**问题3:** 文章中是控制基于相同字节的context length对BLT与token based model进行对比试验的吗？

**回复3:** 
是的，他们主要是按“字节（bytes）总数”来控制上下文的长度，从而保证在同一次训练或推理中，BLT 和基于 Token 的模型在“能看到的原始字节总量”上是一致的。这样就避免了 BLT 因为默认字节序列更长而“额外获利”的问题。

具体来说，论文中提到的做法大致包含以下要点：

1.	固定每个批次(batch)的字节总数:
    例如，在处理 Llama 2 数据集时，作者让每个序列的平均长度为 8k 字节；在处理 BLT-1T 数据集时，他们让每个序列的平均长度为 16k 字节。 
    如此一来，无论是 BPE 模型还是 BLT，在同一个 batch 中，都只能“看到”大约相同数量的原始字节。

2.  对应地调整 BPE 模型的序列长度:
    对于 BPE/token 模型，如果一行文本有 8k 字节，Token 化以后可能只有几千个 token（甚至更少），但总的“原始字节数”仍然控制在 8k。
    BLT 则直接处理 8k 字节的序列（再进一步分成 dynamic patch），两边在字节量上是对齐的。

3.	避免让 BLT “看到”比 BPE 模型更多的实际信息:
    若不控制，BLT 可能会直接拿到更多的上下文（因为它按字节读入），而 BPE 模型在同样的文本下往往只对应更短的 token 序列。
    通过固定“字节总数”的做法，可以排除“谁看了更多文本”这个因素，把实验对比的重点放在了「按字节 vs. 按 token」以及「动态分组 vs. 固定分词」本身的差异上。

4.	Flops（计算成本）和上下文长度也因此得到可对齐的衡量:
    作者还进一步做了推理/训练 Flops 的精细估算，并在同等“可见字节数”或同等训练预算时比较性能，保证了对比的公平性。


因此，文中所谓的“carefully design controlled experiments”就是在保证同等字节上下文及相同训练/推理 FLOPs 预算的情况下，对 BLT 与基于 token 的模型进行一系列实验，以排除序列长度或数据规模不同带来的干扰，让读者能更好地理解 BLT 架构本身的优劣势。

&lt;/details&gt;

---

### **Key Findings and Contributions**



BLT的贡献重新定义了LLM的范式：

- Flop Efficiency（浮点操作效率）： 在训练性能上匹配了如LLaMA 3等基于tokenized的模型，同时显著降低了推理成本。

- Robustness（鲁棒性）： 展示了对噪声输入的强大抵抗能力和增强的字符级理解能力，在正字法知识和低资源机器翻译任务中表现卓越。

- Scaling Potential（扩展潜力）： 解锁了LLM扩展的新维度，允许补丁和模型尺寸的同时增长。

---

### **Empirical Insights: BLT in Action**

BLT&apos;s superiority is evident in its performance on standard benchmarks and specific tasks. For instance:

- **Noise Robustness:** Outperforms token-based models in handling noisy inputs, such as character-level distortions.
- **Orthographic Tasks:** Excels in character manipulation tasks, leveraging direct byte-level access.
- **Translation:** Achieves higher scores in low-resource language translations, demonstrating its adaptability to diverse linguistic contexts.

---

### **Beyond Tokenization: The Road Ahead**

The introduction of BLT signals a transformative era in LLM development. By prioritizing efficiency, robustness, and scalability, it paves the way for more inclusive, adaptable, and powerful language models. Researchers and developers can access BLT’s training and inference code on [GitHub](https://github.com/facebookresearch/blt).

For correspondence or collaboration inquiries, contact Artidoro Pagnoni or Srinivasan Iyer via the provided emails.

---

**Conclusion**
BLT is more than an architecture; it is a statement against the limitations of traditional tokenization. By redefining how LLMs process language, it lays the groundwork for future innovations that prioritize flexibility, efficiency, and fairness in AI-driven communication. The age of byte-level language modeling has truly begun.
BLT不仅仅是一种架构；这是对传统标记化（Tokenize）局限性的一种声明。通过重新定义LLM自然语言处理语言的方式，它为未来的创新奠定了基础，在人工智能驱动的交流中，优先考虑灵活性、效率和公平性。字节级语言建模的时代已经真正开始。</content><author><name>Jason Deng</name></author><category term="LLM" /><category term="papers" /><category term="new" /><category term="post" /><summary type="html">“大型语言模型（LLMs）的发展历程传统上由基于tokenizer的架构主导。然而，字节潜在变换器（BLT）的引入标志着一种范式的转变。由Meta的研究人员及其合作伙伴提出，BLT通过消除标记化并处理原始字节数据，创新性地提高了效率和鲁棒性，同时在性能上与tokenizer based model相抗衡。本文将探讨其设计、功能及对未来语言建模的影响。”</summary></entry><entry><title type="html">Coconut：在连续潜在空间中的大语言模型推理范式研究</title><link href="http://localhost:8889/llm/papers/2024/12/25/reason-cot-post.html" rel="alternate" type="text/html" title="Coconut：在连续潜在空间中的大语言模型推理范式研究" /><published>2024-12-25T00:00:00+08:00</published><updated>2024-12-25T00:00:00+08:00</updated><id>http://localhost:8889/llm/papers/2024/12/25/reason-cot-post</id><content type="html" xml:base="http://localhost:8889/llm/papers/2024/12/25/reason-cot-post.html">**Author:** Shibo Hao, Sainbayar Sukhbaatar, DiJia Su, Xian Li, Zhiting Hu, Jason Weston, Yuandong Tian  
1. FAIR at Meta  
2. UC San Diego  
∗ Work done at Meta  

**URL:** [https://arxiv.org/html/2412.06769v2](https://arxiv.org/html/2412.06769v2)  
**Title:** *Training Large Language Models to Reason in a Continuous Latent Space*

---

## 一、思维链(CoT)推理：系统性综述

### 1. 方法分类

#### 1.1 提示工程

- **Jason Wei 等 (2022)：“Chain-of-thought prompting elicits reasoning in large language models.”**  
  通过设计思维链提示来引导大语言模型提供完整的推理路径，然后再生成最终答案，在复杂任务中显著提升了性能。

- **Tushar Khot 等 (2022)：“Decomposed prompting: A modular approach for solving complex tasks.”**  
  提出分解提示法，将复杂问题分解为多个子问题，逐步求解。

- **Denny Zhou 等 (2022)：“Least-to-most prompting enables complex reasoning in large language models.”**  
  开发了由简至繁提示法，首先生成子问题，然后按序求解，以捕捉更深层的依赖关系。

#### 1.2 监督式微调

- **Xiang Yue 等 (2023)：“Mammoth: Building math generalist models through hybrid instruction tuning.”**  
  在 Mammoth 项目中引入混合指令调优，提升了数学推理的泛化能力和鲁棒性。

- **Longhui Yu 等 (2023)：“Metamath: Bootstrap your own mathematical questions for large language models.”**  
  Metamath 项目利用众包或自生成数据进行监督式微调，在数学任务中实现了更强的泛化能力。

#### 1.3 强化学习

- **Alex Havrilla 等 (2024)：“Teaching large language models to reason with reinforcement learning.”**  
  开创性地将强化学习应用于教授大语言模型 CoT 推理。

- **Shibo Hao 等 (2024)：“Reasoning with language model is planning with world model.”**  
  将推理视为结合世界模型的规划过程，增强了动态情境推理能力。

- **Zhihong Shao 等 (2024)：“Deepseekmath: Pushing the limits of mathematical reasoning in open language models.”**  
  DeepSeekMath 应用强化学习来克服高难度数学场景的局限性。

#### 1.4 Token 分析

- **Aman Madaan 和 Amir Yazdanbakhsh (2022)：“Text and patterns: For effective chain of thought, it takes two to tango.”**  
  研究了“符号”、“模式”和“文本” token 在引导高效简洁的 CoT 生成中的作用。

#### 1.5 理论分析

- **Guhao Feng 等 (2023)：“Towards revealing the mystery behind chain of thought: A theoretical perspective.”**  
  从理论角度阐述了 CoT 如何增强模型的表达能力和深度。

- **William Merrill 和 Ashish Sabharwal (2023)：“The expressive power of transformers with chain of thought.”**  
  研究了引入 CoT 的 Transformer 的扩展表征能力。

- **Zhiyuan Li 等 (2024)：“Chain of thought empowers transformers to solve inherently serial problems.”**  
  证明 CoT 帮助 Transformer 解决本质上的顺序性任务，使模型能够“深化”并逐步推理。

### 2. 关键挑战与改进方向

#### 2.1 规划与搜索问题

- **Yann LeCun (2022)：“A path towards autonomous machine intelligence version 0.9.2.”**  
  探讨了“单路径自回归生成”在复杂任务中的局限性。

- **Yuxi Xie 等 (2023)：“Self-evaluation guided beam search for reasoning.”**  
  引入自评估引导集束搜索，使模型能在搜索过程中自我评估不同分支的质量，提高推理准确性。

- **Shunyu Yao 等 (2023)：“Tree of thoughts: Deliberate problem solving with large language models.”**  
  提出思维树 (Tree-of-Thoughts, ToT)，通过树搜索过程显式探索和重访多个推理分支。

---

## 二、大语言模型中的潜在推理：隐式推理的新视角

### 1. 定义和核心现象

#### 1.1 隐藏计算研究

- **Sohee Yang 等 (2024)：“Do large language models latently perform multi-hop reasoning?”**  
  研究大语言模型是否在多跳推理任务中隐式编码中间步骤。

- **Eden Biran 等 (2024)：“Hopping too late: Exploring the limitations of large language models on multi-hop queries.”**  
  探讨多跳推理中“延迟决策”带来的局限性。

- **Yuval Shalev 等 (2024)：“Distributional reasoning in llms: Parallel reasoning processes in multi-hop reasoning.”**  
  在多跳任务中发现了隐式并行推理过程的证据。

#### 1.2 CoT 中的“不一致性”

- **Boshi Wang 等 (2022)：“Towards understanding chain-of-thought prompting: An empirical study of what matters.”**  
  实证研究揭示模型生成的“链条”常常偏离实际内部计算，暴露出“表层-深层不匹配”现象。

- **Miles Turpin 等 (2024)： “Language models don’t always say what they think: Unfaithful explanations in chain-of-thought.”**  
  强调了显式解释与真实推理路径之间的差异，引发了对安全性和可信度的思考。

### 2. 增强潜在推理

#### 2.1 额外 Token 扩展

- **Sachin Goyal 等 (2023)：“Think before you speak: Training language models with pause tokens.”**  
  主张使用 `&lt;pause&gt;` 等特殊 token 来鼓励模型“思考后回应”，提升推理表现。

- **Jacob Pfau 等 (2024)：“Let’s think dot by dot: Hidden computation in transformer language models.”**  
  发现在部分并行任务中插入“...”等填充 token 能带来性能提升。

#### 2.2 规划 Token 预测

- **Xinyi Wang 等 (2023)：“Guiding language model reasoning with planning tokens.”**  
  用规划 token 引导模型生成更有结构的推理链。

#### 2.3 知识蒸馏

- **Yuntian Deng 等 (2023 &amp; 2024)：“Implicit chain of thought reasoning via knowledge distillation.” &amp; “From explicit cot to implicit cot: Learning to internalize cot step by step.”**  
  提出 iCoT（隐式思维链），通过知识蒸馏压缩推理步骤，在不需要显式输出的情况下内化 CoT。

- **Ping Yu 等 (2024)：“Distilling system 2 into system 1.”**  
  将显式的“系统 2”推理蒸馏为“系统 1”内部表征，降低推理成本。

### 3. 方法扩展与优化

- **循环 Transformer：**  
  - **Angeliki Giannou 等 (2023) 和 Ying Fan 等 (2024)：“Looped transformers as programmable computers.” &amp; “Looped transformers for length generalization.”**  
    引入循环 Transformer 用于迭代自处理，支持算法任务和长度泛化。这与 Coconut 的状态反馈“递归”推理机制相呼应。

---

## 三、与 Coconut 的整合：连接显式和潜在推理

根据选定研究，神经影像学实验表明：在人类执行各类推理任务时，主要负责语言理解和生成的大脑语言网络区域往往并不高度活跃。基于 Coconut（连续思维链）的方法，不仅可以部分映射这种认知现象，也在推理效率上有显著优势。Coconut 通过在连续潜在空间中进行推理，而非依赖传统在自然语言空间中逐步生成推理步骤的思维链方法，引入了一个新的推理范式。

具体来说，Coconut 利用语言模型的最终隐藏状态作为“连续思维”的表征，直接将其作为后续步骤的输入，而不是将其解码为 token。主要变化和优势包括：

![Comparison]( {{ &quot;/assets/images/Figure 1 A comparison of Chain of Continuous Thought (Coconut) with Chain-of-Thought (CoT).png&quot; | relative_url }})  
*Figure 1: A comparison of Chain of Continuous Thought (Coconut) with Chain-of-Thought (CoT).*

### 推理空间的转变
- **传统 CoT：**  
  依赖自然语言逐步生成推理，在复杂任务中容易导致效率低下和表达限制。  
- **Coconut：**  
  在潜在空间中运作，更灵活高效，不受语言约束。

### 增强的推理能力
- **多路径推理：**  
  在连续思维中可同时编码多个潜在的下一步，提升需要广泛搜索和回溯的任务表现。  
- **降低错误传播：**  
  避免每步显式语言输出，在潜在空间中优化推理路径，减少错误的累积。

### 效率提升
- **减少 Token 生成：**  
  以更少的步骤完成任务，显著减少 Token 生成量。  
- **潜在空间优化：**  
  直接使用隐藏状态进行推理，降低解码和编码开销。

### 训练与优化
- **多阶段训练：**  
  逐步将显式 CoT 转化为连续思维，提高推理能力与训练效率。

在多个推理任务（尤其是需要复杂规划和搜索的 ProsQA 等场景）中，Coconut 相比传统 CoT 展现出更高的准确率和更少的 Token 生成量。

相关研究佐证：

- **Amalric 和 Dehaene (2019)：**  
  研究非语言区域在逻辑推理任务中的作用。  
- **Monti 等 (2007, 2009, 2012)：**  
  多项研究强调语言处理与推理的解离。  
- **Fedorenko 等 (2011)：**  
  研究发现语言区域在推理过程中的参与度有限，提示了特定领域网络的重要性。

---

## 四、Coconut 的关键特性与机制

### 1. 从“显式生成”到“隐式思考”

与 CoT 的自回归显式搜索（如 ToT）不同，Coconut 能在连续潜在空间中并行保留多个候选路径，与递归推理和内化策略相匹配。它的训练细节进一步凸显了其独特方法：

![Comparison]( {{ &quot;/assets/images/Figure 2 Training procedure of Chain of Continuous Thought (Coconut).png&quot; | relative_url }})  
*Figure 2: Training procedure of Chain of Continuous Thought (Coconut).*

1. **可微分性与反向传播**  
   Coconut 的连续思维完全面向可微分，支持通过反向传播进行优化，学习更高效的连续推理表征。

2. **前向传递**  
   若当前训练阶段设置了 \(n\) 个潜在思维，需执行 \(n+1\) 次前向传递。每次生成新的潜在思维，最后一次传递用于处理剩余文本序列。

3. **损失计算**  
   在每次传递里生成新的潜在思维；最后一次前向传递处理任务输出并计算损失。

4. **顺序与并行化挑战**  
   KV 缓存可减轻部分重复计算，但因为每次传递依赖前一次结果，无法完全并行化。

5. **未来优化方向**  
   提升训练效率仍是研究重点，力求在不损害推理能力的前提下降低计算资源需求。

### 2. 连接“表层语言”和“潜在推理”

Coconut 减少了对自然语言形式生成的依赖，避免了显式 CoT 输出中常见的不一致性。

### 3. 重新思考“规划与搜索”

Coconut 的连续推理过程可被类比为“搜索树”而非线性推理链。它可在潜在空间中保留并评价多条分支，同时基于搜索价值动态调度：

1. **连续思维与搜索树类比**  
   - 在搜索树中，每个节点代表一个潜在推理状态，分支代表可能的发展路径。  
   - Coconut 可同时对多个路径并行评分并进行剪枝。

2. **示例（图 7）**  
   若根节点为 Alex，第一步可探索 `{lempus, sterpus, zhorpus, grimpus}`；若选择 `lempus` 分支，下一步则从孙节点展开。Coconut 能自动评估哪些分支更有前景。

![Trees]( {{ &quot;/assets/images/Figure 7 An illustration of the latent search trees.png &quot; | relative_url }}) 
*Figure 7 An illustration of the latent search trees.*

3. **与标准 BFS 的区别**  
   - **BFS：** 统一广度探索前沿节点。  
   - **Coconut：** 动态优先级评估，在潜在空间评估每个分支的“价值”，更灵活高效。

4. **语言空间解码**  
   经过连续思维后，若返回语言空间，模型会解码出可能的推理路径。根据概率分布，可进一步分析其偏好及下一步选择。

**总结：**  
Coconut 的优势在于隐式评估与动态调度，使其在需要广泛搜索与规划的复杂任务中具备更高效的推理能力。

### 4. 与多阶段训练和自监督的协同效应

1. **多阶段训练与分解目标**  
   - 通过多阶段课程将训练目标分解并逐步复杂化，Coconut 在复杂推理任务中表现更佳。  
   - `&lt;pause&gt;` token 也可结合类似思路在部分场景中获得增益。

2. **与 iCoT 的比较**  
   - iCoT（隐式思维链）也使用多阶段训练，但在“计划移除”等细粒度操作上有所差异。  
   - 二者方法或可结合，进一步强化模型在潜在空间的推理能力。

3. **对监督信号的依赖**  
   - 目前 Coconut 训练时依赖显式思维链数据，将其转化为潜在推理目标。  
   - 作者提出未来可探索不依赖显式语言链监督的潜在推理策略，使模型更具通用性。

#### 混合数据策略

在 Coconut 的多阶段训练中，以 \(p = 0.3\) 的概率将早期阶段数据混入当前训练阶段，有效防止模型遗忘之前学到的知识：

- **连续思维插入**  
  中间阶段的隐层表征（连续嵌入或“思维”）以一定概率被混入后续训练目标中，保证连续性和统一性。

- **目标选择**  
  这些隐层数据能作为额外监督信号，帮助模型在潜在空间和语言空间间更好地衔接。

- **防止遗忘**  
  混合数据策略可最大程度保留早期训练内容，避免在后续阶段产生“灾难性遗忘”。

实验显示，该方法能在多阶段复杂推理任务中取得良好平衡，在潜在（隐层）与显式（文本）推理间自由切换。

![Comparison]( {{ &quot;/assets/images/Table1_Results_on_three_datasets(GSM8l_ProntoQA_ProsQA).png&quot; | relative_url }})  
*Table 1: Results on three datasets (GSM8l, ProntoQA, ProsQA).*

---

## 五、展望：未来推理框架中的多范式集成

### 1. 跨范式融合

将 `&lt;pause&gt;` token、规划 token 与 Coconut 结合使用，可兼顾显式可解释性与隐式并行性，适配更复杂的推理任务。

### 2. 自动化搜索与人工干预

将 Coconut 的潜在空间推理嵌入到 ToT 框架中可有效提升搜索效率与准确性，也为人工干预保留了接口。

### 3. 通用预训练重新设计

若在基础模型（如循环 Transformer）中融入“递归”或“连续推理”机制，可能在推理能力上带来跨越式提升。

---

## 六、结论

本文通过回顾思维链（CoT）在提示工程、监督式微调、强化学习与理论分析等方面的最新发展，说明了显式推理链在诸多任务中的优势与不足。潜在推理的出现进一步挖掘了内化多跳推理与规划的潜力。

Coconut 将这两者加以整合，通过多阶段训练与潜在状态反馈，在连续空间中完成推理和规划，不再局限于单一路径的自回归生成方式。在大量需要规划、回溯的复杂任务中，Coconut 展现了突出的灵活性与效率。

未来，Coconut、iCoT、`&lt;pause&gt;` token 与循环 Transformer 等技术有望通过更大规模、更多样化的验证不断进化，逐渐弥合“语言空间推理”与“内部模型推理”之间的鸿沟，向真正的灵活、多路径的自主思考推进。</content><author><name>Jason Deng</name></author><category term="LLM" /><category term="papers" /><category term="reason" /><category term="CoT" /><summary type="html">本文基于新兴范式 Coconut（连续思维链）的引入，深入探讨了大语言模型(LLMs)中思维链(Chain-of-Thought, CoT)推理和潜在推理的分类，这些分类在思维图谱框架中得到了概述。本文旨在总结大语言模型推理领域的发展轨迹和核心挑战。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:8889/assets/images/post1.png" /><media:content medium="image" url="http://localhost:8889/assets/images/post1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Reasoning with REinforced Fine-Tuning</title><link href="http://localhost:8889/llm/papers/2024/12/12/my-first-post.html" rel="alternate" type="text/html" title="Reasoning with REinforced Fine-Tuning" /><published>2024-12-12T00:00:00+08:00</published><updated>2024-12-12T00:00:00+08:00</updated><id>http://localhost:8889/llm/papers/2024/12/12/my-first-post</id><content type="html" xml:base="http://localhost:8889/llm/papers/2024/12/12/my-first-post.html">### **论文主题**

《REFT: Reasoning with REinforced Fine-Tuning》提出了一种基于强化学习与微调相结合的创新方法，用以提升大语言模型（LLM）的推理能力。该方法旨在通过对推理路径的细化设计和多层次优化，在复杂推理任务中实现更高的准确性、解释性和效率。✨📘✨

---

### **解决的问题**

当前的大语言模型在逻辑推理和复杂任务执行方面仍存在显著瓶颈。具体而言：✨

1. **推理能力的局限性**：虽然预训练语言模型具备一定的通用推理能力，但在处理复杂、多步骤的推理任务时，往往存在逻辑不一致或结果不可靠的问题。📉
2. **标注数据的匮乏**：推理任务通常需要大规模高质量的标注数据，而这些数据的获取成本较高，且不同任务的数据分布具有高度不平衡性。📋
3. **优化目标的不明确性**：传统微调方法依赖于静态的监督信号，难以全面优化模型的推理路径和结果质量。✨

该论文旨在通过引入强化学习中的奖励机制，为推理路径质量和任务结果提供动态反馈，以突破上述限制。🚀

---

### **解决思路**

论文提出了一种强化微调（REFT）框架，其核心思想包括：✨📈✨

![REFT训练框架示意图]( {{ &quot;/assets/images/img.png&quot; | relative_url }}){: img }

1.**结合监督微调和强化学习**：
    - **监督微调 (Supervised Fine-Tuning, SFT)**：利用标注数据进行初步任务适配，学习基本的任务能力。🎯
    - **强化学习信号 (Reinforcement Signals)**：通过奖励函数将任务目标形式化为定量信号，并通过策略优化方法改进模型输出。🎢
2. **奖励机制的设计**：
    - 奖励函数不仅关注最终任务结果的准确性，还对生成过程中的逻辑性、一致性以及效率进行综合评价。🎨
    - 通过设计分步骤和全局奖励函数，提升模型的过程推理能力。🛠️
3. **两阶段优化流程**：
    - **第一阶段**：采用监督微调完成基础任务能力的训练。⚙️
    - **第二阶段**：结合策略梯度方法（如PPO），引入奖励机制进行强化优化。📊
4. **推理路径优化**：
    - 针对逐步推理（Step-by-Step Reasoning）中的逻辑不一致问题，通过奖励信号显式鼓励模型生成逻辑严谨、路径清晰的推理过程。🌟

![推理路径对比示例]( {{ &quot;/assets/images/img_1.png&quot; | relative_url }}){: img }

---

### **针对过程CoT的奖励设计（Reward for Chain-of-Thought Reasoning）**

1. **设计初衷**：
    - **推理路径质量的重要性**：链式推理 (Chain-of-Thought, CoT) 方法已被证明在复杂任务中具有显著优势。然而，模型生成的CoT路径容易因中间步骤的不合理性或冗余性而导致结果偏差。💡
    - **现有方法的局限性**：传统奖励机制通常仅基于最终任务结果，而忽略了推理过程中的路径质量，这种简化可能导致模型优化不足。✨
2. **奖励机制的实现**：
    - **分步骤奖励**：逐步评估推理路径的中间结果，包括每个步骤的逻辑性、一致性和与上下文的相关性。🛡️
    - **全局奖励**：综合评估推理路径的整体合理性和最终答案的准确性。🏆
    - **负向激励**：对冗余步骤、逻辑错误或路径复杂度过高的生成进行惩罚。❌
3. **技术实现**：
    - 通过任务特定的规则（例如基于领域知识的验证机制）自动化评估推理步骤的合理性。📜
    - 借助高级语言模型（如GPT-4）进行推理路径的逻辑一致性和解释性评分。🧠
    - 将局部与全局信号结合，确保生成路径在满足逻辑性的同时兼顾任务效率。🔧
4. **效果与意义**：
    - **提升推理路径的逻辑性**：奖励机制有效减少了路径中的冗余和错误，显著提升了推理的可靠性。📈
    - **增强模型的解释性**：生成的路径结构清晰且易于理解，为任务的透明化提供了基础。📚
    - **提高任务结果的准确性**：通过优化推理路径，最终任务结果的质量得到显著提升。✅
    - **适应复杂推理需求**：该奖励机制在多步计算、多跳推理等复杂任务中表现出优越性。📊✨

---

### **效果分析**

实验结果表明，REFT在多个推理任务中均显著超越现有方法：✨📊✨

![实验结果表格]( {{ &quot;/assets/images/img_2.png&quot; | relative_url }}){: img }

1. **标准任务测试**：在HotpotQA和GSM8K等推理基准数据集上，REFT模型在准确率和推理路径质量评分上分别提升了5%-10%。📊
2. **数据效率**：在有限标注数据条件下，REFT仍能有效提升性能，显示出对低资源场景的适应能力。📉
3. **可解释性分析**：REFT生成的推理路径不仅质量更高，而且逻辑结构清晰，显著改善了用户对模型行为的理解。🌟

---

### **远望**

1. **跨领域扩展**：进一步探索REFT方法在多模态推理、跨领域知识整合等复杂任务中的适用性。✨
2. **优化训练效率**：通过改进奖励设计和优化算法，降低强化学习阶段的计算开销。🚀
3. **实际应用场景验证**：在法律分析、医学诊断和金融决策等高复杂度场景中测试REFT的可行性和有效性。✨
4. **多维度信号融合**：引入多模态数据或特定领域知识以增强模型的推理多样性与准确性。📊
5. **长期推理性能研究**：针对跨文档、跨段落信息整合等长期推理任务展开深入研究。🌟

---

### **总结**

《REFT: Reasoning with REinforced Fine-Tuning》提出了一种创新性的强化微调框架，通过联合优化推理路径和任务结果，显著提升了大语言模型的推理能力。该方法不仅在理论上具有前瞻性，也在实践中展现了广泛的适用潜力，为未来的大规模推理任务提供了新的解决方案。📘🌟📘

---

### **附图表**

1. **REFT训练框架示意图**：
    - 展示监督微调和强化学习阶段的整体流程与关系。🔄
    - 包括奖励信号如何调整模型策略的流程图。📉
2. **推理路径对比示例**：
    - 直观对比传统微调方法与REFT生成的CoT路径，突出逻辑一致性和冗余消除效果。🗺️
3. **实验结果表格**：
    - 详细列出REFT与基线模型在多个数据集上的性能对比，包括准确率、路径质量评分等关键指标。📊📋
4. **奖励机制设计图**：
    - 图解分步骤奖励与全局奖励的设计结构，说明各部分如何协同优化模型性能。📊✨📊</content><author><name>Jason Deng</name></author><category term="LLM" /><category term="papers" /><category term="first" /><category term="post" /><summary type="html">《REFT: Reasoning with REinforced Fine-Tuning》提出了一种基于强化学习与微调相结合的创新方法，用以提升大语言模型（LLM）的推理能力。该方法旨在通过对推理路径的细化设计和多层次优化，在复杂推理任务中实现更高的准确性、解释性和效率。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:8889/assets/images/post1.png" /><media:content medium="image" url="http://localhost:8889/assets/images/post1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Super Weights in Large Language Model</title><link href="http://localhost:8889/llm/papers/2024/12/03/history1-post.html" rel="alternate" type="text/html" title="Super Weights in Large Language Model" /><published>2024-12-03T00:00:00+08:00</published><updated>2024-12-03T00:00:00+08:00</updated><id>http://localhost:8889/llm/papers/2024/12/03/history1-post</id><content type="html" xml:base="http://localhost:8889/llm/papers/2024/12/03/history1-post.html">## **一、研究背景与动机**

### **1.1 前期研究基础**

大语言模型中的异常值研究主要沿两条线索发展：

1. **权重异常值研究**

   •	**发现**：Kovaleva等人(2021)首次在GPT-2中发现了权重异常值，这些异常值在预训练早期即显现，并显著影响模型的输出嵌入向量。

   •	**挑战**：禁用这些权重会显著降低性能，但研究未揭示这些权重的具体作用机制和普适性。

2. **激活异常值研究**

   •	**发现**：Dettmers等人(2022)发现了大型语言模型中的激活异常值，这些激活对模型的性能、特别是压缩后的表现至关重要。

   •	**不足**：这些研究主要集中于激活异常值的特性，未能建立其与权重异常值的因果关系，也未解析异常激活的来源。

### **1.2 研究缺口**

现有研究在理论和实践上仍存在以下局限：

1. **理论局限**

   •	未能建立权重和激活之间的因果链条。

   •	缺乏对异常值在模型计算中的结构性作用的全面理解。

   •	对异常值形成的根本机制和跨模型的一致性研究不足。

2. **实践挑战**

   •	异常值的识别和保护机制不完善。

   •	模型压缩和微调时对异常值的处理不当，导致性能损失。

   •	缺乏稳定控制异常值对模型行为影响的方法。

3. **本研究目标**：通过引入Super Weights的概念，统一解释权重异常值与激活异常值的关系，并提出在实际模型优化中的操作指导。

   ![超级权重示意图]({{ &quot;/assets/images/super_weights.png&quot;| relative_url }}){: img }

## **二、研究方法与过程**

### **2.1 Super Weights的识别方法**

我们采用了以下三阶段方法：

1. **统计分析阶段**

   •	异常值筛选标准：幅度显著高于中位数（100倍以上），在不同输入下保持稳定，且分布固定于MLP下投影层。

    ![异常值筛选标准.png]({{ &quot;/assets/images/异常值筛选标准.png&quot;| relative_url }}){: img }

   •	显著性检验：通过Bootstrap重采样和95%置信区间验证这些权重的显著性。

2. **验证方法**

   •	**线性探测**：分析权重与激活值的关联性及对信息流动的影响。

   •	**消融实验**：通过移除Super Weights和非Super Weights，观察对模型性能的差异影响。

   •	**机制验证**：跟踪激活值的传播路径，研究其对注意力机制和概率分布的调节作用。

3. **跨模型分析**

   •	在不同规模（7B至70B参数）和架构（LLaMA、Mistral等）的模型中重复实验，验证Super Weights的一致性。

### **2.2 实验设计与验证**

1. **消融实验**

   •	控制组：完整模型性能作为基准。

   •	实验组1：移除单个Super Weight。

   •	实验组2：移除7000个最大非Super Weight。

   •	实验组3：移除Super Weight但保留Super Activation。

2. **跨模型验证**

   •	验证Super Weights的位置、数量及对模型性能的影响是否具有普适性。

   •	分析模型规模对Super Weights影响强度的调节作用。

3. **统计分析**

   •	使用效应量和p值评估实验结果的显著性。

   •	对比不同模型和任务下的性能变化。

## **三、核心发现与结果**

### **3.1 定量结果**

1. **LLaMA-7B实验结果**

   TruthfulQA准确率：

   •	**完整模型**：41.81%

   •	**移除Super Weight**：19.80%

   •	**移除7000个非Super Weight**：41.47%

    困惑度：

   •	**完整模型**：5.67

   •	**移除Super Weight**：1211.11

   •	**Super Activation保留**：476.23

2. **跨模型验证结果**

   •	在多个模型中发现Super Weights的位置固定，作用显著。

   •	影响强度随模型规模增大而增强，30B以上模型对Super Weights的敏感性更高。

### **3.2 机制发现**

1. **结构性作用**

   •	Super Weights通过激活值的放大作用影响全网络的注意力模式。

   •	它们集中于MLP的下投影层，并通过跳跃连接对后续层传播影响。

2. **功能特征**

   •	抑制停用词概率，提高关键语义词的权重。

    ![stopwords.png]({{ &quot;/assets/images/stopwords.png&quot;| relative_url }}){: img }

   •	调节注意力机制，维持模型在推理任务中的稳定性。

## **四、应用价值与实践指导**

### **4.1 模型压缩优化**

1. **差异化量化**

   •	Super Weights保持高精度量化，其他权重采用标准量化策略。

   •	设置性能基准，平衡压缩率与性能。

2. **监控与调整**

   •	动态监控压缩过程中Super Weights的变化。

   •	通过梯度裁剪和阈值优化降低异常影响。

### **4.2 模型微调指导**

1. **保护机制**

   •	设置Super Weights的学习率下限，避免过度更新。

   •	使用梯度裁剪限制权重更新幅度。

2. **实践建议**

   •	在领域迁移任务中优先保护Super Weights，以确保性能稳定性。

   •	通过性能监控和调优策略实现动态调整。

### **4.3 架构优化启示**

1. **模型设计改进**

   •	在架构设计时增强MLP下投影层的灵活性和适应性。

   •	针对Super Weights位置进行参数初始化优化。

2. **预训练策略调整**

   •	根据Super Weights的特性调整权重初始化分布，减少早期训练的不稳定性。</content><author><name>Jason Deng</name></author><category term="LLM" /><category term="papers" /><category term="history" /><category term="post" /><summary type="html">这篇文章主要讨论了在大型语言模型中引入“超级权重”（Super Weights）这一概念，以增强模型的表现和适应性。 作者介绍了如何通过特殊加权策略，使模型在保持参数数量不变的情况下实现更高的推理能力和泛化性能。 文中同时阐述了相关的实验结果和案例分析，展示了“超级权重”在实际应用中的潜在优势。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:8889/assets/images/post1.png" /><media:content medium="image" url="http://localhost:8889/assets/images/post1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>