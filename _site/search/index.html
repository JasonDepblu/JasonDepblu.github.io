<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Communication</title>

  <!-- MathJax -->
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]],
        displayMath: [["$$", "$$"], ["\\[", "\\]"]],
        processEscapes: true
      },
      "HTML-CSS": {
      scale: 70  // è°ƒæ•´å…¬å¼å­—ä½“å¤§å°ï¼Œé»˜è®¤ 100ï¼ˆç™¾åˆ†æ¯”ï¼‰
      },
      CommonHTML: {
      scale: 70  // å¦‚æœä½¿ç”¨ CommonHTML è¾“å‡ºï¼Œä¹Ÿéœ€è¦è®¾ç½®
      }
    });
  </script>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/assets/css/custom.css">
</head>

<body class="post-layout">
<!--     Header -->
    <header class="header">
      <div class="container">
        <span class="logo">ğŸŒŸ Jason's Blog</span>
        <nav class="nav">
          <ul>
            
              <li><a href="/">Posts</a></li>
            
              <li><a href="/archive/">Archive</a></li>
            
              <li><a href="/chat/">Q&A</a></li>
            
              <li><a href="/tags/">Tags</a></li>
            
              <li><a href="/about/">About</a></li>
            
              <li><a href="/contact/">Contact</a></li>
            
          </ul>
        </nav>
      </div>
    </header>

    <article>
        <h1>Communication</h1>
        <div class="post-meta">
          <span class="post-date">Date: </span> |
          <span class="reading-time">Estimated Reading Time: 5 min</span> |
          <span class="post-author">Author: Jason</span>
        </div>
        <main class="container">
            <h1>Q & A</h1>
<!-- search.html çš„ä¸»ä½“éƒ¨åˆ† -->
<div id="chat-container">
    <div id="chat-log"><!-- åŠ¨æ€æ’å…¥å¯¹è¯ --></div>
    <div id="input-area">
      <textarea id="question" placeholder="è¯·è¾“å…¥æ‚¨çš„é—®é¢˜..."></textarea>
      <button id="send-btn">æäº¤</button>
    </div>
</div>

  <!-- å¼•å…¥ Markdown æ¸²æŸ“åº“ -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
    // å¼€å¯è°ƒè¯•æ¨¡å¼ï¼Œè¾“å‡ºè¯¦ç»†æ—¥å¿—
    const DEBUG_MODE = true;

    function debugLog(...args) {
      if (DEBUG_MODE) {
        console.log('[DEBUG]', ...args);
      }
    }
    // å‰ç«¯è„šæœ¬ï¼šå‘é€æé—®ï¼Œæ¥æ”¶å›ç­”å¹¶æ›´æ–°UI
    const sendBtn = document.getElementById('send-btn');
    const questionInput = document.getElementById('question');
    const chatLog = document.getElementById('chat-log');

    // ä»æœ¬åœ°å­˜å‚¨ä¸­è·å–ä¼šè¯IDï¼Œç”¨äºç»´æŒå¯¹è¯è¿ç»­æ€§
    let sessionId = localStorage.getItem('chatSessionId');

    // è®¾ç½®è½®è¯¢ç›¸å…³å‚æ•°
    const POLL_INTERVAL = 5000; // è½®è¯¢é—´éš”
    const MAX_POLL_ATTEMPTS = 60; // æœ€å¤§è½®è¯¢æ¬¡æ•°

    const pendingRequests = new Map();
    let streamFailureCount = 0;

    // API ç«¯ç‚¹é…ç½®
    // è·å–å½“å‰åŸŸå
    const domain = window.location.origin;
    // æ„å»ºç»å¯¹è·¯å¾„ API URL
    const API_URL = `${domain}/.netlify/functions`;

    // ç®€å•é—®å€™çš„æœ¬åœ°ç¼“å­˜
    const GREETING_CACHE = {
      "hi": "ä½ å¥½ï¼æˆ‘æ˜¯åšå®¢åŠ©æ‰‹ï¼Œå¯ä»¥å›ç­”æ‚¨å…³äºåšå®¢å†…å®¹çš„é—®é¢˜ã€‚æœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©æ‚¨çš„å—ï¼Ÿ",
      "hello": "ä½ å¥½ï¼æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ",
      "hey": "å—¨ï¼æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ",
      "ä½ å¥½": "ä½ å¥½ï¼æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ",
      "hello there": "ä½ å¥½ï¼å¾ˆé«˜å…´ä¸ºæ‚¨æœåŠ¡ã€‚è¯·é—®æœ‰ä»€ä¹ˆé—®é¢˜å—ï¼Ÿ",
      "å—¨": "å—¨ï¼æˆ‘æ˜¯åšå®¢åŠ©æ‰‹ï¼Œå¾ˆé«˜å…´èƒ½å¸®åŠ©æ‚¨ã€‚",
      "å“ˆå–½": "å“ˆå–½ï¼è¯·é—®æœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©æ‚¨çš„ï¼Ÿ"
    };

    // Simple hash function
    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
      return hash;
    }

    // å‘èµ·åˆå§‹è¯·æ±‚ï¼Œè·å–requestIdæˆ–ç›´æ¥è·å–ç­”æ¡ˆ
    async function initiateRequest(question, sessionId, useStream = false) {
    try {
      // Create a hash to identify this specific question
      const questionHash = hashString(question);

      // Check if we're already processing this exact question
      if (pendingRequests.has(questionHash)) {
        console.log("Request already in progress for this question");
        return { inProgress: true };
      }

      // Add to pending requests
      pendingRequests.set(questionHash, true);

      try {
        // Original function logic starts here
        const isSimpleQuestion = question.length < 50 &&
                               !question.includes("å¦‚ä½•") &&
                               !question.includes("ä¸ºä»€ä¹ˆ") &&
                               !question.includes("æ¯”è¾ƒ");

        const normalizedQuestion = question.toLowerCase().trim();

        if (GREETING_CACHE[normalizedQuestion] && !useStream) {
          return {
            directAnswer: true,
            answer: GREETING_CACHE[normalizedQuestion]
          };
        }

        let retries = 0;
        const maxRetries = 3;
        let lastError = null;

        while (retries < maxRetries) {
          try {
            const response = await fetch(`${API_URL}/rag`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
              },
              body: JSON.stringify({
                question,
                sessionId: sessionId,

                preferFastResponse: isSimpleQuestion && !useStream,
                stream: useStream
              })
            });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`æœåŠ¡å™¨é”™è¯¯ (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            console.log("API response received:", Object.keys(data));

            if (data.sessionId) {
              sessionId = data.sessionId;
              localStorage.setItem('chatSessionId', sessionId);
            }

            if (data.answer) {
              console.log("Received direct answer from backend");
              return {
                directAnswer: true,
                answer: data.answer
              };
            }

            if (data.streamConfig) {
              console.log("Received streaming configuration");
              return {
                directAnswer: false,
                streamConfig: data.streamConfig,
                requestId: data.requestId
              };
            }

            if (data.quickResponse) {
              console.log("Received quick response from backend");
              return {
                directAnswer: false,
                quickResponse: data.quickResponse,
                requestId: data.requestId
              };
            }

            if (data.fallbackToStandard) {
              console.log("Stream not supported, falling back to standard processing");
              return initiateRequest(question, sessionId, false);
            }

            return {
              directAnswer: false,
              requestId: data.requestId
            };
          } catch (error) {
            lastError = error;
            retries++;
            console.warn(`Request attempt ${retries} failed: ${error.message}`);

            if (retries < maxRetries) {
              const delay = Math.pow(2, retries) * 1000;
              console.log(`Retrying in ${delay}ms...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }

        throw lastError || new Error('æ‰€æœ‰è¯·æ±‚å°è¯•å‡å¤±è´¥');
      } finally {
        // Always remove from pending requests when done
        pendingRequests.delete(questionHash);
      }
    } catch (error) {
      console.error('åˆå§‹åŒ–è¯·æ±‚å¤±è´¥:', error);
      throw error;
    }
    }

  // æ–°å¢: å¤„ç†æµå¼å“åº”
  // In your handleStreamingResponse function (frontend):
  async function handleStreamingResponse(streamConfig, thinkingId) {
    try {
      console.log("Setting up streaming connection...");

      // Validate the streaming configuration
      if (!streamConfig || !streamConfig.apiEndpoint || !streamConfig.model || !streamConfig.apiKey) {
        console.error("Invalid streaming configuration:", JSON.stringify({
          ...streamConfig,
          apiKey: streamConfig && streamConfig.apiKey ? "[REDACTED]" : undefined
        }, null, 2));
        throw new Error("æµå¼é…ç½®æ— æ•ˆï¼Œæ— æ³•å»ºç«‹è¿æ¥");
      }

      // Log details for debugging
      console.log("Stream config details:", {
        endpoint: streamConfig.apiEndpoint,
        model: streamConfig.model,
        messageCount: streamConfig.messages?.length || 0
      });

      // Remove the "thinking" message
      removeThinkingMessage(thinkingId);

      // Create a message container for the streaming content
      const msgDiv = document.createElement('div');
      msgDiv.className = 'ai-message streaming';
      msgDiv.innerHTML = '<div class="content"></div><div class="stream-indicator">æ­£åœ¨ç”Ÿæˆå›ç­”...</div>';
      chatLog.appendChild(msgDiv);

      const contentDiv = msgDiv.querySelector('.content');
      const indicatorDiv = msgDiv.querySelector('.stream-indicator');

      // Create the request body
      const requestBody = {
        model: streamConfig.model,
        messages: streamConfig.messages || [{ role: "user", content: "è¯·æä¾›å›ç­”" }],
        stream: true,
        temperature: 0.7,
        max_tokens: 1024
      };

      // Log the request structure (without sensitive data)
      console.log("Request structure:", {
        model: requestBody.model,
        messageCount: requestBody.messages.length,
        stream: requestBody.stream
      });

      // Create fetch options
      const options = {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${streamConfig.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      };

      // Send the request
      console.log("Sending stream request to:", streamConfig.apiEndpoint);
      const response = await fetch(streamConfig.apiEndpoint, options);

      // Check response status
      if (!response.ok) {
        const errorText = await response.text();
        console.error("Stream API error response:", errorText);
        throw new Error(`APIè¿”å›é”™è¯¯çŠ¶æ€: ${response.status}`);
      }

      console.log("Stream connection established, starting to read...");

      // Set up stream reader
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let fullResponse = '';

      // Process the stream
      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          console.log("Stream complete");
          break;
        }

        // Decode chunk
        const chunk = decoder.decode(value);
        console.log("Received chunk of size:", chunk.length);

        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data:')) {
            const data = line.slice(5).trim();

            if (data === '[DONE]') {
              continue;
            }

            try {
              const parsed = JSON.parse(data);
              if (parsed.choices && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                const content = parsed.choices[0].delta.content;
                fullResponse += content;

                // Update UI with latest content
                try {
                  contentDiv.innerHTML = marked.parse(fullResponse);
                } catch (e) {
                  contentDiv.textContent = fullResponse;
                }

                // Scroll to bottom
                chatLog.scrollTop = chatLog.scrollHeight;
              }
            } catch (parseError) {
              console.warn("Failed to parse stream chunk:", parseError.message);
            }
          }
        }
      }

      // Stream complete
      console.log("Stream completed successfully");
      indicatorDiv.remove();
      msgDiv.classList.remove('streaming');

      // Update session history
      const userQuestion = streamConfig.messages.find(m => m.role === 'user')?.content || question;
      await updateSessionAfterStreaming(sessionId, userQuestion, fullResponse);

      // Reset failure count on success
      streamFailureCount = 0;

      return fullResponse;
    } catch (error) {
      console.error("Streaming error:", error);

      // Increment failure count
      streamFailureCount++;

      // If we've failed multiple times, disable streaming
      if (streamFailureCount >= 3) {
        const streamToggle = document.getElementById('stream-toggle');
        if (streamToggle && streamToggle.checked) {
          streamToggle.checked = false;
          appendMessage('ai', '<p class="info-message">å·²è‡ªåŠ¨å…³é—­æµå¼å“åº”æ¨¡å¼ï¼Œå› ä¸ºæ£€æµ‹åˆ°å¤šæ¬¡è¿æ¥å¤±è´¥ã€‚</p>');
        }
      }

      // Show error to user
      appendMessage('ai', `<p class="error-message">æµå¼å“åº”å‡ºé”™: ${error.message}</p><p>æ­£åœ¨åˆ‡æ¢åˆ°æ ‡å‡†æ¨¡å¼...</p>`);

      // Return false to indicate failure and trigger fallback
      return false;
    }
  }


  async function updateSessionAfterStreaming(sessionId, question, answer) {
    try {
      debugLog("æ›´æ–°æµå¼å¤„ç†åçš„ä¼šè¯:", sessionId);

      const response = await fetch(`${API_URL}/status`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          updateSession: true,
          sessionId: sessionId,
          question: question,
          answer: answer
        })
      });

      const data = await response.json();
      debugLog("ä¼šè¯æ›´æ–°å“åº”:", data);

      console.log("Session updated after streaming");
      return true;
    } catch (error) {
      console.error("Failed to update session after streaming:", error);
      return false;
    }
  }


  // åœ¨ä¸»æé—®å‡½æ•°å¼€å§‹å¤„æ·»åŠ è¶…æ—¶ä¿æŠ¤
  const requestTimeout = setTimeout(() => {
    if (document.getElementById(thinkingId)) {
      removeThinkingMessage(thinkingId);
      appendMessage('ai', '<p class="error-message">è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åå†è¯•ã€‚</p>');
      sendBtn.disabled = false;
      sendBtn.textContent = 'æäº¤';
    }
  }, 60000); // 60ç§’è¶…æ—¶

  // åœ¨å‡½æ•°ç»“æŸå‰æ¸…é™¤è¶…æ—¶
  clearTimeout(requestTimeout);
  // ä¸»è¦æé—®å‡½æ•°
  sendBtn.onclick = async () => {
    const question = questionInput.value.trim();
    if (!question) return;

    // ç¦ç”¨å‘é€æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
    sendBtn.disabled = true;
    sendBtn.textContent = 'å¤„ç†ä¸­...';

    // åœ¨ç•Œé¢æ·»åŠ ç”¨æˆ·æé—®
    appendMessage('user', question);
    questionInput.value = '';  // æ¸…ç©ºè¾“å…¥æ¡†

    // æ·»åŠ "æ€è€ƒä¸­"çš„æç¤º
    const thinkingId = 'thinking-' + Date.now();
    appendThinkingMessage(thinkingId);

    try {
      // è·å–æµå¼æ¨¡å¼è®¾ç½®
      const useStream = document.getElementById('stream-toggle').checked;

      // è°ƒç”¨RAGå‡½æ•°è·å–è¯·æ±‚IDæˆ–ç›´æ¥è·å–ç­”æ¡ˆ
      const result = await initiateRequest(question, sessionId, useStream);

      // å¦‚æœæ”¶åˆ°ç›´æ¥ç­”æ¡ˆ
      if (result.directAnswer) {
        removeThinkingMessage(thinkingId);
        appendMessage('ai', `<p>${result.answer}</p>`);
        // æ¢å¤å‘é€æŒ‰é’®
        sendBtn.disabled = false;
        sendBtn.textContent = 'æäº¤';
        return;
      }

      // å¦‚æœæ”¶åˆ°æµå¼é…ç½®
      if (result.streamConfig) {
        const streamResult = await handleStreamingResponse(result.streamConfig, thinkingId);
        if (streamResult === false) {
          // æµå¼å¤„ç†å¤±è´¥ï¼Œå›é€€åˆ°æ ‡å‡†å¤„ç†
          const standardResult = await initiateRequest(question, sessionId, false);
          if (!standardResult.directAnswer) {
            // å¯åŠ¨å¸¸è§„è½®è¯¢
            const pollResult = await pollForResult(standardResult.requestId, thinkingId);
            removeThinkingMessage(thinkingId);
            handleResult(pollResult);
          } else {
            removeThinkingMessage(thinkingId);
            appendMessage('ai', `<p>${standardResult.answer}</p>`);
          }
        }

        // æµå¼å¤„ç†æˆåŠŸï¼Œå·²æ˜¾ç¤ºå›ç­”
        sendBtn.disabled = false;
        sendBtn.textContent = 'æäº¤';
        return;
      }

      // å¦‚æœæ”¶åˆ°äº†å¿«é€Ÿå“åº”ï¼Œå…ˆæ˜¾ç¤ºå®ƒ
      if (result.quickResponse) {
        // æ˜¾ç¤ºå¿«é€Ÿå“åº”ï¼Œä½†ä¿ç•™"thinking"çŠ¶æ€ï¼Œå› ä¸ºå®Œæ•´ç­”æ¡ˆè¿˜åœ¨ç”Ÿæˆä¸­
        updateThinkingMessageWithText(thinkingId, result.quickResponse);
      }

      // å¼€å§‹è½®è¯¢æ£€æŸ¥ç»“æœ
      const pollResult = await pollForResult(result.requestId, thinkingId);

      // ç§»é™¤"æ€è€ƒä¸­"æç¤º
      removeThinkingMessage(thinkingId);

      // æ ¹æ®ç»“æœæ›´æ–°UI
      handleResult(pollResult);

    } catch(err) {
      // ç§»é™¤"æ€è€ƒä¸­"æç¤º
      removeThinkingMessage(thinkingId);
      console.error('å¤„ç†å¤±è´¥:', err);
      // appendMessage('ai', `<p class="error-message">æŠ±æ­‰ï¼Œè·å–å›ç­”å¤±è´¥: ${err.message}</p>`);
    } finally {
      // æ¢å¤å‘é€æŒ‰é’®
      sendBtn.disabled = false;
      sendBtn.textContent = 'æäº¤';
    }
  };

  // æ·»åŠ æ˜¾ç¤ºå¿«é€Ÿå“åº”ä½†ä¿æŒåŠ è½½çŠ¶æ€çš„å‡½æ•°
  function updateThinkingMessageWithText(id, text) {
    const thinkingDiv = document.getElementById(id);
    if (!thinkingDiv) return;

    // ä¿ç•™åŠ¨ç”»å…ƒç´ 
    const dots = thinkingDiv.querySelector('.dots');

    // æ›´æ–°å†…å®¹ï¼ŒåŒ…å«å¿«é€Ÿå“åº”å’ŒåŠ è½½æŒ‡ç¤ºå™¨
    thinkingDiv.innerHTML = `
      <p>${text}</p>
      <p class="loading-more">æ­£åœ¨ç”Ÿæˆå®Œæ•´å›ç­”<span class="dots">...</span></p>
    `;

    // é‡æ–°å¼€å§‹åŠ¨ç”»
    animateThinking(id);
  }

  // è½®è¯¢æ£€æŸ¥ç»“æœ
// æ›´æ–°çš„ pollForResult å‡½æ•°
async function pollForResult(requestId, thinkingId, attempts = 0) {
  try {
    // è¶…å‡ºæœ€å¤§å°è¯•æ¬¡æ•°æ—¶åœæ­¢
    if (attempts >= MAX_POLL_ATTEMPTS) {
      console.log(`è¾¾åˆ°æœ€å¤§è½®è¯¢æ¬¡æ•° ${MAX_POLL_ATTEMPTS}`);
      return {
        status: "timeout",
        requestId: requestId,
        message: "å¤„ç†æ—¶é—´è¾ƒé•¿ï¼Œè¯·ç¨åæ£€æŸ¥ç»“æœã€‚"
      };
    }

    // æ›´æ–°æ€è€ƒä¸­åŠ¨ç”»ä»¥æä¾›è§†è§‰åé¦ˆ
    updateThinkingMessage(thinkingId, attempts);

    let response;

    // å¢åŠ è°ƒè¯•æ—¥å¿—
    console.log(`æ­£åœ¨è½®è¯¢è¯·æ±‚ID: ${requestId}, ä¼šè¯ID: ${sessionId}, å°è¯•æ¬¡æ•°: ${attempts + 1}`);

    try {
      // ä¿æŒä½¿ç”¨ POST è¯·æ±‚è¿›è¡Œè½®è¯¢ï¼ˆç¡®ä¿æœåŠ¡å™¨ç«¯ä¹Ÿæ”¯æŒï¼‰
      response = await fetch(`${API_URL}/status`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache'
        },
        body: JSON.stringify({
          requestId: requestId,
          sessionId: sessionId
        })
      });

      console.log(`è½®è¯¢å“åº”çŠ¶æ€ç : ${response.status}`);
    } catch (fetchError) {
      console.error(`è½®è¯¢è¯·æ±‚å¤±è´¥: ${fetchError.message}`);

      // å¦‚æœ POST å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ GET ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
      console.log("å°è¯•ä½¿ç”¨ GET è¯·æ±‚ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ...");
      response = await fetch(`${API_URL}/status?requestId=${encodeURIComponent(requestId)}&sessionId=${encodeURIComponent(sessionId)}`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      });

      console.log(`å¤‡é€‰ GET è¯·æ±‚å“åº”çŠ¶æ€ç : ${response.status}`);
    }

    if (!response.ok) {
      throw new Error(`æœåŠ¡å™¨è¿”å›é”™è¯¯: ${response.status}`);
    }

    const result = await response.json();
    console.log("è½®è¯¢ç»“æœ:", result);

    // æ£€æŸ¥çŠ¶æ€å¹¶å¤„ç†
    if (result.status === 'completed' && result.answer) {
      console.log("æ”¶åˆ°å›ç­”:", result.answer.substring(0, 50) + "...");
      return result;
    } else if (result.status === 'failed') {
      console.error("è¯·æ±‚å¤±è´¥:", result.error);
      return {
        status: "error",
        error: result.error || "å¤„ç†è¯·æ±‚æ—¶å‡ºé”™"
      };
    } else {
      // ç»§ç»­è½®è¯¢ - è¿™é‡Œæ˜¯å…³é”®ä¿®å¤
      console.log(`çŠ¶æ€: ${result.status}ï¼Œç­‰å¾… ${POLL_INTERVAL}ms åé‡è¯•`);
      await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
      return pollForResult(requestId, thinkingId, attempts + 1);
    }
  } catch (error) {
    console.error("è½®è¯¢é”™è¯¯:", error);

    // è½®è¯¢å‡ºé”™åçŸ­æš‚ç­‰å¾…ç„¶åé‡è¯•ï¼Œä½†ä¸è¶…è¿‡æœ€å¤§å°è¯•æ¬¡æ•°
    if (attempts < MAX_POLL_ATTEMPTS - 1) {
      console.log(`è½®è¯¢å‡ºé”™ï¼Œ${POLL_INTERVAL}ms åé‡è¯•...`);
      await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
      return pollForResult(requestId, thinkingId, attempts + 1);
    }

    return {
      status: "error",
      error: error.message || "è½®è¯¢è¿‡ç¨‹ä¸­é‡åˆ°é”™è¯¯"
    };
  }
}

  // function addDebugButton() {
  //   if (localStorage.getItem('enableDebug') === 'true') {
  //     const inputArea = document.getElementById('input-area');
  //     const debugBtn = document.createElement('button');
  //     debugBtn.id = 'debug-btn';
  //     debugBtn.textContent = 'è°ƒè¯•ä¿¡æ¯';
  //     debugBtn.style.marginLeft = '10px';
  //     debugBtn.style.backgroundColor = '#888';
  //
  //     debugBtn.onclick = () => {
  //       const debugInfo = {
  //         sessionId,
  //         apiUrl: API_URL,
  //         userAgent: navigator.userAgent,
  //         screenSize: `${window.innerWidth}x${window.innerHeight}`,
  //         lastError: localStorage.getItem('lastError') || 'æ— é”™è¯¯'
  //       };
  //
  //       alert(JSON.stringify(debugInfo, null, 2));
  //     };
  //
  //     inputArea.appendChild(debugBtn);
  //   }
  // }
  //
  // // åœ¨å‡ºé”™æ—¶ä¿å­˜é”™è¯¯ä¿¡æ¯
  // window.addEventListener('error', function(event) {
  //   localStorage.setItem('lastError', JSON.stringify({
  //     message: event.message,
  //     source: event.filename,
  //     line: event.lineno,
  //     column: event.colno,
  //     time: new Date().toISOString()
  //   }));
  // });
  //
  // // æ·»åŠ åˆ°DOMContentLoadedäº‹ä»¶ä¸­
  // window.addEventListener('DOMContentLoaded', () => {
  //   addClearSessionButton();
  //   addStreamToggle();
  //   addDebugButton();
  // });

  // å¤„ç†æœ€ç»ˆç»“æœ
  function handleResult(result) {
    if (result.status === "timeout") {
      // è¶…æ—¶ä½†ä»åœ¨å¤„ç†
      appendMessage('ai', `<p class="processing-message">
        ${result.message}
        <button onclick="checkAnswer('${result.requestId}')">æ£€æŸ¥æ˜¯å¦å·²å®Œæˆ</button>
      </p>`);
      return;
    }

    if (result.answer) {
      // æ›´æ–°ä¼šè¯ID
      if (result.sessionId) {
        sessionId = result.sessionId;
        localStorage.setItem('chatSessionId', sessionId);
      }

      // æ¸²æŸ“å›ç­”
      const answerHtml = marked.parse(result.answer);
      appendMessage('ai', answerHtml);

    } else {
      // æ²¡æœ‰å›ç­”
      appendMessage('ai', '<p class="error-message">å¤„ç†å®Œæˆï¼Œä½†æ²¡æœ‰è·å¾—å›ç­”</p>');
    }
  }

  // æ·»åŠ æ£€æŸ¥åŠŸèƒ½
  async function checkAnswer(requestId) {
    if (!requestId) return;

    const thinkingId = 'checking-' + Date.now();
    appendThinkingMessage(thinkingId);

    try {
      const result = await pollForResult(requestId, thinkingId, 0);
      removeThinkingMessage(thinkingId);
      handleResult(result);
    } catch (error) {
      removeThinkingMessage(thinkingId);
      appendMessage('ai', `<p class="error-message">æ£€æŸ¥å¤±è´¥: ${error.message}</p>`);
    }
  }

  // æ›´æ–°"æ€è€ƒä¸­"æç¤ºï¼Œä½¿è½®è¯¢è¿‡ç¨‹æ›´ç”ŸåŠ¨
  function updateThinkingMessage(id, attempts) {
    const thinkingDiv = document.getElementById(id);
    if (!thinkingDiv) return;

    const thinkingTexts = [
      'æ€è€ƒä¸­',
      'æœç´¢çŸ¥è¯†åº“ä¸­',
      'æ•´ç†å›ç­”ä¸­',
      'æ­£åœ¨ç”Ÿæˆå›ç­”',
      'å³å°†å®Œæˆ'
    ];

    // æ ¹æ®è½®è¯¢æ¬¡æ•°é€‰æ‹©ä¸åŒçš„æç¤ºæ–‡æœ¬
    const index = Math.min(Math.floor(attempts / 6), thinkingTexts.length - 1);
    const dotsElem = thinkingDiv.querySelector('.dots');

    if (dotsElem) {
      const messageElem = dotsElem.parentElement;
      messageElem.textContent = thinkingTexts[index];
      messageElem.appendChild(dotsElem);
    }
  }

  function appendMessage(sender, content) {
    const msgDiv = document.createElement('div');
    msgDiv.className = sender === 'user' ? 'user-message' : 'ai-message';
    // å¦‚æœæ˜¯AIæ¶ˆæ¯ï¼Œcontentå¯èƒ½æ˜¯HTMLå­—ç¬¦ä¸²
    msgDiv.innerHTML = sender === 'user' ?
      `<p>${content}</p>` : content;
    chatLog.appendChild(msgDiv);
    chatLog.scrollTop = chatLog.scrollHeight; // æ»šåŠ¨åˆ°åº•éƒ¨
  }

  function appendThinkingMessage(id) {
    const thinkingDiv = document.createElement('div');
    thinkingDiv.id = id;
    thinkingDiv.className = 'ai-message thinking';
    thinkingDiv.innerHTML = '<p>æ€è€ƒä¸­<span class="dots">...</span></p>';
    chatLog.appendChild(thinkingDiv);
    chatLog.scrollTop = chatLog.scrollHeight;

    // æ·»åŠ åŠ¨ç”»æ•ˆæœ
    animateThinking(id);
  }

  function removeThinkingMessage(id) {
    const thinkingDiv = document.getElementById(id);
    if (thinkingDiv) {
      thinkingDiv.remove();
    }
  }

  function animateThinking(id) {
    const thinkingDiv = document.getElementById(id);
    if (!thinkingDiv) return;

    const dots = thinkingDiv.querySelector('.dots');
    if (!dots) return;

    let count = 0;

    const interval = setInterval(() => {
      if (!document.getElementById(id)) {
        clearInterval(interval);
        return;
      }

      count = (count + 1) % 4;
      dots.textContent = '.'.repeat(count);
    }, 500);
  }

  // å…è®¸æŒ‰Enteré”®å‘é€æ¶ˆæ¯
  questionInput.addEventListener('keydown', (e) => {
    // Ctrl+Enter æˆ– åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šç›´æ¥ Enter å‘é€
    if ((e.ctrlKey && e.key === 'Enter') ||
        (window.innerWidth <= 768 && e.key === 'Enter' && !e.shiftKey)) {
      e.preventDefault();
      sendBtn.click();
    }
  });

  // æ·»åŠ æµå¼å“åº”åˆ‡æ¢å¼€å…³
  function addStreamToggle() {
    const inputArea = document.getElementById('input-area');

    // åˆ›å»ºåˆ‡æ¢å®¹å™¨
    const toggleContainer = document.createElement('div');
    toggleContainer.className = 'toggle-container';

    // åˆ›å»ºåˆ‡æ¢å¼€å…³
    const toggleLabel = document.createElement('label');
    toggleLabel.className = 'toggle-switch';
    toggleLabel.innerHTML = `
      <input type="checkbox" id="stream-toggle" checked>
      <span class="toggle-slider"></span>
    `;

    // åˆ›å»ºæ ‡ç­¾æ–‡æœ¬
    const toggleText = document.createElement('span');
    toggleText.className = 'toggle-text';
    toggleText.textContent = 'æµå¼å“åº”';

    // ç»„è£…å…ƒç´ 
    toggleContainer.appendChild(toggleLabel);
    toggleContainer.appendChild(toggleText);

    // æ·»åŠ åˆ°UI
    inputArea.appendChild(toggleContainer);
  }

  // æ·»åŠ æ¸…é™¤ä¼šè¯æŒ‰é’®
  function addClearSessionButton() {
    const inputArea = document.getElementById('input-area');
    const clearBtn = document.createElement('button');
    clearBtn.id = 'clear-session';
    clearBtn.textContent = 'æ–°å¯¹è¯';
    clearBtn.title = 'å¼€å§‹æ–°çš„å¯¹è¯ï¼Œæ¸…é™¤å¯¹è¯å†å²';
    clearBtn.style.marginLeft = '10px';

    clearBtn.onclick = () => {
      if (confirm('ç¡®å®šè¦å¼€å§‹æ–°çš„å¯¹è¯å—ï¼Ÿè¿™å°†æ¸…é™¤å½“å‰çš„å¯¹è¯å†å²ã€‚')) {
        localStorage.removeItem('chatSessionId');
        sessionId = null;
        chatLog.innerHTML = '';
        appendMessage('ai', '<p>å·²å¼€å§‹æ–°çš„å¯¹è¯ã€‚</p>');
      }
    };

    inputArea.appendChild(clearBtn);
  }

  // æ·»åŠ å…¨å±€å‡½æ•°ï¼Œä½¿æŒ‰é’®onclickèƒ½æ­£å¸¸å·¥ä½œ
  window.checkAnswer = checkAnswer;

  // é¡µé¢åŠ è½½å®Œæˆåæ·»åŠ æ§åˆ¶ç»„ä»¶
  window.addEventListener('DOMContentLoaded', () => {
    addClearSessionButton();
    addStreamToggle();
  });
</script>

<style>
  /* æ ·å¼ä¼˜åŒ– */
  #chat-container {
    max-width: 800px;
    margin: 0 auto;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    height: 70vh;
    min-height: 500px;
  }

  #chat-log {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    background-color: #f9f9f9;
  }

  #input-area {
    display: flex;
    padding: 10px;
    background-color: #fff;
    border-top: 1px solid #e0e0e0;
    flex-wrap: wrap;
  }

  #question {
    flex: 1;
    min-height: 60px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    resize: vertical;
    font-family: inherit;
    font-size: 16px;
  }

  #send-btn, #clear-session {
    padding: 10px 15px;
    margin-left: 10px;
    background-color: #99999a;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.2s;
  }

  #send-btn:hover, #clear-session:hover {
    background-color: #a8a5a5;
  }

  #send-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
  }

  .user-message, .ai-message {
    max-width: 80%;
    margin-bottom: 15px;
    padding: 10px 15px;
    border-radius: 18px;
    line-height: 1.5;
  }

  .user-message {
    background-color: #e3f2fd;
    margin-left: auto;
    border-bottom-right-radius: 4px;
  }

  .ai-message {
    background-color: #f1f1f1;
    margin-right: auto;
    border-bottom-left-radius: 4px;
  }

  .thinking {
    opacity: 0.8;
  }

  .loading-more {
    font-size: 14px;
    color: #666;
    margin-top: 8px;
    font-style: italic;
  }

  .error-message {
    color: #d32f2f;
  }

  .processing-message {
    color: #f57c00;
  }

  /* ä»£ç å—æ ·å¼ä¼˜åŒ– */
  pre {
    background-color: #282c34;
    border-radius: 4px;
    padding: 15px;
    overflow-x: auto;
    color: #abb2bf;
  }

  code {
    font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
  }

  /* æµå¼å“åº”ç›¸å…³æ ·å¼ */
  .toggle-container {
    display: flex;
    align-items: center;
    margin-left: 10px;
  }

  .toggle-switch {
    position: relative;
    display: inline-block;
    width: 40px;
    height: 20px;
  }

  .toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 34px;
  }

  .toggle-slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
  }

  input:checked + .toggle-slider {
    background-color: #0066cc;
  }

  input:checked + .toggle-slider:before {
    transform: translateX(20px);
  }

  .toggle-text {
    margin-left: 8px;
    font-size: 14px;
  }

  .ai-message.streaming .content {
    border-right: 2px solid #0066cc;
    animation: blinking 1s infinite;
  }

  .stream-indicator {
    font-size: 12px;
    color: #0066cc;
    margin-top: 5px;
    font-style: italic;
  }

  @keyframes blinking {
    0% { border-color: transparent; }
    50% { border-color: #0066cc; }
    100% { border-color: transparent; }
  }

  /* ç§»åŠ¨è®¾å¤‡é€‚é… */
  @media (max-width: 768px) {
    #chat-container {
      height: 80vh;
      min-height: 400px;
      border: none;
      border-radius: 0;
    }

    #input-area {
      padding: 8px;
    }

    #question {
      min-height: 50px;
      font-size: 14px;
    }

    #send-btn, #clear-session {
      padding: 8px 12px;
      font-size: 14px;
    }

    .toggle-container {
      order: 3;
      margin-top: 8px;
      margin-left: 0;
      width: 100%;
      justify-content: center;
    }
  }
</style>
        </main>
        
    </article>
    <!-- Footer -->
    <footer class="footer">
      <p>&copy; 2025 Jasonâ€˜s Blog</p>
    </footer>

    <!-- Custom JavaScript -->
    <script src="/assets/js/main.js"></script>
</body>
<!--<script src="/assets/js/main.js"></script>-->

<!--&lt;!&ndash;<link rel="stylesheet" href="/assets/main.css">&ndash;&gt;-->
<!--<link rel="stylesheet" href="/assets/css/custom.css">-->
</html>